<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<p>[TOC]</p>
<h3 data-content="1" id="780deece7039715072882bec48ad5b64">前言</h3>
<p>这一个需要管理员权限的二次SQL注入，利用起来比较鸡肋。这里仅分享一下挖洞时的思路，不包含具体的poc。</p>
<h3 data-content="1" id="126b09b186f423083bca3573c20cfc00">分析</h3>
<p>漏洞触发点在components/com_content/models/articles.php:L458</p>
<pre><code>$dateFiltering = $this-&gt;getState('filter.date_filtering', 'off');
$dateField     = $this-&gt;getState('filter.date_field', 'a.created');

switch ($dateFiltering)
{
    case 'range':
        ...
        $query-&gt;where(
            '(' . $dateField . ' &gt;= ' . $startDateRange . ' AND ' . $dateField .
            ' &lt;= ' . $endDateRange . ')'
        );
        break;

    ...
 }</code></pre>
<p>可以看到这里的dateField从getState('filter.date_field')取值之后未经任何过滤就直接拼接到where语句中。通过在这个model的逆向查找，并没有找到date_field这个state初始化的地方。我们只能先通过构造入口，来看看使用这个model的控制器是否对date_field进行了初始化。</p>
<p>这个model属于前台的com_content组件，但是这个model的入口与同组件下的其他几个model不太一样。其他的model基本上都可以通过访问这个组件来访问，而articles model在本组件中却没有使用。</p>
<p>程序中有两个名为articles的model，一个在/components，一个在/administrator/components目录下。我在黑盒测试的时候构造了一个url如下：</p>
<pre><code>/index.php?option=com_content&amp;view=articles&amp;layout=modal&amp;tmpl=component</code></pre>
<p>这里程序中的控制器会根据view和layout的值，将请求直接跳到了administrator目录下的articles中了。但是根据<code>存在即合理，天生我材必有用</code>，/components下面有个前台articles的model，因此程序中一定会有调用这里的地方。最终找到了几处调用前台article的地方，只是有的跟正常调用的不太一样，这里是动态调用。写法大概有如下几种</p>
<pre><code>$model = JModelLegacy::getInstance('Articles', 'ContentModel', array('ignore_request' =&gt; true));

也有动态调用model：
/libraries/src/MVC/Controller/BaseController.php:createModel($model, ...){
    ...
    JModelLegacy::getInstance($modelName, $classPrefix, $config);
    ...
}</code></pre>
<p>通过访问</p>
<pre><code>index.php/blog?252c5a5ef0e3df8493dbe18e7034957e=1</code></pre>
<p>可以到达漏洞点，但是state我们控制不了，因为首先在articles model中没有对date_field做赋值处理，只能寄希望于调用这个model的地方能对date_field赋值。可是通过查看代码发现，当前的index.php/blog路由背后的com_content组件并没有对date_field进行初始化，因此这个组件只能放弃，看看其他的。</p>
<p>终于，在一个module：mod_articles_popular的helper类中找到了有设置date_field的地方，大概如下/modules/mod_articles_popular/helper.php</p>
<pre><code>function getList(&amp;$params){
    $model = JModelLegacy::getInstance('Articles', 'ContentModel', array('ignore_request' =&gt; true)); //调用articles model
    ...
    $date_filtering = $params-&gt;get('date_filtering', 'off');
    if ($date_filtering !== 'off'){
        $model-&gt;setState('filter.date_filtering', $date_filtering);
        $model-&gt;setState('filter.date_field', $params-&gt;get('date_field', 'a.created'));
        ...
    }
    ...
}</code></pre>
<p>可以看到这里通过\$params-&gt;get('date_field')来进行赋值，这里的param是从modules表中取出的。通过逆向查找发现，/libraries/src/Helper/ModuleHelper.php:getModuleList()方法会从modules表取出module的属性（包括param），然后在/libraries/src/Document/Renderer/Html/ModulesRenderer.php:render():L45对module进行遍历并渲染：</p>
<pre><code>foreach (ModuleHelper::getModules($position) as $mod){
    $moduleHtml = $renderer-&gt;render($mod, $params, $content);
    ...
}</code></pre>
<p>到这里我们理一下思路，首先是那个SQL注入点，date_field，需要从param中获取值，而param又是从module在数据库中对应的param获取的。因此我们这里可以考虑一下二次注入。由于在获取date_field的值时使用了<code>$this-&gt;getState('filter.date_field', 'a.created');</code>，且默认值为a.created，因此猜测这个字段在某个部分是可以修改的。</p>
<p>通过对漏洞点和此module附近的功能与逻辑进行部分了解之后，可以发现在首页的module编辑中，可以直接编辑date_field字段！因此我们只要点击保存后抓包修改一下date_field的内容即可将之写进modules表中！</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191224004136-15cd3100-25a3-1.png"/></p>
<p>这里回到最开始的漏洞点</p>
<pre><code>$dateFiltering = $this-&gt;getState('filter.date_filtering', 'off');
$dateField     = $this-&gt;getState('filter.date_field', 'a.created');

switch ($dateFiltering)
{
    case 'range':
        $startDateRange = $db-&gt;quote($this-&gt;getState('filter.start_date_range', $nullDate));
        $endDateRange   = $db-&gt;quote($this-&gt;getState('filter.end_date_range', $nullDate));
        $query-&gt;where(
            '(' . $dateField . ' &gt;= ' . $startDateRange . ' AND ' . $dateField .
            ' &lt;= ' . $endDateRange . ')'
        );//vuln 
        break;

    ....</code></pre>
<p>可以看到这里还有个dateFiltering的限制。其实我们只要在刚刚的module设置中把date_filtering设置为range即可。</p>
<h3 data-content="1" id="26aa4fc4edc6b7faf7f702910ba0f144">更好的注入</h3>
<p>可是目前为止这个漏洞还只是盲注而已。。回显它不香吗？并且之前拼接的SQL语句执行之后会报错</p>
<pre><code>Unknown column 'a.hits' in 'order clause'</code></pre>
<p>由于最后有个order by一个不可控的column名，并且我们不知道a.hits列名的表叫什么（每个Joomla系统的表前缀都默认是随机的），因此我们不能很好的union出数据。这里最简单的办法就是看看是否能控制order by的值，比如将之置为1。查看代码发现这个order by的确是可以控制的，就在之前的漏洞点下面几行</p>
<pre><code>$query-&gt;order($this-&gt;getState('list.ordering', 'a.ordering') . ' ' . $this-&gt;getState('list.direction', 'ASC'));</code></pre>
<p>这里依旧是通过getState()来进行取值。通过回看模块mod_articles_popular的赋值点，发现这里写死成a.hits了</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191224004207-285b4316-25a3-1.png"/></p>
<p>因此这个module就不太好用了，我们要考虑另一个list.ordering可控的module，结果就发现了模块mod_articles_category，满足我们的所有幻想：date_field可控、date_filtering可控、list.ordering可控</p>
<pre><code>$ordering = $params-&gt;get('article_ordering', 'a.ordering');

switch ($ordering){
    ...
    default:
        $articles-&gt;setState('list.ordering', $ordering);
        ...
}

$date_filtering = $params-&gt;get('date_filtering', 'off');
if ($date_filtering !== 'off'){
    $articles-&gt;setState('filter.date_filtering', $date_filtering);
    $articles-&gt;setState('filter.date_field', $params-&gt;get('date_field', 'a.created'));

    ...</code></pre>
<p>同理，登陆后在首页编辑模块，然后将相应的值改掉就好了。经过测试发现这里的list.ordering没有进行任何的过滤，因此可以算是一个单独的order by注入。不过这里我们的目标是只要将order by的列置为1即可，以便在date_field的位置进行union 注入。</p>
<h3 data-content="1" id="1170cbb044b96f7447258bf54ffee440">利用</h3>
<p>这里仅放出效果图，具体的poc就不公开了</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191224004234-389adac0-25a3-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191224004246-3f5f1a6a-25a3-1.png"/></p>
<h3 data-content="1" id="955ea2442e320fd8d517473a9d55073e">总结</h3>
<p>这个洞还是比较鸡肋的，1是需要最高的super user权限，2是由于有token校验无法进行csrf，因此把这个漏洞限制成只能有sa账号才能进行利用。</p>
<h3 data-content="1" id="830fb879b33a9023c2544881a95b48b2">补丁分析</h3>
<p>在最新版的3.9.14中，通过diff发现官方做的修复很简单，只是在module中存储时对字段进行了校验</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191224004315-510f4b9a-25a3-1.png"/></p>
<p>也就是只加了个<code>validate="options"</code>。下面我们要跟进一下这个字段有何意义，在这之前我们要先搞懂这个xml文件是啥。</p>
<p>下图是利用链的第一部分：module的目录结构</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191224004326-577bc68e-25a3-1.png"/></p>
<p>helper.php是我们利用的文件，而这个xml配置文件主要是包含了当前module的一些基本信息，以及一些<code>参数</code>的信息，包括参数的描述、type、默认值、值范围等等，这是我们需要重点关注的。以我们的poc中的date_filter作为例子：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191224004042-f5e8c82c-25a2-1.png"/></p>
<p>可以看到它的默认值是<code>a.title</code>，同时下面还有很多option标签，也就是说这个字段的值只能是option标签的值的其中一个。</p>
<p>但是说是这么说，Joomla在这次补丁之前并没有进行校验，也就是前面说的<code>validate="options"</code>。</p>
<p>下面跟进源码走一下，下面的代码是保存param之前的逻辑</p>
<pre><code>/libraries/src/MVC/Controller/FormController.php

public function save(...) {
    ....
    $data  = $this-&gt;input-&gt;post-&gt;get('jform', array(), 'array');//获取用户传参
    ....
    $form = $model-&gt;getForm($data, false);
    ....
    $validData = $model-&gt;validate($form, $data);//校验
    ...
    if (!$model-&gt;save($validData)) {//保存
        ..error...
    }

    ...

    return true;
}</code></pre>
<p>跟进这里的validate，底层代码如下</p>
<pre><code>/libraries/src/MVC/Model/FormModel.php

public function validate(...) {
    ...
    $data = $form-&gt;filter($data);
    $return = $form-&gt;validate($data, $group);

    ...
    return $data;
}</code></pre>
<p>继续跟进validate</p>
<pre><code>/libraries/src/Form/Form.php

public function validate($data, $group = null)
{
    ...

    // Create an input registry object from the data to validate.
    $input = new Registry($data);

    // Get the fields for which to validate the data.
    $fields = $this-&gt;findFieldsByGroup($group);

    ...

    // Validate the fields.
    foreach ($fields as $field)//
    {
        $value = null;
        $name = (string) $field['name'];

        // Get the group names as strings for ancestor fields elements.
        $attrs = $field-&gt;xpath('ancestor::fields[@name]/@name');
        $groups = array_map('strval', $attrs ? $attrs : array());
        $group = implode('.', $groups);

        // Get the value from the input data.
        if ($group)
        {
            $value = $input-&gt;get($group . '.' . $name);
        }
        else
        {
            $value = $input-&gt;get($name);
        }

        // Validate the field.
        $valid = $this-&gt;validateField($field, $group, $value, $input);//

        // Check for an error.
        if ($valid instanceof \Exception)
        {
            $this-&gt;errors[] = $valid;
            $return         = false;
        }
    }

    return $return;
}</code></pre>
<p>跟进validateField</p>
<pre><code>protected function validateField(\SimpleXMLElement $element, $group = null, $value = null, Registry $input = null)
{
    ...

    // Get the field validation rule.
    if ($type = (string) $element['validate'])//根据xml中的每个field节点的"validate"属性做校验
    {
        // Load the JFormRule object for the field.
        $rule = $this-&gt;loadRuleType($type);//如果$type是options，则$rule为类"Joomla\\CMS\\Form\\Rule\\OptionsRule"的实例化

        ...

        // Run the field validation rule test.
        $valid = $rule-&gt;test($element, $value, $group, $input, $this);//

        // Check for an error in the validation test.
        if ($valid instanceof \Exception)
        {
            return $valid;
        }
    }</code></pre>
<p>这里获取<code>validate</code>属性的值之后，调用对应类的test方法。这里我们以本次的补丁为例<code>validate=options</code>，跟进OptionsRule的test方法</p>
<pre><code>public function test(\SimpleXMLElement $element, $value, $group = null, Registry $input = null, Form $form = null)
{
    // Check if the field is required.
    $required = ((string) $element['required'] == 'true' || (string) $element['required'] == 'required');

    if (!$required &amp;&amp; empty($value))
    {
        return true;
    }

    // Make an array of all available option values.
    $options = array();

    // Create the field
    $field = null;

    if ($form)
    {
        $field = $form-&gt;getField((string) $element-&gt;attributes()-&gt;name, $group);
    }

    // When the field exists, the real options are fetched.
    // This is needed for fields which do have dynamic options like from a database.
    if ($field &amp;&amp; is_array($field-&gt;options))
    {
        foreach ($field-&gt;options as $opt)//取出所有option节点
        {
            $options[] = $opt-&gt;value;//取出field节点对应的option子节点，用于后面进行in_array()校验合法性
        }
    }
    else
    {
        foreach ($element-&gt;option as $opt)//取出所有option节点
        {
            $options[] = $opt-&gt;attributes()-&gt;value;//取出field节点对应的option子节点，用于后面进行in_array()校验合法性
        }
    }

    // There may be multiple values in the form of an array (if the element is checkboxes, for example).
    if (is_array($value))
    {
        // If all values are in the $options array, $diff will be empty and the options valid.
        $diff = array_diff($value, $options);//校验

        return empty($diff);
    }
    else
    {
        // In this case value must be a string
        return in_array((string) $value, $options);//校验
    }
}</code></pre>
<p>原理比较简单，就是通过<code>in_array()和array_diff()</code>将用户输入值与option节点的值进行对比。</p>
</div>
</div>