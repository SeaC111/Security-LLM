<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h2 data-content="1" id="8c9cf2b030cb4c8f2cb22349e1d02c81">什么是Shiro</h2>
<p><a href="https://shiro.apache.org/" target="_blank">Apache Shiro</a> is a powerful and easy-to-use Java security framework that performs authentication(身份验证), authorization(授权), cryptography(加密), and session management(会话管理). With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.</p>
<h2 data-content="1" id="5b3ef935414df417c108918524e7111f">相关CVE</h2>
<p>根据官方网站上的<a href="https://shiro.apache.org/security-reports.html" target="_blank">漏洞通报</a>，<code>Shiro</code> 在历史上共通报了 <code>11</code> 个 <code>CVE</code>（以及最新披露的CVE），其中包含认证绕过、反序列化等漏洞类型，接下来我们来依次学习。</p>
<table>
<thead>
<tr>
<th>漏洞编号</th>
<th>Shiro版本</th>
<th>配置</th>
<th>漏洞形式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CVE-2010-3863</code></td>
<td>
<code>shiro &lt; 1.1.0</code> 和<code>JSecurity 0.9.x</code>
</td>
<td><code>/** = anon</code></td>
<td><code>/./remoting.jsp</code></td>
</tr>
<tr>
<td>
<code>CVE-2014-0074</code>/<code>SHIRO-460</code>
</td>
<td><code>shiro 1.x &lt; 1.2.3</code></td>
<td>-</td>
<td>
<code>ldap</code>、空密码、空用户名、匿名</td>
</tr>
<tr>
<td>
<code>CVE-2016-4437</code>/<code>SHIRO-550</code>
</td>
<td><code>shiro 1.x &lt; 1.2.5</code></td>
<td>-</td>
<td>
<code>RememberMe</code>、硬编码</td>
</tr>
<tr>
<td><code>CVE-2016-6802</code></td>
<td><code>shiro &lt; 1.3.2</code></td>
<td>
<code>Context Path</code>绕过</td>
<td><code>/x/../context/xxx.jsp</code></td>
</tr>
<tr>
<td>
<code>CVE-2019-12422</code>/<code>SHIRO-721</code>
</td>
<td><code>shiro &lt; 1.4.2</code></td>
<td>-</td>
<td>
<code>RememberMe</code>、<code>Padding Oracle Attack</code>、<code>CBC</code>
</td>
</tr>
<tr>
<td>
<code>CVE-2020-1957</code>/<code>SHIRO-682</code>
</td>
<td><code>shiro &lt; 1.5.2</code></td>
<td><code>/** = anon</code></td>
<td>
<code>/toJsonPOJO/</code>,<code>Spring Boot &lt; 2.3.0.RELEASE</code> -&gt; <code>/xx/..;/toJsonPOJO</code>
</td>
</tr>
<tr>
<td>
<code>CVE-2020-11989</code>/ <code>SHIRO-782</code>
</td>
<td><code>shiro &lt; 1.5.3</code></td>
<td>(等于1.5.2）<code>/toJsonList/* = authc</code>；(小于1.5.3）<code>/alter/* = authc &amp;&amp; /** = anon</code>
</td>
<td>(等于1.5.2）<code>/</code>的两次编码 -&gt; <code>%25%32%66</code> <code>/toJsonList/a%25%32%66a -&gt;/toJsonList/a%2fa</code>；（小于1.5.3）<code>/;/shirodemo/alter/test -&gt; /shirodemo/alter/test</code> (<code>Shiro &lt; 1.5.2</code>版本的话，根路径是什么没有关系)</td>
</tr>
<tr>
<td><code>CVE-2020-13933</code></td>
<td><code>shiro &lt; 1.6.0</code></td>
<td><code>/hello/* = authc</code></td>
<td><code>/hello/%3ba -&gt; /hello/;a</code></td>
</tr>
<tr>
<td><code>CVE-2020-17510</code></td>
<td><code>shiro &lt; 1.7.0</code></td>
<td><code>/hello/* = authc</code></td>
<td>
<code>/hello/%2e -&gt; /hello/.</code>  (<code>/%2e</code>、<code>/%2e/</code>、<code>/%2e%2e</code>、<code>/%2e%2e/</code>都可以）</td>
</tr>
<tr>
<td><code>CVE-2020-17523</code></td>
<td><code>shiro &lt; 1.7.1</code></td>
<td><code>/hello/* = authc</code></td>
<td><code>/hello/%20 -&gt; /hello/%20</code></td>
</tr>
<tr>
<td><code>CVE-2021-41303</code></td>
<td><code>shiro &lt; 1.8.0</code></td>
<td>
<code>/admin/* = authc</code> &amp;&amp; <code>/admin/page = anon</code>
</td>
<td><code>/admin/page/ -&gt; /admin/page</code></td>
</tr>
<tr>
<td><code>CVE-2022-32532</code></td>
<td><code>shiro &lt; 1.9.1</code></td>
<td>
<code>RegExPatternMatcher</code> &amp;&amp; <code>/alter/.*</code>
</td>
<td>
<code>/alter/a%0aaa -&gt; /alter/a%0aaa</code>;<code>/alter/a%0daa -&gt; /alter/a%0daa</code>
</td>
</tr>
</tbody>
</table>
<h2 data-content="1" id="48cfbc4e82a9f2bdc33534decfd03b38">CVE-2010-3863</h2>
<h3 data-content="1" id="ebf765df029eb598e2f5e2beaca62e75">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3863" target="_blank">CVE-2010-3863</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2010-2715" target="_blank">CNVD-2010-2715</a><br/>
影响版本：<code>shiro &lt; 1.1.0</code> 和<code>JSecurity 0.9.x</code><br/>
漏洞描述：<code>Shiro</code>进行权限验证前未进行路径标准化，导致使用时可能绕过权限校验<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/ab8294940a19743583d91f0c7e29b405d197cc34" target="_blank">Commit</a></p>
<h3 data-content="1" id="e4db8d99dda69710c28bbdd011a095a5">漏洞分析</h3>
<p>先分析一下<code>Shiro</code>身份验证的流程：<code>Shiro</code>使用<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code> 方法获取和调用要执行的 <code>Filter</code>，逻辑如下：<br/>
在<code>getPathWithinApplication()</code>方法中调用 <code>WebUtils.getPathWithinApplication()</code>方法，用来获取请求路径。<br/>
其中<code>getContextPath(request)</code>方法获取 <code>Context</code> 路径<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1.png"/><br/>
<code>getRequestUri(request)</code> 方法获取<code>URI</code> 的值，并调用 <code>decodeAndCleanUriString()</code> 处理。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/2.png"/><br/>
在<code>decodeAndCleanUriString()</code>中对 <code>;</code> 进行了截取。<br/>
此时<code>contextPath</code>值为<code>/samples_web_war</code>，<code>requestUri</code>值为<code>/samples_web_war/login.jsp</code><br/>
然后判断<code>requestUri</code>是否以<code>contextPath</code>开始，是的话将其替换为<code>/</code></p>
<p>处理之后的请求 <code>URL</code> 将会使用 <code>AntPathMatcher#doMatch</code> 进行权限验证。<br/>
此时发现，<code>Shiro</code>中对<code>URI</code>并没有进行路径的标准化处理，这样当<code>URI</code>中存在特殊字符时，就存在绕过风险</p>
<h4 data-content="1" id="eceec7e20e9d36fecb41956a079377b1">复现</h4>
<pre><code>[urls]
/login.jsp = authc
/logout = logout
/account/** = authc
/remoting.jsp = authc, perms["audit:list"]
/** = anon</code></pre>
<p>有了上面的配置，直接访问：<code>/remoting.jsp</code>，会因为没有权限而跳转至登陆界面。<br/>
当访问 <code>/./remoting.jsp</code>，由于其不能与配置文件匹配，导致进入了 <code>/**</code> 的匹配范围，导致可以越权访问。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/3.png"/></p>
<h3 data-content="1" id="541b9595020d5430d840839b751d0bbe">漏洞修复</h3>
<p><code>Shiro</code> 在 <a href="https://github.com/apache/shiro/commit/ab8294940a19743583d91f0c7e29b405d197cc34" target="_blank">Commit</a> 更新中添加了标准化路径函数。<br/>
对 <code>/</code>、<code>//</code>、<code>/./</code>、<code>/../</code> 等进行了处理。</p>
<h2 data-content="1" id="c0c6e68ee7766bc3d2e8284ae82ffa63">CVE-2014-0074</h2>
<h3 data-content="1" id="947e4820c19bfdbf4a044b1569b2db0a">漏洞信息</h3>
<p>漏洞编号： <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0074" target="_blank">CVE-2014-0074</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2014-03861" target="_blank">CNVD-2014-03861</a> / <a href="https://issues.apache.org/jira/browse/SHIRO-460" target="_blank">SHIRO-460</a><br/>
影响版本：<code>shiro 1.x &lt; 1.2.3</code><br/>
漏洞描述 ：当程序使用<code>LDAP</code>服务器并启用非身份验证绑定时，远程攻击者可借助空的用户名或密码利用该漏洞绕过身份验证。<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/f988846207f98c98ff24213ee9063798ea5d9b6c" target="_blank">Commit</a></p>
<h3 data-content="1" id="7d06232d433e2d362fd580237af23989">漏洞分析</h3>
<p>当使用了未经身份验证绑定的 <code>LDAP</code> 服务器时，允许远程攻击者通过空用户名或空密码绕过身份验证。</p>
<h3 data-content="1" id="ed181f24dbc6cf7412bbb40feb4b428e">漏洞修复</h3>
<p><code>Shiro</code> 在 <a href="https://github.com/apache/shiro/commit/f988846207f98c98ff24213ee9063798ea5d9b6c" target="_blank">f988846</a> 中针对此漏洞进行了修复</p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/0074_1.png"/><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/0074_2.png"/></p>
<h2 data-content="1" id="ca69a68401669b6a29c7116edd41bfab">CVE-2016-4437</h2>
<h3 data-content="1" id="8e6aae28a4373ee490486130182dbf18">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-4437" target="_blank">CVE-2016-4437</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2016-03869" target="_blank">CNVD-2016-03869</a> / <a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank">SHIRO-550</a><br/>
影响版本：<code>shiro 1.x &lt; 1.2.5</code><br/>
漏洞描述：利用硬编码的密钥构造<code>rememberMe</code>参数，进行反序列化攻击<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848" target="_blank">Commit</a><br/>
参考：  <a href="https://www.anquanke.com/post/id/225442" target="_blank">Shiro 550反序列化漏洞分析</a></p>
<h3 data-content="1" id="cff471cd714e629ebe2a8dfc2e4cdb78">漏洞分析</h3>
<p>关键代码处于 <code>AbstractRememberMeManager#getRememberedPrincipals</code> 方法中，参数是用户的身份<code>Context</code>信息，如下图<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/7.png"/><br/>
这个方法主要是把<code>SubjectContext</code> 转化成 <code>PrincipalCollection</code> 。该方法调用了<code>getRememberedSerializedIdentity</code> 和 <code>convertBytesToPrincipals</code> 方法。</p>
<p>其中<code>CookieRememberMeManager</code> 的<code>getRememberedSerializedIdentity</code> 的实现是获取 <code>Cookie</code> 并 <code>Base64</code> 解码<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/8.png"/></p>
<p>将解码后的 <code>byte</code> 数组传入 <code>convertBytesToPrincipals</code> 中进行：<code>decrypt</code> 和 <code>deserialize</code>。<code>decrypt</code> 是使用 <code>AesCipherService</code> 进行解密。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/9.png"/><br/>
<code>deserialize</code> 调用 <code>deserialize()</code> 方法反序列化解密后的数据。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/10.png"/></p>
<p>反序列化得到的 <code>PrincipalCollection</code> 会被 <code>set</code> 到 <code>SubjectContext</code> 。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12.png"/></p>
<p>解密的调用栈入下图所示<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/13.png"/><br/>
此时就可以想象，如果我们有了加密密钥，使用密钥加密一个恶意序列化的<code>payload</code>，将<code>rememberMe</code>的值替换成<code>base64</code>后的<code>payload</code>传入服务器，那这样就可以触发漏洞了。关键点在于，我们如何获取加密密钥？</p>
<p>这就要提到<code>AbstractRememberMeManager</code>类，它是<code>RememberMeManager</code> 接口的实现。类中有几个关键变量：</p>
<ul>
<li>
<code>DEFAULT_CIPHER_KEY_BYTES</code>：对称密钥，使用<code>Base64</code>加密之后直接存在代码中</li>
<li>
<code>serializer</code>：<code>Shiro</code> 提供的序列化器</li>
<li>
<code>cipherService</code>：用来对数据加解密的类</li>
</ul>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/4.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png"/></p>
<h4 data-content="1" id="61fe02b43b53ebc11714d1abb98abca1">漏洞利用</h4>
<p>编写一个<code>poc</code></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">com.alter.Shiro</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.alter.Deserialize.CommonsCollections6</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.shiro.crypto.AesCipherService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.shiro.util.ByteSource</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">payloads</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CommonsCollections6</span><span class="o">().</span><span class="na">getPayload</span><span class="o">(</span><span class="s">"/System/Applications/Calculator.app/Contents/MacOS/Calculator"</span><span class="o">);</span>
        <span class="n">AesCipherService</span> <span class="n">aes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AesCipherService</span><span class="o">();</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="s">"kPH+bIxk5D2deZiIxcaaaA=="</span><span class="o">);</span>

        <span class="n">ByteSource</span> <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">aes</span><span class="o">.</span><span class="na">encrypt</span><span class="o">(</span><span class="n">payloads</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="n">ciphertext</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>

    <span class="o">}</span>
</pre></div>
<p>将生成的<code>payload</code>赋值给<code>rememberMe</code>,但是发送过去后，服务器报错。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/16.png"/><br/>
下面根据<code>p师傅</code>的分析复现一下报错原因，发现是这个类：<code>org.apache.shiro.io.ClassResolvingObjectInputStream</code>的问题。可以看到，这是一个<code>ObjectInputStream</code>的子类，其重写了<code>resolveClass</code>方法（<code>resolveClass</code>是反序列化中用来查找类的方法）：<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17.png"/><br/>
对比一下它的父类，也就是正常的 <code>ObjectInputStream</code> 类中的 <code>resolveClass</code> 方法：<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/18.png"/><br/>
区别就是前者用的是<code>org.apache.shiro.util.ClassUtils#forName</code>(实际上内部用到了<code>org.apache.catalina.loader.ParallelWebappClassLoader#loadClass</code>)，而后者用的是<code>Java</code>原生的<code>Class.forName</code><br/>
调试发现出现异常时加载的类名为<code>[Lorg.apache.commons.collections.Transformer;</code>这个类名看起来怪，其实就是表示<code>org.apache.commons.collections.Transformer</code>的数组。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/19.png"/><br/>
所以，网上很多文章就给出结论，<code>Class.forName</code>支持加载数组，<code>ClassLoader.loadClass</code>不支持加载数组，这个区别导致了问题。但<code>p师傅</code>在<code>Java</code>漫谈中否定了这一观点，并写出结论：如果反序列化流中包含非<code>Java</code>自身的数组，则会出现无法加载类的错误。这就解释了为什么<code>CommonsCollections6</code>无法利用了，因为其中用到了<code>Transformer</code>数组。<br/>
<code>p师傅</code>在漫谈中分析讲解了两种<code>poc</code>，一个是<a href="https://alter1125.github.io/file/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/Shiro550/CommonsCollectionsShiro.java" target="_blank">使用TemplatesImpl改造的无数组CCShiro反序列化链</a>，这个链需要有<code>CC</code>依赖，另一个是<a href="https://alter1125.github.io/file/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/Shiro550/CommonsBeanUtilsShiro.java" target="_blank">CB的无依赖Shiro反序列化链</a><br/>
这两个<code>poc</code>都可以测试成功了。</p>
<h4 data-content="1" id="2a644b3821a72b16b3d79d284f15e7f6">漏洞修复</h4>
<p><code>Shiro</code> 在 <code>1.2.5</code> 的 <a href="https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848" target="_blank">Commit</a> 中对此漏洞进行了修复。系统在启动的时候会生成一个新<code>key</code>，用户也可以手动配置一个<code>cipherKey</code>。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/20.png"/><br/>
其实如果用户设置的密钥泄漏或者太简单的话，还是会被攻击成功。</p>
<p>其实在 <a href="https://issues.apache.org/jira/browse/SHIRO-441" target="_blank">SHIRO-441</a>，就有人提出了硬编码可能带来的问题。</p>
<h2 data-content="1" id="0b5c507d1774c08c103a54389f37b157">CVE-2016-6802</h2>
<h3 data-content="1" id="737d7f9e4faea3a770176f4299e1a65b">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6802" target="_blank">CVE-2016-6802</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2016-07814" target="_blank">CNVD-2016-07814</a><br/>
影响版本：<code>shiro &lt; 1.3.2</code><br/>
漏洞描述：<code>Shiro</code>未对<code>ContextPath</code>做路径标准化导致权限绕过<br/>
漏洞补丁： <a href="https://github.com/apache/shiro/commit/b15ab927709ca18ea4a02538be01919a19ab65af" target="_blank">Commit</a><br/>
参考 ： <a href="https://su18.org/post/shiro-2/#cve-2016-6802" target="_blank">su18师傅</a></p>
<h3 data-content="1" id="c5b67180e7591c5635a627834b6a4a54">漏洞详解</h3>
<p>本漏洞类似 <code>CVE-2010-3863</code>，依旧是路径标准化导致的问题，不过之前是在 <code>RequestURI</code> 上，本漏洞是在 <code>ContextPath</code> 上。<br/>
之前提到，<code>Shiro</code> 调用 <code>WebUtils.getPathWithinApplication()</code> 方法获取请求路径。逻辑如下：</p>
<pre><code>public String getPathWithinApplication(HttpServletRequest request) {
    String contextPath = this.getContextPath(request);
    String requestUri = this.getRequestUri(request);
    String path = this.getRemainingPath(requestUri, contextPath, true);
    if (path != null) {
        return StringUtils.hasText(path) ? path : "/";
    } else {
        return requestUri;
    }
}</code></pre>
<p>其中调用 <code>getContextPath()</code> 方法，获取 <code>contextPath</code> ；调用 <code>getRequestUri()</code> 方法，获取 <code>uri</code> ；</p>
<p>在<code>getContextPath()</code> 方法调用 <code>decodeRequestString</code> 进行 <code>URLDecode</code>。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/6802_2.png"/><br/>
由于获取的 <code>ContextPath</code> 没有标准化处理，如果出现一些特殊字符使<code>ContextPath</code>与实际不符，都会导致在 <code>StringUtils.startsWithIgnoreCase()</code> 方法判断时失效，直接返回完整的<code>RequestURI</code>。</p>
<h4 data-content="1" id="cb40ab714ee074574151e28e8032436f">复现</h4>
<p>登录账户<code>lonestarr</code>，该账户对页面<code>remoting.jsp</code>没有访问权限，在跟路径前加任意路径，再加<code>../</code>即可实现绕过<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/6802_3.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/6802_4.png"/></p>
<h3 data-content="1" id="07c6d178e903272cae93312d55dcf8c2">漏洞修复</h3>
<p><code>Shiro</code> 在 <code>1.3.2</code> 版本的 <a href="https://github.com/apache/shiro/commit/b15ab927709ca18ea4a02538be01919a19ab65af" target="_blank">Commit</a> 中对此漏洞进行了修复。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/6802_5.png"/><br/>
通过代码可以看出，在 <code>WebUtils.getContextPath</code> 方法进行了更新，使用了修复 <code>CVE-2010-3863</code> 时更新的路径标准化方法 <code>normalize</code> 来处理 <code>ContextPath</code> 之后再返回。</p>
<h2 data-content="1" id="65c8dd5577eee8f93755ca460b6bf8ba">CVE-2019-12422</h2>
<h3 data-content="1" id="53561a35ffef92111443c95d4b678f59">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12422" target="_blank">CVE-2019-12422</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2019-42574" target="_blank">CNVD-2016-07814</a> /<a href="https://issues.apache.org/jira/browse/SHIRO-721" target="_blank">SHIRO-721</a><br/>
影响版本：<code>shiro &lt; 1.4.2</code><br/>
漏洞描述：<code>RememberMe</code>默认通过 <code>AES-128-CBC</code> 模式加密，易受<code>Padding Oracle Attack</code>攻击<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/a8018783373ff5e5210225069c9919e071597d5e" target="_blank">Commit</a><br/>
参考：<a href="https://blog.skullsecurity.org/2016/12" target="_blank">padding oracles</a> <a href="https://skysec.top/2017/12/13/padding-oracle%E5%92%8Ccbc%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/" target="_blank">Padding oracle attack</a> <a href="https://www.anquanke.com/post/id/203869" target="_blank">PaddingOracleAttack-Shiro-721代码分析</a></p>
<h3 data-content="1" id="5fcadf1be6f8576127698ff3e10d20b5">漏洞分析</h3>
<p>本次漏洞实际并不是针对 <code>shiro</code> 代码逻辑的漏洞，而是针对 <code>shiro</code> 使用的 <code>AES-128-CBC</code> 加密模式的攻击，首先了解一下这种加密方式。</p>
<h4 data-content="1" id="50a0533024ce0e7a8966488a0d0fde1d">AES-128-CBC</h4>
<p><code>AES-128-CBC</code> 模式就代表使用 <code>AES</code> 密钥长度为 <code>128 bit</code>，使用 <code>CBC</code> 分组算法的加密模式。</p>
<ul>
<li>
<code>AES</code>是对称、分组加密算法，分组长度固定为 <code>128bit</code>，密钥 <code>key</code> 的长度可以为 <code>128 bit</code>（<code>16</code>字节）、<code>192 bit</code>（<code>24</code>字节）、<code>256 bit</code>（<code>32</code>字节），如果数据块及密钥长度不足时，会补齐。</li>
<li>
<code>CBC</code>，全称 <code>Cipher Block Chaining</code> (密文分组链接模式)，简单来说，是一种使用前一个密文组与当前明文组 <code>XOR</code> 后再进行加密的模式。<code>CBC</code>主要是引入一个初始化向量<code>（Initialization Vector，IV）</code>来加强密文的随机性，保证相同明文通过相同的密钥加密的结果不一样。</li>
</ul>
<p><code>CBC</code> 模式下，存在以下填充方式，用于在分组数据不足时，在结尾进行填充，用于补齐：</p>
<ul>
<li>
<code>NoPadding</code>：不填充，明文长度必须是 <code>16 Bytes</code> 的倍数。</li>
<li>
<code>PKCS5Padding</code>：<code>PKCS7Padding</code>跟<code>PKCS5Padding</code>的区别就在于数据填充方式，<code>PKCS7Padding</code>是缺几个字节就补几个字节的<code>0</code>，而<code>PKCS5Padding</code>是缺几个字节就补充几个字节的几，比如缺<code>6</code>个字节，就补充<code>6</code>个字节的<code>6</code>，如果不缺字节，就需要再加一个字节块。</li>
<li>
<code>ISO10126Padding</code>：以随机字节填充 , 最后一个字节为填充字节的个数。</li>
</ul>
<p><code>Shiro</code> 中使用的是 <code>PKCS5Padding</code>，也就是说，可能出现的 <code>padding byte</code> 值只可能为：</p>
<pre><code>1 个字节的 padding 为 0x01
2 个字节的 padding 为 0x02,0x02
3 个字节的 padding 为 0x03,0x03,0x03
4 个字节的 padding 为 0x04,0x04,0x04,0x04
...</code></pre>
<p>当待加密的数据长度刚好满足分组长度的倍数时，仍然需要填充一个分组长度，也就是说，明文长度如果是 <code>16n</code>，加密后的数据长度为 <code>16(n+1)</code> 。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12422_3.png"/></p>
<p>加密过程：</p>
<ul>
<li>明文经过填充后，分为不同的组<code>block</code>，以组的方式对数据进行处理</li>
<li>初始化向量（<code>IV</code>）首先和第一组明文进行<code>XOR</code>（异或）操作，得到”中间值“</li>
<li>采用密钥对中间值进行块加密，删除第一组加密的密文 （加密过程涉及复杂的变换、移位等）</li>
<li>第一组加密的密文作为第二组的初始向量（<code>IV</code>），参与第二组明文的异或操作</li>
<li>依次执行块加密，最后将每一块的密文拼接成密文</li>
<li>
<code>IV</code>经常会被放在密文的前面，解密时先获取前面的<code>IV</code>，再对后面的密文进行解密</li>
</ul>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12422_1.png"/></p>
<p>解密过程</p>
<ul>
<li>会将密文进行分组（按照加密采用的分组大小），前面的第一组是初始化向量，从第二组开始才是真正的密文</li>
<li>使用加密密钥对密文的第一组进行解密，得到中间值</li>
<li>将中间值和初始化向量进行异或，得到该组的明文</li>
<li>前一块密文是后一块密文的<code>IV</code>，通过异或中间值，得到明文</li>
<li>块全部解密完成后，拼接得到明文，密码算法校验明文的格式（填充格式是否正确）</li>
<li>校验通过得到明文，校验失败得到密文</li>
</ul>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12422_2.png"/></p>
<h4 data-content="1" id="0b4c61865c9da57d2ff71fe08a4040c0">Padding Oracle Attack 原理</h4>
<p>这个攻击的根源是明文分组和填充，同时应用程序对于填充异常的响应可以作为反馈。首先明确以下两点</p>
<ol>
<li>解密之后的最后一个数据块，其结尾应该包含正确的填充序列。如果这点没有满足，那么加/解密程序就会抛出一个填充异常。<code>Padding Oracle Attack</code>的关键就是利用程序是否抛出异常来判断<code>padding</code>是否正确。</li>
<li>解密时将密文分组，第一组是初始化向量，后面才是真正的密文。密文传过去后先解密得到中间值，中间值与初始向量异或得到明文片段。</li>
</ol>
<p>比如我们的明文为<code>admin</code>，则需要被填充为 <code>admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b</code>，一共<code>11</code>个<code>\x0b</code><br/>
如果我们输入一个错误的<code>IV</code>，依旧是可以解密的，但是中间值<code>middle</code>和我们输入的<code>IV</code>经过异或后得到的填充值可能出现错误这样就出现验证错误的情况。<br/>
比如本来应该是<code>admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b</code><br/>
而我们错误的得到<code>admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x2b</code><br/>
这样解密程序往往会抛出异常(<code>Padding Error</code>)，应用在<code>web</code>里的时候，往往是<code>302</code>或是<code>500</code>报错，而正常解密的时候是<code>200</code><br/>
所以这时，我们可以根据服务器的反应来判断我们输入的<code>IV</code>是否正确</p>
<h5 data-content="1" id="684a364fd6e21fb20db31ce922b90aee">举例解释</h5>
<p>这里使用<a href="https://skysec.top/2017/12/13/padding-oracle%E5%92%8Ccbc%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/" target="_blank">参考链接</a>中的数据进行举例说明</p>
<p>我们假设正确的<code>IV</code>为</p>
<pre><code>0x6d 0x36 0x70 0x76 0x03 0x6e 0x22 0x39</code></pre>
<p><code>middle</code>中间值为(为了方便，这里按<code>8</code>位分组来阐述)</p>
<pre><code>0x39 0x73 0x23 0x22 0x07 0x6a 0x26 0x3d</code></pre>
<p>解密后正确的明文为：</p>
<pre><code>TEST0x040x040x040x04</code></pre>
<p>以攻击者的角度来看，我们可以知道<code>IV</code>的值和服务器的状态，不知道中间值和解密后明文的值，所以我们可以根据输入的<code>IV</code>值和服务器的状态去判断出解密后明文的值，这里的攻击即叫做<code>Padding Oracle Attack</code>攻击<br/>
首先输入<code>IV</code></p>
<pre><code>0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</code></pre>
<p>一起传到服务器后，服务器对<code>IV</code>后面的加密数据进行解密，得到中间值，然后<code>IV</code>与中间值进行异或，得到明文：</p>
<pre><code>0x39 0x73 0x23 0x22 0x07 0x6a 0x26 0x3d</code></pre>
<p>此时程序会校验最后一位<code>padding</code>字节是否正确。由于是按8位进行分组，所以正确的<code>padding</code>的值应该只有<code>0x01~0x08</code>，这里是<code>0x3d</code>，显然是错误的，所以程序会抛出<code>500</code><br/>
知道这一点后，我们可以通过遍历最后一位<code>IV</code>，从而使这个<code>IV</code>和<code>middle</code>值异或后的最后一位是我们需要<code>0x01</code>，这时候有<code>256</code>种可能。<br/>
这时问题来了，我们为什么要使最后一位是<code>0x01</code>呢？因为此时我们像知道<code>plain[8]</code>的值，只计算最后一位就可以了，只计算最后一位的话只有<code>0x01</code>时服务器才会通过验证，我们才能计算下面的公式。<br/>
此时<code>IV</code>的值为：</p>
<pre><code>0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x3c</code></pre>
<p><code>IV</code>和<code>Middle</code>异或后得到的是：</p>
<pre><code>0x39 0x73 0x23 0x22 0x07 0x6a 0x26 0x01</code></pre>
<p>这时候程序校验最后一位，发现是<code>0x01</code>，即可通过校验，服务器返回<code>200</code><br/>
然后我们有公式：</p>
<pre><code>Middle[8]^原IV[8] = plain[8]
Middle[8]^现IV[8] = 0x01</code></pre>
<p>所以，我们可以算出</p>
<pre><code>middle[8] = 0x01^现IV[8]</code></pre>
<p>然后可以计算得到：</p>
<pre><code>plain[8] = 0x01^现IV[8]^原IV[8] = 0x01^0x3c^0x39=0x04</code></pre>
<p>和我们之前解密成功的明文一致（最后4位为填充），下面我们需要获取<code>plain[7]</code>。<br/>
因为这次我们需要的明文是<code>2</code>个<code>0x02</code>，而非之前的一个<code>0x01</code>，所以需要将<code>IV</code>更新</p>
<pre><code>现IV[8] = middle[8]^0x02</code></pre>
<p>为什么是<code>现在的IV[8] = middle[8]^0x02</code>？<br/>
因为<code>现在的IV[8]^middle[8]=服务器校验的值</code>，而我们遍历倒数第二位，应该是<code>2</code>个<code>0x02</code>，所以服务器希望得到的是<code>0x02</code>，所以</p>
<pre><code>现IV[8]^middle[8]=0x02</code></pre>
<p>然后再继续遍历现在的<code>IV[7]</code><br/>
方法还是和上面一样，遍历后可以得到<br/>
<code>IV</code>:</p>
<pre><code>0x00 0x00 0x00 0x00 0x00 0x00 0x24 0x3f</code></pre>
<p><code>IV</code>和<code>middle</code>异或得到的是</p>
<pre><code>0x39 0x73 0x23 0x22 0x07 0x6a 0x02 0x02</code></pre>
<p>此时真正的明文值：</p>
<pre><code>plain[7]=现IV[7]^原IV[7]^0x02</code></pre>
<p>所以<code>plain[7] = 0x02^0x24^0x22=0x04</code><br/>
和我们之前解密成功的明文一致（最后4位为填充）<br/>
最后遍历循环，即可得到完整的<code>plain</code></p>
<h4 data-content="1" id="148f6674f216bcaded97d3e834667505">CBC翻转攻击过程</h4>
<p>这个实际上和<code>padding oracle</code>攻击差不多，还是关注这个解密过程。但这时，我们是已知明文，想利用<code>IV</code>去改变解密后的明文<br/>
比如我们知道明文解密后是<code>1dmin</code>，我们想构造一个<code>IV</code>，让他解密后变成<code>admin</code>。<br/>
还是原来的思路</p>
<pre><code>原IV[1]^middle[1]=plain[1]</code></pre>
<p>而此时，我们想要有如下等式</p>
<pre><code>构造的IV[1]^mddle[1]=’a’</code></pre>
<p>所以我们可以得到</p>
<pre><code>middle[1]=原IV[1]^plain[1]
构造的IV[1] = middle[1]^’a’

构造的IV[1]= 原IV[1]^plain[1]^’a’</code></pre>
<p>我们可以用这个式子，遍历明文，构造出<code>IV</code>，让程序解密出我们想要的明文</p>
<h4 data-content="1" id="6b39a595e2aefcf81a1d27d6bb86e45a">Shiro中的攻击</h4>
<p>在了解上面的基础知识后，就很好理解后面的攻击流程了，攻击者通过已知 <code>RememberMe</code> 密文使用 <code>Padding Oracle Attack</code> 爆破和篡改密文，构造可解密的恶意的反序列化数据，触发反序列化漏洞。<br/>
之前提到过 <code>Padding Oracle Attack</code> 是利用类似于盲注的思想来判断是否爆破成功的，在验证 <code>Padding</code> 失败时的返回信息应该不同，那我们看一下在<code>Shiro</code>中，验证<code>Padding</code>失败时的返回值？</p>
<p>关注点依旧从 <code>AbstractRememberMeManager#getRememberedPrincipals</code> 中开始</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">PrincipalCollection</span> <span class="nf">getRememberedPrincipals</span><span class="o">(</span><span class="n">SubjectContext</span> <span class="n">subjectContext</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">PrincipalCollection</span> <span class="n">principals</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">getRememberedSerializedIdentity</span><span class="o">(</span><span class="n">subjectContext</span><span class="o">);</span>
        <span class="c1">//SHIRO-138 - only call convertBytesToPrincipals if bytes exist:</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">principals</span> <span class="o">=</span> <span class="n">convertBytesToPrincipals</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="n">subjectContext</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="n">re</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">principals</span> <span class="o">=</span> <span class="n">onRememberedPrincipalFailure</span><span class="o">(</span><span class="n">re</span><span class="o">,</span> <span class="n">subjectContext</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">principals</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>负责解密的 <code>convertBytesToPrincipals</code> 方法会调用 <code>CipherService</code> 的 <code>decrypt</code> 方法，调用栈如下所示如下:</p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12422.png"/></p>
<p>其中 <code>PKCS5Padding#unpad</code> 方法对数据的填充格式进行判断，有问题会返回 <code>-1</code>；<br/>
当返回值小于<code>0</code>时，<code>CipherCore#doFinal</code> 方法会抛出 <code>BadPaddingException</code> 异常；<br/>
接着 <code>JcaCipherService#crypt</code> 方法、 <code>AbstractRememberMeManager#getRememberedPrincipals</code> 方法均返回异常，而且<code>AbstractRememberMeManager#getRememberedPrincipals</code>方法还好调用<code>onRememberedPrincipalFailure</code> 移除 <code>rememberMe cookie</code>并添加 <code>deleteMe</code>。</p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12422-1.png"/><br/>
由此可见，只要 <code>padding</code> 错误，服务端就会返回一个 <code>cookie: rememberMe=deleteMe;</code>，攻击者可以借由此特征进行 <code>Padding Oracle Attack</code>。</p>
<h3 data-content="1" id="aaf894672359001bfb1eb3d2a1e6d871">漏洞复现</h3>
<p>直接使用 <a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721" target="_blank">longofo 师傅的项目</a>。<br/>
首先获取一个有效的 <code>rememberMe</code> 值，其次生成一个反序列化利用的 <code>payload</code>，然后使用如下参数执行攻击。</p>
<pre><code>java -jar PaddingOracleAttack-1.0-SNAPSHOT.jar http://localhost:8080/samples_web_war/ "P5MwbBios...sdSdf" 16 cb.ser</code></pre>
<p>经过一段时间后，生成<code>payload</code>，替换<code>rememberMe</code>的值，发送到服务器<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12422_4.png"/></p>
<p>这个洞需要大量的请求，在实际中应该不太可能攻击成功。</p>
<p>问题：<br/>
由于系统初始化后，只要不重启服务器，密钥就固定了，那应该就可以攻击成功一次之后，后面继续攻击应该就不需要大量请求了，可以直接生成<code>payload</code>，但是目前不知道需要保存哪些值才能实现这种需求<br/>
不完全解答：<br/>
改了一下代码，目前只实现攻击一次后，<code>ser</code>不变的情况下，可以快速生成，但是<code>ser</code>改变，就需要重新生成。<br/>
原因在于原代码是基于<code>nextCipherTextBlock</code>也就是<code>nextBLock</code>计算的<code>tmpIV</code>，继而计算的<code>nextBLock</code>。所以无法通过保存<code>nextBLock</code>或<code>tmpIV</code>达到通用的目标。但我认为从攻击算法的角度来看，还是有办法实现的。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12422_7.png"/><br/>
也有师傅对利用代码进行分析后，实现了<code>payload</code>瘦身的<a href="https://www.cnblogs.com/wh4am1/p/12761959.html" target="_blank">功能</a></p>
<h3 data-content="1" id="335c5721022816facdf33ead1e465302">漏洞修复</h3>
<p>在 <code>1.4.2</code> 版本的更新 <a href="https://github.com/apache/shiro/commit/a8018783373ff5e5210225069c9919e071597d5e" target="_blank">Commit</a> 中对此漏洞进行了修复 ，在父类 <code>JcaCipherService</code> 中写了一个抽象方法 <code>createParameterSpec()</code> ，该方法返回加密算法对应的类，并在 <code>AesCipherService</code> 中重写了这个方法，默认使用 <code>GCM</code> 加密模式，避免此类攻击。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/12422_6.png"/></p>
<h2 data-content="1" id="4e67e87364954a5f54c4399a19395b73">CVE-2020-1957</h2>
<h3 data-content="1" id="b9469ed76b0a62325c28af97540228c1">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-1957" target="_blank">CVE-2020-1957</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-20984" target="_blank">CNVD-2020-20984</a> /<a href="https://issues.apache.org/jira/browse/SHIRO-682" target="_blank">SHIRO-682</a><br/>
影响版本：<code>shiro &lt; 1.5.2</code><br/>
漏洞描述：利用 <code>Shiro</code> 和 <code>Spring</code> 对 <code>URL</code> 的处理的差异化，越权并成功访问。<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/589f10d40414a815dbcaf1f1500a51f41258ef70" target="_blank">Commit</a> <a href="https://github.com/apache/shiro/commit/9762f97926ba99ac0d958e088cae3be8b657948d" target="_blank">Commit</a> <a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce" target="_blank">Commit</a><br/>
参考：<a href="https://www.anquanke.com/post/id/226899" target="_blank">Shiro权限绕过漏洞详细分析</a> <a href="http://rui0.cn/archives/1643" target="_blank">Ruil1n 师傅</a></p>
<h3 data-content="1" id="ad1f2c88aa111beefaebf1f289aaee1e">漏洞分析</h3>
<h3 data-content="1" id="772da5754a707e7ce61fd85c66afa36e">SHIRO-682</h3>
<p>本漏洞起源于 <a href="https://issues.apache.org/jira/browse/SHIRO-682" target="_blank">SHIRO-682</a>。在 <code>Spring</code> 中，<code>/resource/xx</code> 与 <code>/resource/xx/</code> 都会被截成<code>/resource/xx</code>以访问相应资源；在 <code>shiro</code> 中，<code>/resource/xx</code> 与 <code>/resource/xx/</code>被视为两个不同路径。所以在 <code>Spring</code> 集成 <code>shiro</code> 时，只需要在访问路径后添加 <code>/</code> 就存在绕过权限校验的可能。<br/>
下面通过复现进行分析(分析、测试版本<code>1.4.2</code>)：<br/>
首先<code>shiro.ini</code>中[urls]配置如下:</p>
<pre><code>[urls]
# anon：匿名拦截器，不需登录就能访问，一般用于静态资源，或者移动端接口。
# authc：登录拦截器，需要登录认证才能访问的资源。
/login.jsp = authc
/logout = logout
/toJsonPOJO = authc, perms["audit:list"]
/** = anon</code></pre>
<p>输入<code>/toJsonPOJO</code>时，<code>shiro</code>对其进行判断，从<code>shior.ini</code>或其他配置中进行匹配。当匹配到<code>/toJsonPOJO</code>时，匹配成功，跳出循环。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_1.png"/><br/>
此时，跳转至登陆界面。<br/>
输入<code>/toJsonPOJO/</code>时，<code>shiro</code>对其进行判断，当匹配到<code>/toJsonPOJO</code>时，匹配失败，继续匹配；当匹配到<code>/**</code>时，匹配成功，跳出循环。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_2.png"/><br/>
接着到了<code>springframework</code>中的判断，这里<code>/toJsonPOJO/</code>和<code>/toJsonPOJO</code>是可以匹配成功的<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_3.png"/><br/>
此时，成功绕过<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_4.png"/></p>
<h3 data-content="1" id="6d569f152d0db9d8df1564622fdf60d7">其他绕过方式</h3>
<p>除了上面的绕过方式，本 <code>CVE</code> 还存在另一个绕过。利用的是 <code>shiro</code> 和 <code>spring</code> 对 <code>url</code> 中的 <code>;</code> 处理的差异进行绕过并成功访问。<br/>
分析、测试版本<code>1.4.2</code></p>
<h4 data-content="1" id="3a1c393cc478532ae6392fcde0e7b977">绕过分析</h4>
<p>首先进入<code>Shiro</code>中<br/>
首先在<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver.class#getChain</code>处下断点，进行调试，访问<code>http://localhost:8080/xx/..;/toJsonPOJO</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_6.png"/></p>
<p>单步调试进入<code>this.getPathWithinApplication(request)</code>，在<code>WebUtils#getPathWithinApplication()</code>中，通过<code>getContextPath(request)</code>，获取到上下文信息后，再用<code>getRequestUri(request)</code>获取具体的<code>uri</code>。进入<code>getRequestUri()</code>方法，在<code>return</code>前，获取到的<code>uri</code>为<code>/xx/..;/toJsonPOJO</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_5.png"/><br/>
接下来分析一下<code>return normalize(decodeAndCleanUriString(request, uri));</code><br/>
首先进入<code>decodeAndCleanUriString</code><br/>
传入的参数<code>uri</code>是<code>/xx/..;/toJsonPOJO</code>,然后通过语句<code>int semicolonIndex = uri.indexOf(59);</code>找出<code>uri</code>中分号的位置，<code>59</code>也就是<code>;</code>的<code>ASCII码</code><br/>
如果<code>uri</code>中有分号，就返回分号前的字段，否则返回整个<code>uri</code>。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_7.png"/><br/>
接着进入<code>normalize</code>，参数<code>uri</code>已经变成<code>/xx/..</code>，<code>normalize</code>内部对传入的路径进行标准化规范处理，相关操作包括替换反斜线、替换<code>//</code>为<code>/</code>等，最后得到返回的<code>uri</code><br/>
此时<code>return normalize(decodeAndCleanUriString(request, uri));</code>结果为<code>/xx/..</code>，也就是说<code>getRequestUri(request)</code>获取的<code>uri</code>为<code>/xx/..</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_8.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_9.png"/></p>
<p>一路回到<code>getChain</code>，经过上面的步骤，得到<code>requestURI</code>值为<code>/xx/..</code>，接下来在<code>while</code>循环里使用<code>pathMatches(pathPattern, requestURI)</code>进行权限校验，此时只有<code>/**</code>能够与<code>/xx/..</code>匹配成功，<code>/**</code>是<code>anon</code>权限，不需要登陆就能访问，绕过了<code>/toJsonPOJO</code>的<code>authc</code>权限<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_10.png"/></p>
<p>此时<code>Shiro</code>部分的权限绕过了，那么<code>Spring</code>部分的路径是怎么匹配的呢？<br/>
<code>url</code>经过<code>shiro</code>的处理认证通过后，就会进入<code>spring</code>中进行解析，我们在<code>UrlPathHelper#getLookupPathForRequest</code>下断点<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_11.png"/><br/>
先进入<code>getPathWithinApplication()</code>，通过<code>this.getRequestUri(request)</code>获取<code>uri</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_12.png"/><br/>
获取到的<code>uri</code>值为<code>/xx/..;/toJsonPOJO</code>，在<code>return</code>之前进入<code>decodeAndCleanUriString(request, uri)</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_14.png"/><br/>
传进来的参数<code>uri</code>为<code>/xx/..;/toJsonPOJO</code>，经过<code>removeSemicolonContent(uri)</code>后移除<code>uri</code>中<code>/</code>与<code>/</code>之间的的分号以及分号后面的内容；经过<code>decodeRequestString(request, uri)</code>后对<code>uri</code>进行解码；经过<code>getSanitizedPath(uri)</code>后将路径中<code>//</code>替换为<code>/</code>。此时返回的<code>uri</code>值为<code>/xx/../toJsonPOJO</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_15.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_16.png"/><br/>
步入<code>getPathWithinServletMapping()</code>后，传入的参数<code>pathWithinApp</code>值为<code>/xx/../toJsonPOJO</code>。依次通过<code>UrlPathHelper#getServletPath</code>、<code>HttpServletRequestWrapper#getServletPath</code>、<code>Request#getServletPath</code>获取到我们实际访问的<code>url：http://localhost:8080/toJsonPOJO</code>后返回，最终实现绕过权限访问<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_13.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_17.png"/></p>
<p>经过测试当<code>uri</code>为<code>123;/..;345/;../.;/alter/..;/;/;///////;/;/;awdwadwa/toJsonPOJO</code>时，<code>Shiro</code>对<code>/123</code>进行权限验证;<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_18.png"/><br/>
<code>Spring</code>的<code>org.springframework.web.util.UrlPathHelper</code>中，<code>getPathWithinApplication(request)</code>值为<code>/123/.././alter/../toJsonPOJO</code>;<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_19.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_20.png"/><br/>
<code>this.getPathWithinServletMapping(request, pathWithinApp)</code>值为<code>/toJsonPOJO</code>，可以进行绕过<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_21.png"/></p>
<p>上面这个 <code>payload</code> 只能在较低版本的 <code>Spring Boot</code> 上使用。<br/>
根据<a href="http://rui0.cn/archives/1643" target="_blank">Ruil1n 师傅</a>介绍:<br/>
当 <code>Spring Boot</code> 版本在小于等于 <code>2.3.0.RELEASE</code> 的情况下，<code>alwaysUseFullPath</code> 为默认值 <code>false</code>，这会使得其获取 <code>ServletPath</code> ，所以在路由匹配时相当于会进行路径标准化包括对 <code>%2e</code> 解码以及处理跨目录，这可能导致身份验证绕过。而反过来由于高版本将 <code>alwaysUseFullPath</code> 自动配置成了 <code>true</code> 从而开启全路径，又可能导致一些安全问题。<br/>
所以在高版本上只能试着寻找逻辑上有没有漏洞，然后进行绕过。比如程序配置了访问路径 <code>/alter/**</code> 为 <code>anon</code>，但是指定了其中的一个 <code>/alter/page</code>为 <code>authc</code>。这时在不跳目录的情况下，可以使用如下请求绕过：<br/>
<code>http://127.0.0.1:8080/alter//;aaaa/;...///////;/;/;awdwadwa/page</code></p>
<h3 data-content="1" id="7a06930bdc2f562dde8f829d8848080f">漏洞修复</h3>
<p>先是在 <a href="https://github.com/apache/shiro/commit/589f10d40414a815dbcaf1f1500a51f41258ef70" target="_blank">Commit</a> 的<code>PathMatchingFilter#pathsMatch</code> 和<code>PathMatchingFilterChainResolver#getChain</code>方法中添加了对访问路径后缀为 <code>/</code> 的支持<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_22.png"/></p>
<p>然后在 <a href="https://github.com/apache/shiro/commit/9762f97926ba99ac0d958e088cae3be8b657948d" target="_blank">Commit</a>，除了 <code>endsWith</code> 还添加了 <code>equals</code> 的判断。是修复由于上一次提交，导致访问路径为 <code>/</code> 时抛出的异常。</p>
<p>在 <a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce" target="_blank">Commit</a>中， <code>shiro</code> 使用 <code>request.getContextPath()</code>、<code>request.getServletPath()</code>、<code>request.getPathInfo()</code> 拼接构造<code>uri</code>替代<code>request.getRequestURI()</code>  来修复<code>;</code> 绕过<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1957_26.png"/></p>
<h2 data-content="1" id="334afb7c051794aafe1d719e65fd041b">CVE-2020-11989</h2>
<h3 data-content="1" id="b54bb00b29c574d295994e727f87e767">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-1957" target="_blank">CVE-2020-11989</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-20984" target="_blank">SHIRO-782</a><br/>
影响版本：<code>shiro &lt; 1.5.3</code><br/>
漏洞描述：在<code>Shiro &lt; 1.5.3</code>的情况下，将<code>Shiro</code>与<code>Spring Controller</code>一起使用时，相应请求可能会导致身份验证绕过。<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/589f10d40414a815dbcaf1f1500a51f41258ef70" target="_blank">Commit</a><br/>
参考： <a href="https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/" target="_blank">腾讯安全玄武实验室 Ruilin师傅</a> <a href="https://mp.weixin.qq.com/s/yb6Tb7zSTKKmBlcNVz0MBA" target="_blank">边界无限 淚笑师傅</a></p>
<p>这个漏洞有两种绕过方式，分别由腾讯安全玄武实验室的<code>Ruilin</code>师傅和来自边界无限的淚笑师傅报告</p>
<h3 data-content="1" id="f73786a5642f3d7e2dd2c98d6fa53607">漏洞分析 —— 两次解码绕过</h3>
<h4 data-content="1" id="e7aed090c07b37ffeb5db2c9d889f421">限制</h4>
<p>这个场景下需要一些限制条件，首先配置文件的<code>ant</code>风格需要是<code>*</code>而不是<code>**</code>，测试发现，<code>?</code>也可以<br/>
另外<code>controller</code>需要接收的<code>request</code>参数(<code>@PathVariable</code>)的类型需要是<code>String</code>，否则将会出错。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_3.png"/></p>
<h4 data-content="1" id="eb91976910067d495191e8fdcc966297">复现</h4>
<p>首先复现一下，测试版本 <code>1.5.2</code>。<br/>
编写<code>Controller</code></p>
<div class="highlight"><pre><span></span><span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/toJsonList/{name}"</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="nf">toJsonList</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"返回json集合数据"</span><span class="o">);</span>
        <span class="n">User</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="o">();</span>
        <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"alter1"</span><span class="o">);</span>
        <span class="n">user1</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">15</span><span class="o">);</span>

        <span class="n">User</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="o">();</span>
        <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"alter2"</span><span class="o">);</span>
        <span class="n">user2</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">12</span><span class="o">);</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;();</span>
        <span class="n">userList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>
        <span class="n">userList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">userList</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
<p>配置对应的<code>shiro.ini</code></p>
<pre><code>[urls]
/toJsonList/* = authc</code></pre>
<p>此时请求<code>/toJsonList/aaa</code>那么将会被禁止。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_1.png"/><br/>
但是这里我们可以通过url双编码的方式来绕过。</p>
<pre><code>/ -&gt; %2f -&gt;%25%32%66</code></pre>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_2.png"/><br/>
测试发现下面四种组合只有前两组可以绕过</p>
<pre><code>yes
/toJsonList/a%25%32%66a
/toJsonList/%25%32%66

no
/toJsonList/%25%32%66a
/toJsonList/a%25%32%66</code></pre>
<h4 data-content="1" id="7a4099396927ba6fdbda012e9861da6d">分析</h4>
<p>首先要清楚<code>Shiro</code>支持 <code>Ant</code> 风格的路径表达式配置。<code>ANT</code> 通配符有 <code>3</code> 种，如下所示：<br/>
|  通配符   | 说明  |<br/>
|  ----  | ----  |<br/>
| ?  | 匹配任何单字符 |<br/>
| *  | 匹配0或者任意数量的字符 |<br/>
| **  | 匹配0或者更多的目录 |</p>
<p>解释一下就是<code>/**</code> 之类的配置，匹配路径下的全部访问请求，包括子目录及后面的请求，如：<code>/admin/**</code> 可以匹配 <code>/admin/a</code> 或者 <code>/admin/b/c/d</code> 等请求。<br/>
对于<code>/*</code>的话 ，单个 <code>*</code> 不能跨目录，只能在两个 <code>/</code> 之间匹配任意数量的字符，如 <code>/admin/*</code> 可以匹配 <code>/admin/a</code> 但是不能匹配 <code>/admin/b/c/d</code>。<br/>
那么问题来了，如果我们将其配置为<code>/toJsonList/*</code>，但是我们访问形如<code>/toJsonList/a/b</code>这种路径，此时就会绕过访问权限。</p>
<p>我们还记得为了修复<code>CVE-2020-1957</code>,shiro在<code>1.5.2</code>版本进行了更新，将<code>request.getRequestURI()</code> 修改为 <code>request.getContextPath()</code>、<code>request.getServletPath()</code>、<code>request.getPathInfo()</code> 拼接构造<code>uri</code>。根据网上师傅们的总结，这几个方法的差异性如下：</p>
<ul>
<li>
<code>request.getRequestURL()</code>：返回全路径；</li>
<li>
<code>request.getRequestURI()</code>：返回除去<code>Host</code>部分的路径；</li>
<li>
<code>request.getContextPath()</code>：返回工程名部分，如果工程映射为<code>/</code>，则返回为空；</li>
<li>
<code>request.getServletPath()</code>：返回除去<code>Host</code>和工程名部分的路径；</li>
<li>
<code>request.getPathInfo()</code>：仅返回传递到<code>Servlet</code>的路径，如果没有传递额外的路径信息，则此返回<code>Null</code>；</li>
</ul>
<p>第一次解码发生在<code>request.getServletPath()</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_4.png"/><br/>
第二次解码发生在<code>decodeAndCleanUriString()</code> -&gt; <code>decodeAndCleanUriString()</code> -&gt; <code>decodeRequestString()</code> -&gt; <code>URLDecoder.decode()</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_5.png"/><br/>
因此<code>org.apache.shiro.web.util.WebUtils#getRequestUri</code>进行了两次解码，将<code>/toJsonList/a%25%32%66a</code>解码成<code>/toJsonList/a/a</code><br/>
接着就走到<code>org.apache.shiro.util.AntPathMatcher#doMatch</code>进行权限验证，<code>/toJsonList/a/a</code>不满足配置中的<code>toJsonList/*</code>，因此成功绕过。</p>
<p>但还要看<code>Spring</code>是怎么对其进行解析的<br/>
在<code>org.springframework.web.uti.UrlPathHelper#getPathWithinApplication</code>中，将<code>url</code>解析为<code>/toJsonList/a%2fa</code>，这样其实就表示<code>/toJsonList/{name}</code>中的<code>name</code>值为<code>a%2fa</code>。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_6.png"/></p>
<p>分析完之后， 也就解释了为什么下面四种组合只有前两组可以绕过<br/>
（这种二次解码的方式我测试只适用于<code>1.5.2</code>的版本，之前的版本使用<code>a%25%32%66a</code>测试，因为只有一次解码，会跳转至登陆界面；<code>a%2fa</code>测试直接返回<code>400 Bad Request</code>,应该是请求的问题，希望能有师傅帮忙解答一下）</p>
<h3 data-content="1" id="e7e34d730d42cae2790a87525b082a51">漏洞分析 —— 根路径差异化解析绕过</h3>
<h4 data-content="1" id="d959b51f32df79061c415a0dd5d61e30">限制</h4>
<ol>
<li>若 <code>Shiro &gt;= 1.5.2</code> 的话，应用不能部署在根目录，如果为根目录则 <code>context-path</code> 为空， <code>CVE-2020-1957</code> 更新补丁将 <code>URL</code> 格式化。</li>
<li>
<code>Spring</code> 控制器中没有另外的权限校验代码<br/>
#### 复现<br/>
本次复现使用的是<code>1.4.2</code>版本的<code>shiro</code>所以应用根目录是什么都没有关系<br/>
配置为
<pre><code>/alter/* = authc
/** = anon</code></pre>
新增一个<code>controller</code>
<pre><code>@RequestMapping("/alter/test")
@ResponseBody
public List&lt;User&gt; test(){
 User user1 = new User();
 user1.setName("alter");
 user1.setAge(15);
 List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
 userList.add(user1);
 return userList;
}</code></pre>
输入地址<code>http://localhost:8080/;/shirodemo/alter/test</code>，<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>会进行如下操作获取<code>uri</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_7.png"/><br/>
此时<code>uri</code>结果为<code>/</code>，绕过配置<code>/alter/* = authc</code>，符合配置<code>/** = anon</code>，达到绕过目的。<br/>
<code>Spring</code>在处理<code>uri</code>时直接进行路径标准化，去掉了分号</li>
</ol>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_13.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_8.png"/><br/>
<code>Shiro &lt; 1.5.2</code>版本的话，根路径是什么没有关系<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_9.png"/></p>
<h3 data-content="1" id="d54bb02977b3fbc8be4b555db9bcdc07">漏洞修复</h3>
<p><code>Shiro</code> 在 <a href="https://github.com/apache/shiro/commit/01887f645f92d276bbaf7dc644ad28ed4e82ef02" target="_blank">Commit</a> 中修改了 <code>URL</code> 获取的逻辑，不单独处理 <code>context-path</code>，这样不会导致绕过，同时也避免了二次 URL 解码的问题。<br/>
回退了 <code>WebUtils#getRequestUri</code> 的代码，并将其标记为 <code>@Deprecated</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_10.png"/><br/>
可以看到，<code>shiro</code>建议使用 <code>getPathWithinApplication()</code> 方法获取路径减去上下文路径，或直接调用 <code>HttpServletRequest.getRequestURI()</code> 方法获取。</p>
<p>在 <code>WebUtils#getPathWithinApplication</code> 方法，修改了使用 <code>RequestUri</code> 去除 <code>ContextPath</code> 的方式，改为使用 <code>getServletPath(request) + getPathInfo(request))</code>。然后使用 <code>removeSemicolon</code> 方法处理分号问题，<code>normalize</code> 方法进行路径标准化。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_11.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/11989_12.png"/></p>
<h2 data-content="1" id="51242397668adb97fd71f903a1a8518d">CVE-2020-13933</h2>
<h3 data-content="1" id="1f936915e0867e5da16cb68ce7b281d6">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-13933" target="_blank">CVE-2020-13933</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-46579" target="_blank">CNVD-2020-46579</a><br/>
影响版本：<code>shiro &lt; 1.6.0</code><br/>
漏洞描述：<code>Shiro</code> 由于处理身份验证请求时存在权限绕过漏洞，特制的<code>HTTP</code>请求可以绕过身份验证过程并获得对应用程序的未授权访问。<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/dc194fc977ab6cfbf3c1ecb085e2bac5db14af6d" target="_blank">Commit</a></p>
<h3 data-content="1" id="4433f46ea9df382e10fc257c68d3b318">漏洞分析</h3>
<p>这个CVE其实就是对<code>CVE-2020-11989 patch</code>的绕过。上一个CVE使用 <code>getServletPath(request) + getPathInfo(request))</code> 获取<code>uri</code>，回顾一下：</p>
<ul>
<li>
<code>request.getServletPath()</code>：返回除去<code>Host</code>和工程名部分的路径；</li>
<li>
<code>request.getPathInfo()</code>：仅返回传递到<code>Servlet</code>的路径，如果没有传递额外的路径信息，则此返回<code>Null</code>；</li>
</ul>
<p><code>Shiro</code>在<code>getChain</code>内进行权限验证，首先通过<code>getPathWithinApplication(request)</code>获得<code>uri</code>。从下图可以看到，更新后使用<code>HttpServletRequest.getRequestURI()</code> 方法获取<code>uri</code>；然后使用<code>removeSemicolon</code>去除<code>uri</code>中的分号，这里去除的是分号及分号后面的内容；然后使用<code>normalize</code>进行路径标准化。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/13933_1.png"/><br/>
此时得到的路径为<code>/hello</code>，绕过了配置中的权限。<br/>
接着看<code>Spring</code>是怎么处理路径的：<br/>
在<code>org.springframework.web.util#UrlPathHelper</code>中的<code>getPathWithinApplication</code>方法内，使用<code>getRequestUri(request)</code>方法获取<code>uri</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/13933_2.png"/><br/>
与<code>Shiro</code>处理的差异达到既绕过<code>Shiro</code>权限验证又成功访问的目的。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/13933_3.png"/></p>
<h3 data-content="1" id="fbcea30abcad07dc1b0bebfde7a8ed31">漏洞修复</h3>
<p><code>shiro</code>在<code>1.6.0</code>版本中，<code>org.apache.shiro.spring.web#ShiroFilterFactoryBean</code>中增加了<code>/**</code>的默认路径配置，使其可以全局匹配进行过滤校验<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/13933_4.png"/><br/>
默认的<code>/**</code>配置对应一个全局的 <code>filter</code>：<code>InvalidRequestFilter</code>，这个类继承了 <code>AccessControlFilter</code>。用来过滤特殊字符（分号、反斜线、非ASCII码字符)，并返回 <code>400</code> 状态码。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/13933_5.png"/></p>
<h2 data-content="1" id="f0ae8c3a0c9be788f04783494e46cb61">CVE-2020-17510</h2>
<h3 data-content="1" id="822567eff80a1419c3196f3e423ad518">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-17510" target="_blank">CVE-2020-17510</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-60318" target="_blank">CNVD-2020-60318</a><br/>
影响版本：<code>shiro &lt; 1.7.0</code><br/>
漏洞描述：第三种<code>AntPathMatcher</code>的绕过方式<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/6acaaee9bb3a27927b599c37fabaeb7dd6109403" target="_blank">Commit</a></p>
<h3 data-content="1" id="d8434b7ee20f0b37038e87863c3f0f2e">漏洞分析</h3>
<p>这个漏洞还是对 <code>AntPathMatcher</code> 的继续绕过,在<code>CVE-2020-11989</code>和<code>CVE-2020-13933</code>分别尝试了 <code>/</code> 的双重 <code>URL</code> 编码和 <code>;</code> 的 <code>URL</code> 编码绕过，归根到底这种方式还是因为<code>Shiro</code>与<code>Spring</code>对<code>URI</code>处理的差异化导致的。那么字符 <code>.</code> 是不是也可以进行绕过呢？其实是可以的（测试环境<code>Shiro 1.6.0</code>，<code>SpringBoot 2.5.3</code>）<br/>
还是添加如下配置和<code>Controller</code></p>
<pre><code>map.put("/hello/*", "authc");</code></pre>
<div class="highlight"><pre><span></span><span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/hello/{name}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">hello</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>当<code>Shiro</code>获得的<code>uri</code>为<code>/hello</code>时，是无法和<code>/hello/*</code>匹配的，所以就在<code>/hello</code>后面加上<code>%2e</code>，这样<code>Shiro</code>解码之后变成<code>/hello/.</code>，然后路径标准化成为<code>/hello</code>，绕过身份验证<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17510_1.png"/><br/>
对于<code>Spring</code>来说，正如之前讲的，<code>Spring Boot</code> 版本在小于等于 <code>2.3.0.RELEASE</code>时，会对<code>uri</code>进行解码然后路径标准化，这样得到的路径为<code>/hello</code>，没有页面与之匹配。所以只有当 <code>Spring Boot</code> 版本在大于 <code>2.3.0.RELEASE</code>时标准化路径后<code>/hello/%2e</code>，然后解码<code>/hello/.</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17510_2.png"/><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17510_3.png"/><br/>
下面的<code>payload</code>都可以使用：</p>
<pre><code>/%2e
/%2e/
/%2e%2e
/%2e%2e/</code></pre>
<h3 data-content="1" id="416c17f3fbbe686b802ff1936b8fe646">漏洞修复</h3>
<p>在<a href="https://github.com/apache/shiro/commit/6acaaee9bb3a27927b599c37fabaeb7dd6109403" target="_blank">Commit</a>中发现<code>org.apache.shiro.spring.web</code>下新增了<code>ShiroUrlPathHelper</code>类，属于<code>UrlPathHelper</code>的子类，重写了<code>getPathWithinApplication</code>和<code>getPathWithinServletMapping</code>两个方法<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17510_4.png"/><br/>
通过相关配置后，<code>Spring</code>就会使用<code>Shiro的UrlPathHelper</code>，这样两者判断逻辑一致，就不存在因差异性问题而导致的绕过了。</p>
<p>其实我认为<code>1.7.1</code>才算真正的更新，因为它是依次对原<code>uri</code>和去除<code>uri</code>尾部斜线的<code>uri</code>进行验证，这样就可以避免因直接去除尾部<code>uri</code>导致<code>/hello</code>和<code>/hello/*</code>不匹配而导致的绕过问题。</p>
<h3 data-content="1" id="4bf54bd2dd80807d562c12a20af5418e">补丁问题</h3>
<h4 data-content="1" id="27d3a3a58de4a51a2646f2a500094c2d">问题一</h4>
<p>根据官方发布的公告，发现其实需要配置<code>shiro-spring-boot-web-starter</code>才有效</p>
<pre><code>if you are NOT using Shiro’s Spring Boot Starter
(`shiro-spring-boot-web-starter`), you must configure add the
ShiroRequestMappingConfig auto configuration[1] to your application or
configure the equivalent manually[2].
[1] https://shiro.apache.org/spring-framework.html#SpringFramework-WebConfig
[2]https://github.com/apache/shiro/blob/shiro-root-1.7.0/support/spring/src/main/java/org/apache/shiro/spring/web/config/ShiroRequestMappingConfig.java#L28-L30</code></pre>
<p>由于我导入的<code>dependency</code>如下</p>
<div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">shiro</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">shiro</span><span class="o">-</span><span class="n">web</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="mf">1.6.0</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">shiro</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">shiro</span><span class="o">-</span><span class="n">spring</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="mf">1.6.0</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
</pre></div>
<p>如果直接将版本升为<code>1.7.0</code>的话，其实并没有触发更新，原<code>payload</code>还是可以绕过。<br/>
只有按照上面官网所述的两种配置方式修改后，才能防御成功</p>
<h4 data-content="1" id="b8ed3cce875d34517fdae1f38f7e8388">问题二</h4>
<p>在旧版的SpringBoot 中，当我们需要获取当前请求地址的时候，直接通过如下方式获取：</p>
<div class="highlight"><pre><span></span><span class="c1">//org.springframework.web.servlet.handler#getHandlerInternal</span>
<span class="n">String</span> <span class="n">lookupPath</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getUrlPathHelper</span><span class="o">().</span><span class="na">getLookupPathForRequest</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</pre></div>
<p>但是在新版Spring里边，通过如下方式获取</p>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">lookupPath</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">initLookupPath</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</pre></div>
<p>initLookupPath()代码如下：</p>
<div class="highlight"><pre><span></span><span class="kd">protected</span> <span class="n">String</span> <span class="nf">initLookupPath</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">usesPathPatterns</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">request</span><span class="o">.</span><span class="na">removeAttribute</span><span class="o">(</span><span class="n">UrlPathHelper</span><span class="o">.</span><span class="na">PATH_ATTRIBUTE</span><span class="o">);</span>
        <span class="n">RequestPath</span> <span class="n">requestPath</span> <span class="o">=</span> <span class="n">ServletRequestPathUtils</span><span class="o">.</span><span class="na">getParsedRequestPath</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">lookupPath</span> <span class="o">=</span> <span class="n">requestPath</span><span class="o">.</span><span class="na">pathWithinApplication</span><span class="o">().</span><span class="na">value</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">UrlPathHelper</span><span class="o">.</span><span class="na">defaultInstance</span><span class="o">.</span><span class="na">removeSemicolonContent</span><span class="o">(</span><span class="n">lookupPath</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">getUrlPathHelper</span><span class="o">().</span><span class="na">resolveAndCacheLookupPath</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>如果<code>this.usesPathPatterns() == true</code>的话，就可以绕开问题一中我们配置的<code>ShiroUrlPathHelper</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17510_5.png"/><br/>
此时也成功绕过。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17510_6.png"/></p>
<p>所以这就存在一个矛盾：只有<code>Spring Boot</code> 版本在大于 <code>2.3.0.RELEASE</code>才能触发这个漏洞，修复之后由于版本问题，<code>SpringBoot</code>又不走那条语句。<br/>
另外在配置的时候，当<code>Spring Boot</code> 版本在小于等于 <code>2.3.0.RELEASE</code>，如<code>2.1.5.RELEASE</code>，时，<code>this.getUrlPathHelper()</code>并不是<code>ShiroUrlPathHelper</code>，不清楚是不是配置问题还是版本兼容问题。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17510_7.png"/></p>
<h2 data-content="1" id="d60b3cbfb72c954fd4f3c096f9bdca3a">CVE-2020-17523</h2>
<h3 data-content="1" id="3daa34dc7341d56127a65bfdb5ee3ad2">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-17523" target="_blank">CVE-2020-17523</a> / <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2021-09492" target="_blank">CNVD-2021-09492</a><br/>
影响版本：<code>shiro &lt; 1.7.1</code><br/>
漏洞描述：<code>Shiro 1.7.1</code> 之前的版本，在将 <code>Shiro</code> 与 <code>Spring</code> 结合使用时，特制的 <code>HTTP</code> 请求可能会导致身份验证绕过。<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/ab1ea4a2006f6bd6a2b5f72740b7135662f8f160#diff-ce9ba3462f7d76e68c79bec5b9a3aea9bbd0d22ffb5e738f1b621cae49037b92" target="_blank">Commit</a></p>
<h3 data-content="1" id="e45e38bf4991c8c5e692d1cadfbacaa0">漏洞分析</h3>
<p>如<code>CVE-2020-17510</code>那样，这个漏洞可以使用空格<code>%20</code>进行绕过。<br/>
我们输入路径为<code>http://localhost:8080/hello/%20</code>，进入<code>getChain</code>，经过路径获取后要进行权限的匹配与验证<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17523_1.png"/><br/>
注意，获取的路径后面有空格<br/>
这里主要看一下<code>/hello/</code>和<code>/hello/*</code>比较时发生了什么<br/>
经过<code>pathMatches(pathPattern, requestURI)</code> -&gt; <code>pathMatcher.matches(pattern, path)</code> -&gt; <code>match(pattern, source)</code> -&gt; <code>doMatch(pattern, path, true)</code> 来到了主要的判断方法<code>doMatch()</code>。<br/>
其中<code>StringUtils.tokenizeToStringArray()</code>方法是将它的参数，也就是传进来的两个路径拆解成字符串数组，然后进行比较。<br/>
进入方法，可以看到当对空格进行转换时，直接<code>trim</code>为空<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17523_2.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17523_3.png"/><br/>
这样就导致与<code>shiro</code>中的配置本意想违背，导致绕过。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17523_4.png"/><br/>
然后在<code>Spring</code>中的处理时，<code>uri</code>又包含空格，这样就能访问到<code>/hello/%20</code>页面<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17523_5.png"/></p>
<h3 data-content="1" id="d26911c6b7f435aa5ddb62bcd3c4ffb4">漏洞修复</h3>
<p>在<a href="https://github.com/apache/shiro/commit/ab1ea4a2006f6bd6a2b5f72740b7135662f8f160#diff-ce9ba3462f7d76e68c79bec5b9a3aea9bbd0d22ffb5e738f1b621cae49037b92" target="_blank">Commit</a>中，主要修复点<code>AntPathMatcher.java</code>，在<code>tokenizeToStringArray</code>方法中加了<code>false</code>和<code>true</code>两个参数<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17523_6.png"/><br/>
可以看到，当第三个参数为<code>false</code>时，即<code>trimTokens</code>为<code>false</code>，此时就不会对<code>token</code>进行<code>trim</code>。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/17523_7.png"/></p>
<h2 data-content="1" id="3f192ec2ce169579e0ecd8fd3def5f95">CVE-2021-41303</h2>
<h3 data-content="1" id="843703b291d9236e9d5d979a6c006c85">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41303" target="_blank">CVE-2021-41303</a> / <a href="https://issues.apache.org/jira/browse/SHIRO-825" target="_blank">SHIRO-825</a><br/>
影响版本：<code>shiro &lt; 1.8.0</code><br/>
漏洞描述：<code>1.8.0</code> 之前的 <code>Apache Shiro</code>，在 <code>Spring Boot</code> 中使用 <code>Apache Shiro</code> 时，特制的 <code>HTTP</code> 请求可能会导致身份验证绕过。用户应该更新到 <code>Apache Shiro 1.8.0</code>。<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/4a20bf0e995909d8fda58f9c0485ea9eb2d43f0e" target="_blank">Commit</a><br/>
参考：<a href="https://threedr3am.github.io/2021/09/22/%E4%BB%8E%E6%BA%90%E7%A0%81diff%E5%88%86%E6%9E%90Apache-Shiro%201.7.1%E7%89%88%E6%9C%AC%E7%9A%84auth%20bypass%EF%BC%88CVE-2021-41303%EF%BC%89/" target="_blank">threedr3am师傅</a></p>
<h2 data-content="1" id="9c044d25581536a6952b6fe510979b27">漏洞分析</h2>
<p>根据<a href="https://threedr3am.github.io/2021/09/22/%E4%BB%8E%E6%BA%90%E7%A0%81diff%E5%88%86%E6%9E%90Apache-Shiro%201.7.1%E7%89%88%E6%9C%AC%E7%9A%84auth%20bypass%EF%BC%88CVE-2021-41303%EF%BC%89/" target="_blank">threedr3am师傅</a>博客提供的方向，看了一下Shiro 1.7.1前后<code>PathMatchingFilterChainResolver#getChain</code>的对比<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/41303_1.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/41303_2.png"/><br/>
发现在<code>1.7.1</code>版本中，先是对pathPattern和requestURI进行比较，比较成功，返回：</p>
<div class="highlight"><pre><span></span><span class="n">filterChainManager</span><span class="o">.</span><span class="na">proxy</span><span class="o">(</span><span class="n">originalChain</span><span class="o">,</span> <span class="n">pathPattern</span><span class="o">);</span>
</pre></div>
<p>否则对删除尾部斜线的pathPattern和requestURI进行比较，比较成功，跳出循环，返回：</p>
<div class="highlight"><pre><span></span><span class="n">filterChainManager</span><span class="o">.</span><span class="na">proxy</span><span class="o">(</span><span class="n">originalChain</span><span class="o">,</span> <span class="n">requestURINoTrailingSlash</span><span class="o">);</span>
</pre></div>
<p>但是正常访问，都会返回第一个<code>proxy</code>，什么时候才能绕过第一个比较并符合第二个比较呢？<br/>
可以看到，两者差别是对<code>uri</code>尾部斜线的处理，所以当在<code>uri</code>尾部加一个<code>/</code>，就会进入第二种比较方式。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/41303_3.png"/><br/>
结合之前的多次调试再根据<code>threedr3am师傅</code>博客中的认证，可以知道<code>shiro</code>的认证鉴权会根据配置的先后顺序去依次实施<br/>
所以当我有如下配置时：</p>
<pre><code>map.put("/admin/*", "authc");
map.put("/admin/page", "anon");</code></pre>
<p>循环中先匹配到<code>/admin/*</code>（这里是通过<code>while</code>语句对去除尾部斜线的<code>uri</code>进行匹配）,然后跳出循环，进入到<code>filterChainManager.proxy(originalChain, requestURINoTrailingSlash);</code>，注意，这里真正的参数就是去除尾部斜线的<code>uri</code>，也就是<code>/admin/page</code>，所以在<code>DefaultFilterChainManager#getChain</code>中得到的权限是<code>anon</code>，这样就达到绕过目的。<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/41303_4.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/41303_5.png"/></p>
<h2 data-content="1" id="b5b6139d769055e5153598c5942c894b">漏洞修复</h2>
<p>直接将<code>filterChainManager.proxy</code>的第二个参数改为<code>pathPattern</code>，直接传配置中的<code>uri</code>了<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/41303_6.png"/></p>
<h2 data-content="1" id="c15fba2d3796c23776d9dea1c665d942">CVE-2022-32532</h2>
<h3 data-content="1" id="d07f03970386e7ecda40afc8011848c6">漏洞信息</h3>
<p>漏洞编号：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-32532" target="_blank">CVE-2022-32532</a><br/>
影响版本：<code>shiro &lt; 1.9.1</code><br/>
漏洞描述：在<code>1.9.1</code>之前的<code>Apache Shiro</code>中，<code>RegexRequestMatcher</code>可能会被错误配置，从而在某些<code>servlet</code>容器上被绕过。应用程序使用<code>RegExPatternMatcher</code>与<code>.</code>的正则表达式可能容易被授权绕过。<br/>
漏洞补丁：<a href="https://github.com/apache/shiro/commit/6bcb92e06fa588b9c7790dd01bc02135d58d3f5b" target="_blank">Commit</a><br/>
参考：<a href="https://xz.aliyun.com/t/11501" target="_blank">4ra1n师傅</a></p>
<h3 data-content="1" id="8bb875e0a7cfa1f7a994e489446cc48d">漏洞分析</h3>
<p>这是最新的一个洞，看<code>Shiro</code>发布的<a href="https://lists.apache.org/thread/y8260dw8vbm99oq7zv6y3mzn5ovk90xh" target="_blank">公告</a>显示，是由于<code>RegexRequestMatcher</code>的错误配置导致的问题。<br/>
简单了解了一下，<code>RegexRequestMatcher</code>和<code>AntPathMatcher</code>类似，都是<code>Shiro</code>用于路径匹配的配置，只是<code>RegexRequestMatcher</code>需要用户自己配置。<br/>
根据<a href="https://xz.aliyun.com/t/11501" target="_blank">4ra1n师傅</a>的分析，可以知道，正常正则表达式<code>.</code>并不包含<code>\r</code>和<code>\n</code>字符<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/32532_1.png"/><br/>
修改成如下代码就可修复问题</p>
<div class="highlight"><pre><span></span><span class="c1">// flag为Pattern.DOTALL时，表达式 .可以匹配任何字符，包括行结束符。</span>
<span class="n">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="n">regex</span><span class="o">,</span><span class="n">Pattern</span><span class="o">.</span><span class="na">DOTALL</span><span class="o">);</span>
</pre></div>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/32532_2.png"/><br/>
那么回头看一下<code>RegexRequestMatcher</code>用于匹配的代码</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">matches</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">String</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"pattern argument cannot be null."</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">Pattern</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="n">pattern</span><span class="o">);</span>
        <span class="n">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="na">matches</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>可以发现，当<code>pattern</code>存在带<code>.</code>的正则表达式并且<code>source</code>中存在<code>\r</code>或<code>\n</code>字时，此时判断错误。<br/>
此时我们在配置完<code>RegexRequestMatcher</code>之后增加如下<code>Controller</code></p>
<div class="highlight"><pre><span></span><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/alter/{value}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">alter</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"绕过成功"</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"绕过成功"</span><span class="o">+</span><span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>增加如下配置</p>
<div class="highlight"><pre><span></span><span class="c1">//myFilter.java中设置成需要权限</span>
<span class="n">manager</span><span class="o">.</span><span class="na">addToChain</span><span class="o">(</span><span class="s">"/alter/.*"</span><span class="o">,</span> <span class="s">"myFilter"</span><span class="o">);</span>
</pre></div>
<p>这样正常访问<code>/alter/aaa</code>是被拒绝的，但是当访问<code>/alter/a%0aaa</code>或<code>/alter/a%0daa</code>时就会绕成验证，访问成功<br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/32532_3.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/32532_4.png"/></p>
<p><img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/32532_6.png"/><br/>
这个洞限制还是比较多的，既要服务器配置了<code>RegExPatternMatcher</code>，又要设置带有<code>.</code>的正则表达式</p>
<h3 data-content="1" id="7cf085e1e17a006bfe8fb80c6d38d96b">漏洞修复</h3>
<p>在<a href="https://github.com/apache/shiro/commit/6bcb92e06fa588b9c7790dd01bc02135d58d3f5b" target="_blank">Commit</a>可以看到，对<code>compile</code>方法设置了<code>flag</code><br/>
<img src="https://alter1125.github.io/note_images/Shiro%20%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/32532_5.png"/></p>
</div>
</div>