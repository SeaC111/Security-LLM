<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h2 data-content="1" id="372f3065538650bbff6781b941293b04">shiro漏洞分析</h2>
<p>几周前报告了CVE-2020-13933漏洞，正好前两天有师傅发了文章，分享了姿势，因此来学习下</p>
<h4 data-content="1" id="526cfe0b93aeda867b342aa1ca9373d6">CVE-2020-11989</h4>
<p>在分享13933之前，先看下11989，因为11989的修补并不完全，导致被绕过产生了13933</p>
<h5 data-content="1" id="e0a5f5f93b564cc834290a66232ae0b9">漏洞复现</h5>
<p>利用<a href="https://github.com/l3yx/springboot-shiro" target="_blank">demo</a>搭建</p>
<p>IDEA配置好tomcat，然后点击build，可以直接下载所需要配置，完成后点击run即可开始运行</p>
<h5 data-content="1" id="fe450947bef9fc541176639ba421085f">漏洞分析</h5>
<p>漏洞原理为shiro和Spring获取到的URL不相同，导致shiro鉴权后认为该URL有权限访问，Spring则会将用户前往该URL</p>
<p>首先定位shiro获取URL的位置</p>
<pre><code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code></pre>
<p>在此处打下断点，然后发送payload<code>/;/srpingboot_shiro_war_exploded/admin/page</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164658-dc560d5c-ecf8-1.png"/></p>
<p>可以看到，<code>getPathWithinApplication</code>得到的地址为<code>/</code>,跟进</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164659-dd63ae7a-ecf8-1.png"/></p>
<p>通过计算表达式，返回<code>contextPath</code>为<code>/;/srpingboot_shiro_war_exploded</code>，和我们的payload是相同的</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164701-de91ce6c-ecf8-1.png"/></p>
<p>查看<code>requestUri</code>，返回值为<code>/</code>，跟进查看</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164703-df6b61fe-ecf8-1.png"/></p>
<p>方法首先获取request的属性，返回了null，接着对url进行了获取并拼接，然后返回经过<code>decodeAndCleanUriString</code>处理后的url</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164704-e00cfbcc-ecf8-1.png"/></p>
<p>可以看到经过拼接后的值为正常的获取的值，显然是<code>decodeAndCleanUriString</code>产生的漏洞</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164705-e09c020e-ecf8-1.png"/></p>
<p>查看经过处理后的值，结果返回<code>/</code>，跟进查看</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164706-e12f15f8-ecf8-1.png"/></p>
<p>在方法内部，将会根据ascii=59，也就是<code>;</code>进行截断，包括<code>;</code>，因此返回了<code>/</code>，而shiro认为该路径是存在访问权限的，因此允许访问</p>
<p>接下来查看Spring如何处理</p>
<p><code>org.springframework.web.util.UrlPathHelper#getServletPath</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164707-e1cc41fc-ecf8-1.png"/></p>
<p>直接表达式计算，可以看到，Spring获取的是<code>/admin/page</code>，因此访问到了未授权的页面</p>
<h4 data-content="1" id="c8c0848bdea27117a633d5c8a1cee1e4">漏洞复现</h4>
<p>将pom.xml中的1.5.2替换为1.5.3，将src/main/java/org/syclover/srpingbootshiroLoginController中的后台验证<code>/admin/page</code>替换为<code>/admin/{name}</code>，然后重新build并运行即可</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164708-e27c38d2-ecf8-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164709-e31b0502-ecf8-1.png"/></p>
<p>成功复现了漏洞</p>
<h5 data-content="1" id="1358e82ba26a570e5110559b18db1625">漏洞分析</h5>
<p>通过11989的分析，可以看到出问题的地方在<code>org.apache.shiro.web.util.Webutils#getPathWithinApplication</code>，shiro1.5.3进行了修改，直接在这里下断点，然后dubug调试</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164710-e386fe6a-ecf8-1.png"/></p>
<p>更新后利用<code>getServletPath</code>和<code>getPathInfo</code>进行获取URL，然而真正的漏洞点并不在此</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164711-e40eeef6-ecf8-1.png"/></p>
<p>可以看到拼合后URL是没问题的，再看经过<code>removeSemicolon</code>处理后</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164712-e4becaba-ecf8-1.png"/></p>
<p>可以看到只保留了<code>/admin/</code>，可以在控制器里添加<code>/admin/</code>路由进行测试，</p>
<pre><code>@GetMapping("/admin/")
    public String admin2() {
        return "please login, admin";
    }</code></pre>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164713-e55dd09c-ecf8-1.png"/></p>
<p>访问是不会有权限验证的，当然，在后面添加上参数的话就需要权限了</p>
<p>跟进<code>removeSemicolon</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164713-e5cb9186-ecf8-1.png"/></p>
<p>同样，将<code>;</code>后的内容截断，包括<code>;</code></p>
<p>再看下Spring如何处理</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164714-e661ef32-ecf8-1.png"/></p>
<p>Spring没有问题，获取到的是<code>/admin/;page</code>，然后将<code>;page</code>作为一整个字符串，匹配<code>/admin/{name}</code>路由，导致越权</p>
<p>再看下是怎么处理URL的</p>
<pre><code>`org.springframework.web.util.UrlPathHelper#decodeAndCleanUriString</code></pre>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164715-e6dee618-ecf8-1.png"/></p>
<pre><code>removeSemicolonContent          # 去除;及以后部分
decodeRequestString                 # 进行urldecode解码
getSanitizedPath                        # 将//替换为/</code></pre>
<p>而shiro则相反</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164716-e74edfb8-ecf8-1.png"/></p>
<p>首先进行了urldecode，接着才去去除，从而导致了漏洞</p>
<h4 data-content="1" id="34f33a5e31aea8cd211717640996c44c">shiro 1.6.0</h4>
<p>比对1.5.3和1.6.0，对URL的获取上并没有任何改变</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164717-e7c891be-ecf8-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164718-e836d688-ecf8-1.png"/></p>
<p>不同的是增加了一个InvalidRequestFilter类，作用是对分号、反斜杠和非ASCII字符进行过滤</p>
<pre><code>org.apache.shiro.web.filter.InvalidRequestFilter</code></pre>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164718-e8c08658-ecf8-1.png"/></p>
<p>再进行漏洞测试</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164719-e9639f6e-ecf8-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200902164721-ea226dcc-ecf8-1.png"/></p>
<h3 data-content="1" id="30a51509fc1adc5120b5d749739fefe0">总结</h3>
<p>CVE-2020-13933虽然是CVE-2020-11989的绕过，然而两者的绕过内容却不同</p>
<p>11989针对于<code>/admin/page</code>，这种固定路由，shiro得到的地址为<code>/</code>，因此认为可以访问，Spring得到的地址为<code>/admin/page</code>，从而定位到未授权的页面</p>
<p>13933则是匹配非固定地址路由，比如<code>/admin/{name}</code>，因为shiro得到的是<code>/admin/</code>，认为可以访问，而Spring得到的是<code>/admin/;page</code>，如果也采取固定路由，则会因为找不到<code>;page</code>，从而返回404</p>
<h3 data-content="1" id="7d656934fad333b790a3745c15b0362d">参考：</h3>
<p><a href="https://www.anquanke.com/post/id/214964#h2-0" target="_blank">shiro &lt; 1.6.0的认证绕过漏洞分析(CVE-2020-13933)</a></p>
<p><a href="[https://reportcybercrime.com/apache-shiro-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9Ecve-2020-13933-freebuf%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%A1%8C%E4%B8%9A%E9%97%A8%E6%88%B7/](https://reportcybercrime.com/apache-shiro-权限绕过漏洞cve-2020-13933-freebuf网络安全行业门户/" target="_blank">Apache Shiro 权限绕过漏洞CVE-2020-13933</a>)</p>
<p><a href="https://xz.aliyun.com/t/7964#toc-2" target="_blank">Apache Shiro权限绕过漏洞分析(CVE-2020-11989)</a></p>
<p>[Apache Shiro 身份验证绕过漏洞 (CVE-2020-11989)](</p>
</div>
</div>