<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h2 data-content="1" id="cd510ff483afffb8b7a3caa8a4b3b396">前言</h2>
<p>下图是bleepingcomputer上总结的一些CPU漏洞，已经有许多博客和论文分析了这些漏洞。值得注意的是，ebpf的Spectre变种1(CVE-2017-5753)的补丁并没有考虑全面，导致了CVE-2019-7308。对于Spectre变种4(CVE-2018-3639)Jann Horn也给出了一个需要patch内核的利用ebpf的POC。这篇文章主要分析这两个漏洞ebpf的利用方式。在一些漏洞分析的文章中对ebpf有所提及[2][4]，所以这里也不再赘述，不清楚的读者在阅读接下来的部分之前最好自行查看参考资料。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142013-be088082-3a57-1.png"/></p>
<h2 data-content="1" id="57966160563877163731a4d731c95ca9">CVE-2018-3639利用ebpf的攻击方式</h2>
<p>为了避免重复，这里只根据微软的文章简述Speculative Store Bypass的原理[7]。考虑下面的代码。</p>
<pre><code>01: 88040F            mov [rdi+rcx],al
02: 4C0FB6040E        movzx r8,byte [rsi+rcx]
03: 49C1E00C          shl r8,byte 0xc
04: 428B0402          mov eax,[rdx+r8]</code></pre>
<p>如果CPU推测加载指令与之前的存储指令无关，那么可以在存储指令执行之前执行加载指令。第1行的MOV指令在特殊情况下可能需要额外的时间来执行(如果计算RDI+RCX的地址表达式正在等待先前的指令执行)。在这种情况下，CPU可能会推测MOVZX指令不依赖于MOV指令，并且可能在MOV指令执行之前执行MOVZX指令。这可能会导致位于RSI+RCX的内存中的旧数据被加载到R8中，从而导致第四行代码使用了错误的数据。<br/>
Project Zero给出的利用CVE-2018-3639攻击ebpf的EXP需要patch linux内核源码[8]，先来看看改动的内容。在ebpf系统调用中增加了处理0x13370001的情况，处理这个新增的cmd用的是<code>map_time_flush_loc</code>函数。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142156-fb304a9e-3a57-1.png"/><br/>
该函数读取<code>ptr + attr-&gt;flags</code>指向的内容，使用rdtscp计算读取的时间。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142224-0c4400be-3a58-1.png"/><br/>
EXP的<code>array_time_flush_loc</code>函数中用到这部分逻辑计算读取mapfd中偏移<code>idx+off</code>处内容需要的时间。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142405-48518428-3a58-1.png"/><br/>
还有就是在<code>bpf_base_func_proto</code>函数中加了一个helper函数<code>bpf_clflush_mfence_proto</code>，它的主要作用是清空缓存。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142436-5acfc452-3a58-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142443-5f24f96e-3a58-1.png"/><br/>
EXP中使用<code>BPF_CALL</code>可以调用到这部分逻辑。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142503-6adda7b0-3a58-1.png"/><br/>
EXP中我们先看ebpf指令部分，旁边我已经加上了伪代码注释。首先是一些设置。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142526-78c0173c-3a58-1.png"/><br/>
然后拿到需要泄露的内存的地址。之前<code>leak_bit</code>函数调用了<code>array_set_dw(input_map, 0, addr)</code>对此进行了设置。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142553-88c2f258-3a58-1.png"/><br/>
设置r9为<code>leak_map</code>偏移2048处。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142617-96db0c0e-3a58-1.png"/><br/>
设置r1=r7，然后清一下缓存。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142642-a5a35778-3a58-1.png"/><br/>
设置r3=fp-216。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142703-b210817a-3a58-1.png"/><br/>
接下来就是最关键的部分了。因为<code>*(u64 *)(r8)=r3</code>执行起来比较慢，所以提前执行了<code>r1=*(u64 *)(r6)</code>取到了需要泄露的内存的地址，然后<code>r2=*(u8 *)(r1)</code>取到了其中的值。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142759-d36e919a-3a58-1.png"/><br/>
后面的代码需要结合<code>leak_bit</code>函数理解。对于sockfds[16]来说根据最开始的<code>BPF_ST_MEM(BPF_B, BPF_REG_FP, -216, dummy_ff ? 0x00 : 0xff)</code>指令可以知道sockfds[bit+8]的<code>*(u8 *)(fp-216)=0x00</code>，sockfds[bit+0]的<code>*(u8 *)(fp-216)=0xff</code>。对于sockfds[bit+8]和sockfds[bit+0]，它们的selected_bit=bit&amp;7是相同的，如果取到的值是1，r2=0x1000，那么最后<code>r0=*(u8 *)(r9)= r0=*(u8 *)( leak_map偏移2048+0x1000)</code>；如果取到的值是0，r2=0，那么最后<code>r0=*(u8 *)(r9)= r0=*(u8 *)( leak_map偏移2048)</code>。而sockfds[bit+8]没有推测执行的话<code>r0=*(u8 *)( leak_map偏移2048)</code>；sockfds[bit+0]没有推测执行的话<code>r0=*(u8 *)( leak_map偏移2048+0x1000)</code>。所以如果sockfds[bit+8]读取<code>leak_map</code>偏移2048+0x1000需要的时间短，说明取到的值应该是1；如果sockfds[bit+0]读取<code>leak_map</code>偏移2048需要的时间短，说明取到的值应该是0。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142915-012389ba-3a59-1.png"/><br/>
后面再在<code>leak_byte</code>函数中进一步调用<code>leak_bit</code>函数一个一个bit拼起来就得到了泄露的byte。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227142938-0ee67882-3a59-1.png"/><br/>
用该EXP泄露指定地址的数据如下。</p>
<div class="highlight"><pre><span></span>$ sudo grep core_pattern /proc/kallsyms
ffffffff9b2954e0 D core_pattern
$ gcc -o bpf_store_skipper_assisted bpf_store_skipper_assisted.c
$ <span class="nb">time</span> ./bpf_store_skipper_assisted ffffffff9b2954e0 <span class="m">5</span>
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
BPF PROG LOADED SUCCESSFULLY
<span class="m">4</span> vs <span class="m">96</span>
<span class="m">1</span> vs <span class="m">99</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">2</span> vs <span class="m">98</span>
<span class="m">0</span> vs <span class="m">100</span>
<span class="m">100</span> vs <span class="m">0</span>
ffffffff9b2954e0: 0x63 <span class="o">(</span><span class="s1">'c'</span><span class="o">)</span>
<span class="m">2</span> vs <span class="m">98</span>
<span class="m">1</span> vs <span class="m">99</span>
<span class="m">1</span> vs <span class="m">99</span>
<span class="m">1</span> vs <span class="m">99</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">2</span> vs <span class="m">98</span>
<span class="m">0</span> vs <span class="m">100</span>
<span class="m">100</span> vs <span class="m">0</span>
ffffffff9b2954e1: 0x6f <span class="o">(</span><span class="s1">'o'</span><span class="o">)</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">3</span> vs <span class="m">97</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">1</span> vs <span class="m">99</span>
<span class="m">2</span> vs <span class="m">98</span>
<span class="m">0</span> vs <span class="m">100</span>
<span class="m">100</span> vs <span class="m">0</span>
ffffffff9b2954e2: 0x72 <span class="o">(</span><span class="s1">'r'</span><span class="o">)</span>
<span class="m">2</span> vs <span class="m">98</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">0</span> vs <span class="m">100</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">0</span> vs <span class="m">100</span>
<span class="m">0</span> vs <span class="m">100</span>
<span class="m">100</span> vs <span class="m">0</span>
ffffffff9b2954e3: 0x65 <span class="o">(</span><span class="s1">'e'</span><span class="o">)</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
<span class="m">100</span> vs <span class="m">0</span>
ffffffff9b2954e4: 0x00 <span class="o">(</span><span class="s1">''</span><span class="o">)</span>

real    0m31.591s
user    0m2.547s
sys     0m27.429s
</pre></div>
<h2 data-content="1" id="254d808870ae39f4f840fe3f2fb9e6bf">ebpf中CVE-2017-5753的补丁不完善导致的CVE-2019-7308</h2>
<p>我们仍然只根据Project Zero的文章简述Bounds Check Bypass的原理[1]。考虑下面的代码。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227143430-bcf7c386-3a59-1.png"/><br/>
CPU可能会不检查if语句中的条件就推测其为真，先将下一步指令所需要的内存加载到缓存之中，假如发现推测错误再回滚指令。但是这时CPU缓存并没有清空，通过侧信道攻击可以取到<code>arr1-&gt;data[untrusted_offset_from_caller]</code>中的值。<br/>
在ebpf系统中为了修补这个漏洞，在每个需要取数组元素的操作中都将数组的索引和掩码相与避免越界访问。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227143514-d6bae5dc-3a59-1.png"/><br/>
如果map不是由具有<code>CAP_SYS_ADMIN</code>权限的用户创建的，还会为JIT代码添加同样的操作。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227143541-e7319f28-3a59-1.png"/><br/>
补丁对数组中的指针计算并没有作用，来看看EXP是如何利用这一点的[5]。EXP中有两个重要的结构体，<code>mem_leaker_prog</code>和<code>array_timed_reader_prog</code>。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227143621-fed7e7b8-3a59-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227143635-075e21cc-3a5a-1.png"/><br/>
首先设置<code>mem_leaker_prog.data_map</code>的偏移0x1200，0x2000和0x3000处为1。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227143707-1a2fd28c-3a5a-1.png"/><br/>
在<code>leak_byte</code>函数中依次调用<code>leak_bit</code>函数得到泄露出指定地址的内存。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227144037-978e8318-3a5a-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227144050-9f43917a-3a5a-1.png"/><br/>
下面来看<code>trigger_proc(leakprog-&gt;sockfd)</code>调用的ebpf指令。首先，取到之前<code>array_set_2dw(leakprog-&gt;control_map, 0, 12-bit_index, byte_offset)</code>设置的<code>12-bit_index</code>和<code>byte_offset</code>。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227144126-b47c93a2-3a5a-1.png"/><br/>
取<code>mem_leaker_prog.data_map</code>的偏移0x1200处的值，前面说了这个值被设置为1，<code>BPF_AND</code>和<code>BPF_OR</code>对值没有影响，只是为了延长时间，使得之后的<code>BPF_JGT</code>指令CPU推测执行为false。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227144159-c83a1d74-3a5a-1.png"/><br/>
通过<code>r4=*(u8 *)(r4)</code>读到了泄露地址的内存，左移<code>12-bit_index</code>位之后和0x1000相与，如果<code>bit_index</code>位的值是1，结果是0x1000，加上0x2000导致<code>mem_leaker_prog.data_map</code>偏移0x3000处的值被加载到了缓存；如果<code>bit_index</code>位的值是0，结果是0x0，加上加上0x2000导致<code>mem_leaker_prog.data_map</code>偏移0x2000处的值被加载到了缓存。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227144229-da7a3636-3a5a-1.png"/><br/>
返回到<code>leak_bit</code>函数中，接下来分别去算读<code>mem_leaker_prog.data_map</code>偏移0x2000处的值需要的时间times[0]和<code>mem_leaker_prog.data_map</code>偏移0x3000处的值需要的时间times[1]。times[0] &lt; times[1]说明<code>bit_index</code>位的值是0，times[0] &gt; times[1]说明<code>bit_index</code>位的值是1。ebpf指令非常简单，结合注释可以很容易看懂。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227144303-ee7355c8-3a5a-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227144313-f4a042e4-3a5a-1.png"/><br/>
对于这种情况的补丁，掩码需要考虑的情况有很多，要处理的值可能存在于源寄存器中(如<code>ptr+=val</code>)，也可以存在于目的寄存器中(如<code>val+=ptr</code>)；limit取决于ALU操作是加或减以及偏移量的正负。在补丁增加的<code>retrieve_ptr_limit</code>函数中如果ALU操作是加但是偏移是负的，或者ALU操作是减但是偏移是正的说明是减法，<code>mask_to_left</code>被设置为1；否则说明是加法，<code>mask_to_left</code>被设置为0。对于map类型的指针减法的<code>limit=ptr_reg-&gt;umax_value+ptr_reg-&gt;off</code>，加法的<code>limit=ptr_reg-&gt;map_ptr-&gt;value_size–(ptr_reg-&gt;smin_value+ptr_reg-&gt;off)</code>；对于stack类型的指针减法的<code>limit=MAX_BPF_STACK+off</code>，加法的<code>limit=-off</code>，其中<code>off=ptr_reg-&gt;off+ptr_reg-&gt;var_off.value</code>。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190305172334-5997e32e-3f28-1.png"/><br/>
在<code>fixup_bpf_calls</code>函数中根据前面计算的limit对寄存器中的值进行掩码运算从而避免越界访问。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190227144432-237b3e52-3a5b-1.png"/><br/>
PS：如果你还有兴趣了解这方面内容，我整理了一些CPU漏洞相关的资料：<a href="https://github.com/houjingyi233/CPU-vulnerability-collections" target="_blank">https://github.com/houjingyi233/CPU-vulnerability-collections</a></p>
<h2 data-content="1" id="ace97d43bcc6688c12769e64761361bf">参考资料</h2>
<p>1.<a href="https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html" target="_blank" title="Reading privileged memory with a side-channel ">Reading privileged memory with a side-channel</a><br/>
2.<a href="https://xz.aliyun.com/t/2212" target="_blank" title="深入分析Ubuntu本地提权漏洞—【CVE-2017-16995】">深入分析Ubuntu本地提权漏洞—【CVE-2017-16995】</a><br/>
3.<a href="http://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank">http://man7.org/linux/man-pages/man2/bpf.2.html</a><br/>
4.<a href="https://bbs.pediy.com/thread-249033.htm" target="_blank" title="Linux CVE-2017-16995整数扩展问题导致提权漏洞分析">Linux CVE-2017-16995整数扩展问题导致提权漏洞分析</a><br/>
5.<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1711" target="_blank" title="Issue 1711: Linux: eBPF Spectre v1 mitigation is insufficient ">Issue 1711: Linux: eBPF Spectre v1 mitigation is insufficient </a><br/>
6.<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank">https://www.kernel.org/doc/Documentation/networking/filter.txt</a><br/>
7.<a href="https://blogs.technet.microsoft.com/srd/2018/05/21/analysis-and-mitigation-of-speculative-store-bypass-cve-2018-3639/" target="_blank" title="Analysis and mitigation of speculative store bypass (CVE-2018-3639)">Analysis and mitigation of speculative store bypass (CVE-2018-3639)</a><br/>
8.<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1528" target="_blank" title="Issue 1528: speculative execution, variant 4: speculative store bypass ">Issue 1528: speculative execution, variant 4: speculative store bypass </a></p>
</div>
</div>