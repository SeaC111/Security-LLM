<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<p>翻译自：<a href="http://find-sec-bugs.github.io/bugs.htm" target="_blank">http://find-sec-bugs.github.io/bugs.htm</a><br/>
翻译：聂心明</p>
<h1 data-content="1" id="eed8e0bf4d9fa95df1014ce33b94f120">xml解析导致xxe漏洞</h1>
<p>漏洞特征：XXE_XMLSTREAMREADER<br/>
当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br/>
危害1：探测本地文件内容（xxe：xml 外部实体）</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
<p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol "lol"&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
 &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt;
 &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
[...]
 &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
<p>解决方法：<br/>
为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br/>
有漏洞的代码：</p>
<pre><code>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</code></pre>
<p>禁用外部实体的解决方案：</p>
<pre><code>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</code></pre>
<p>禁用DTD的方案：</p>
<pre><code>public void parseXML(InputStream input) throws XMLStreamException {

    XMLInputFactory factory = XMLInputFactory.newFactory();
    factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
    XMLStreamReader reader = factory.createXMLStreamReader(input);
    [...]
}</code></pre>
<p>引用：<br/>
<a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<a href="http://openjdk.java.net/jeps/185" target="_blank">JEP 185: Restrict Fetching of External XML Resources</a></p>
<h1 data-content="1" id="bba58ae5d9d185c59d183894319632bf">xml解析导致xxe漏洞(XPathExpression)</h1>
<p>漏洞特征：XXE_XPATH<br/>
当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br/>
危害1：探测本地文件内容（xxe：xml 外部实体）</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
<p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol "lol"&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
 &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt;
 &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
[...]
 &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
<p>解决方法：<br/>
为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br/>
有漏洞的代码：</p>
<pre><code>DocumentBuilder builder = df.newDocumentBuilder();

XPathFactory xPathFactory = XPathFactory.newInstance();
XPath xpath = xPathFactory.newXPath();
XPathExpression xPathExpr = xpath.compile("/somepath/text()");

xPathExpr.evaluate(new InputSource(inputStream));</code></pre>
<p>下面的两个片段展示了可能的解决方案。你可以设置其中一个，或者两个都设置</p>
<p>使用"Secure processing" 模式的解决方案</p>
<pre><code>DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
df.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
DocumentBuilder builder = df.newDocumentBuilder();

[...]

xPathExpr.evaluate( builder.parse(inputStream) );</code></pre>
<p>禁用DTD的解决方案：<br/>
通过禁用DTD，大多数的xxe攻击都可以被避免</p>
<pre><code>DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
DocumentBuilder builder = df.newDocumentBuilder();

[...]

xPathExpr.evaluate( builder.parse(inputStream) );</code></pre>
<p>引用：<br/>
<a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE" target="_blank">XML External Entity (XXE) Prevention Cheat Sheet</a>_Prevention_Cheat_Sheet#XPathExpression)</p>
<h1 data-content="1" id="ba96615b0660f5781d96dd70b17dd135">xml解析导致xxe漏洞(SAXParser)</h1>
<p>漏洞特征：XXE_SAXPARSER<br/>
当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br/>
危害1：探测本地文件内容（xxe：xml 外部实体）</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
<p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol "lol"&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
 &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt;
 &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
[...]
 &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
<p>解决方法：<br/>
为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br/>
有漏洞的代码：</p>
<pre><code>SAXParser parser = SAXParserFactory.newInstance().newSAXParser();

parser.parse(inputStream, customHandler);</code></pre>
<p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p>
<p><strong>使用"Secure processing" 模式的解决方案:</strong><br/>
这个设置能保护你能避免拒绝服务攻击和ssrf漏洞</p>
<pre><code>SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
SAXParser parser = spf.newSAXParser();

parser.parse(inputStream, customHandler);</code></pre>
<p><strong>禁用DTD的解决方案:</strong><br/>
通过禁用DTD，大多数的xxe攻击都可以被避免</p>
<pre><code>SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
SAXParser parser = spf.newSAXParser();

parser.parse(inputStream, customHandler);</code></pre>
<p>引用：<br/>
<a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<a href="http://xerces.apache.org/xerces-j/features.html" target="_blank">Xerces complete features list</a></p>
<h1 data-content="1" id="d512e77eb4cc22f928a54545623ce37b">xml解析导致xxe漏洞(XMLReader)</h1>
<p>漏洞特征：XXE_XMLREADER<br/>
当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br/>
危害1：探测本地文件内容（xxe：xml 外部实体）</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
<p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol "lol"&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
 &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt;
 &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
[...]
 &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
<p>解决方法：<br/>
为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br/>
有漏洞的代码：</p>
<pre><code>XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setContentHandler(customHandler);
reader.parse(new InputSource(inputStream));</code></pre>
<p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p>
<p><strong>使用"Secure processing" 模式的解决方案:</strong><br/>
这个设置能保护你能避免拒绝服务攻击和ssrf漏洞</p>
<pre><code>XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
reader.setContentHandler(customHandler);

reader.parse(new InputSource(inputStream));</code></pre>
<p><strong>禁用DTD的解决方案:</strong><br/>
通过禁用DTD，大多数的xxe攻击都可以被避免</p>
<pre><code>XMLReader reader = XMLReaderFactory.createXMLReader();
reader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
reader.setContentHandler(customHandler);

reader.parse(new InputSource(inputStream));</code></pre>
<p>引用：<br/>
<a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<a href="http://xerces.apache.org/xerces-j/features.html" target="_blank">Xerces complete features list</a></p>
<h1 data-content="1" id="912f82efd2b823af516b939a0719398f">xml解析导致xxe漏洞(DocumentBuilder)</h1>
<p>漏洞特征：XXE_DOCUMENT<br/>
当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br/>
危害1：探测本地文件内容（xxe：xml 外部实体）</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
<p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol "lol"&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
 &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt;
 &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
[...]
 &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
<p>解决方法：<br/>
为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br/>
有漏洞的代码：</p>
<pre><code>DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();

Document doc = db.parse(input);</code></pre>
<p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p>
<p><strong>使用"Secure processing" 模式的解决方案:</strong><br/>
这个设置能保护你能避免拒绝服务攻击和ssrf漏洞</p>
<pre><code>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
DocumentBuilder db = dbf.newDocumentBuilder();

Document doc = db.parse(input);</code></pre>
<p><strong>禁用DTD的解决方案:</strong><br/>
通过禁用DTD，大多数的xxe攻击都可以被避免</p>
<pre><code>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
DocumentBuilder db = dbf.newDocumentBuilder();

Document doc = db.parse(input);</code></pre>
<p>引用：<br/>
<a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank">Identifying Xml eXternal Entity vulnerability (XXE)</a><br/>
<a href="http://xerces.apache.org/xerces-j/features.html" target="_blank">Xerces complete features list</a></p>
<h1 data-content="1" id="ffe1056ed4bf2c1a53407814fda54d21">xml解析导致xxe漏洞(TransformerFactory)</h1>
<p>漏洞特征：XXE_DTD_TRANSFORM_FACTORY<br/>
当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br/>
危害1：探测本地文件内容（xxe：xml 外部实体）</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE foo [
   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>
<p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
 &lt;!ENTITY lol "lol"&gt;
 &lt;!ELEMENT lolz (#PCDATA)&gt;
 &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
 &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt;
 &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
[...]
 &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre>
<p>解决方法：<br/>
为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br/>
有漏洞的代码：</p>
<pre><code>Transformer transformer = TransformerFactory.newInstance().newTransformer();
transformer.transform(input, result);</code></pre>
<p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p>
<p><strong>使用"Secure processing" 模式的解决方案:</strong><br/>
这个设置能保护你能避免拒绝服务攻击和ssrf漏洞</p>
<pre><code>TransformerFactory factory = TransformerFactory.newInstance();
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "all");
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "all");

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</code></pre>
<p><strong>禁用DTD的解决方案:</strong><br/>
通过禁用DTD，大多数的xxe攻击都可以被避免</p>
<pre><code>TransformerFactory factory = TransformerFactory.newInstance();
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</code></pre>
<p>引用：<br/>
<a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank">Identifying Xml eXternal Entity vulnerability (XXE)</a></p>
<h1 data-content="1" id="1d3538819a7b0c9c52e20e67f5b71f35">XSLT解析导致xxe漏洞(TransformerFactory)</h1>
<p>漏洞特征：XXE_XSLT_TRANSFORM_FACTORY<br/>
当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br/>
危害1：探测本地文件内容（xxe：xml 外部实体）</p>
<pre><code>&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
   &lt;xsl:template match="/"&gt;
       &lt;xsl:value-of select="document('/etc/passwd')"&gt;
   &lt;/xsl:value-of&gt;&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>
<p>解决方法：<br/>
为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br/>
有漏洞的代码：</p>
<pre><code>Transformer transformer = TransformerFactory.newInstance().newTransformer();
transformer.transform(input, result);</code></pre>
<p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p>
<p><strong>使用"Secure processing" 模式的解决方案:</strong><br/>
这个设置能保护你能避免ssrf漏洞但是不能避免拒绝服务攻击</p>
<pre><code>TransformerFactory factory = TransformerFactory.newInstance();
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "all");
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "all");

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</code></pre>
<p><strong>禁用DTD的解决方案:</strong><br/>
这个设置能保护你能避免ssrf漏洞但是不能避免拒绝服务攻击</p>
<pre><code>TransformerFactory factory = TransformerFactory.newInstance();
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);

Transformer transformer = factory.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

transformer.transform(input, result);</code></pre>
<p>引用：<br/>
<a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank">CWE-611: Improper Restriction of XML External Entity Reference ('XXE')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank">CERT: IDS10-J. Prevent XML external entity attacks</a><br/>
<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank">OWASP.org: XML External Entity (XXE) Processing</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank">WS-Attacks.org: XML Entity Expansion</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank">WS-Attacks.org: XML External Entity DOS</a><br/>
<a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank">WS-Attacks.org: XML Entity Reference Attack</a><br/>
<a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank">Identifying Xml eXternal Entity vulnerability (XXE)</a></p>
<h1 data-content="1" id="4af8f48c5ca9d1adae3bf131ad07fa68">潜在的XPath注入</h1>
<p>漏洞特征： XPATH_INJECTION<br/>
XPath注入的危险程度就像sql注入一样。如果XPath查询包含不信任的用户输入，那么数据库就会被完全暴露。这样就可以让攻击者访问未授权的数据或者在目标xml数据库中放入恶意数据。</p>
<p>引用：<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-39: XPath Injection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/643.html" target="_blank">CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')</a><br/>
<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61407250" target="_blank">CERT: IDS09-J. Prevent XPath Injection (archive)</a><br/>
<a href="http://media.blackhat.com/bh-eu-12/Siddharth/bh-eu-12-Siddharth-Xpath-WP.pdf" target="_blank">Black Hat Europe 2012: Hacking XPath 2.0</a><br/>
<a href="http://www.balisage.net/Proceedings/vol7/html/Vlist02/BalisageVol7-Vlist02.html" target="_blank">Balisage: XQuery Injection</a></p>
<h1 data-content="1" id="ab60df30908e1820ca02415d3bf1e469">发现Struts 1 服务器端</h1>
<p>漏洞特征： STRUTS1_ENDPOINT<br/>
这个类是Struts 1 的Action<br/>
曾清一个请求被路由到一个控制器中，Form对象将会被自动的实例化为http参数的对象。这些参数应该被严格检查，以保证它们是安全的。</p>
<h1 data-content="1" id="c958d19e4c562650d7aef02812ccb24a">发现Struts 2 服务器端</h1>
<p>漏洞特征：STRUTS2_ENDPOINT<br/>
在Struts 2中，服务器端是简单的Java对象 (POJOs)，这就意味着没有接口/类 需要被实现/拓展</p>
<p>当一个请求被路由到它的控制器的时候（像这些被选择的类），http提供的参数会被自动的映射到类中的setters中。所以，所有类中的setters都应该被看成来自不被信任源的输入，即使form中没有包含那些值。一个攻击者都被在请求中插入一些额外的值，他们会被当成对象，只要对象具有这样的setter。这些参数应该被严格检查，以保证它们是安全的。</p>
<h1 data-content="1" id="8a34c75598887cc2823de8e1f822c2c8">发现Spring 服务器端</h1>
<p>漏洞特征： SPRING_ENDPOINT<br/>
这个类是一个Spring的控制器。所有方法的注解都在RequestMapping（还有一些简化注解在GetMapping, PostMapping, PutMapping, DeleteMapping, 和 PatchMapping），这些方法都能被远程访问到。这些类应该被严格的分析，以保证暴露给远程的方法是安全的，不会被攻击者轻易攻击。</p>
<h1 data-content="1" id="c6cb77111db2f5857193d64f8d0c7947">Spring关闭 CSRF保护</h1>
<p>漏洞特征： SPRING_CSRF_PROTECTION_DISABLED<br/>
对于标准的web应用程序来讲，关闭Spring的CSRF保护显然是不安全的。<br/>
禁用此保护的有效使用场景是服务器暴露一个可以改变状态的接口，这个接口仅可以被非浏览器操控。</p>
<p><strong>不安全的配置</strong></p>
<pre><code>@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();
    }
}</code></pre>
<p>引用：<br/>
<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#when-to-use-csrf-protection" target="_blank">Spring Security Official Documentation: When to use CSRF protection</a><br/>
<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#when-to-use-csrf-protection" target="_blank">OWASP: Cross-Site Request Forgery</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet" target="_blank">OWASP: CSRF Prevention Cheat Sheet</a><br/>
<a href="https://cwe.mitre.org/data/definitions/352.html" target="_blank">CWE-352: Cross-Site Request Forgery (CSRF)</a></p>
<h1 data-content="1" id="20147174325435136c3c675a489c8778">Spring 中不受CSRF限制的RequestMapping</h1>
<p>漏洞特征： SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING<br/>
通过默认的映射所有的HTTP请求方法都会被RequestMapping注解。可是，http请求中的GET, HEAD, TRACE, 和OPTIONS（可能会导致tokens被泄露）方法不会默认开启csrf保护。所以，被RequestMapping注解的可以改变状态的方法和 POST, PUT, DELETE, 或者 PATCH这些http请求方法都会受到csrf攻击。</p>
<p>有漏洞的代码：</p>
<pre><code>@Controller
public class UnsafeController {

    @RequestMapping("/path")
    public void writeData() {
        // State-changing operations performed within this method.
    }
}</code></pre>
<p>解决方案（Spring Framework 4.3和更新的版本）</p>
<pre><code>@Controller
public class SafeController {

    /**
     * For methods without side-effects use @GetMapping.
     */
    @GetMapping("/path")
    public String readData() {
        // No state-changing operations performed within this method.
        return "";
    }

    /**
     * For state-changing methods use either @PostMapping, @PutMapping, @DeleteMapping, or @PatchMapping.
     */
    @PostMapping("/path")
    public void writeData() {
        // State-changing operations performed within this method.
    }
}</code></pre>
<p>解决方案（在Spring Framework 4.3之前的版本）</p>
<pre><code>@Controller
public class SafeController {

    /**
     * For methods without side-effects use either
     * RequestMethod.GET, RequestMethod.HEAD, RequestMethod.TRACE, or RequestMethod.OPTIONS.
     */
    @RequestMapping(value = "/path", method = RequestMethod.GET)
    public String readData() {
        // No state-changing operations performed within this method.
        return "";
    }

    /**
     * For state-changing methods use either
     * RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE, or RequestMethod.PATCH.
     */
    @RequestMapping(value = "/path", method = RequestMethod.POST)
    public void writeData() {
        // State-changing operations performed within this method.
    }
}</code></pre>
<p>引用：<br/>
<a>Spring Security Official Documentation: Use proper HTTP verbs (CSRF protection)</a>)<br/>
<a>OWASP: Cross-Site Request Forgery</a><br/>
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet" target="_blank">OWASP: CSRF Prevention Cheat Sheet</a><br/>
<a href="https://cwe.mitre.org/data/definitions/352.html" target="_blank">CWE-352: Cross-Site Request Forgery (CSRF)</a></p>
<h1 data-content="1" id="5b4a0d8e4872ded8280a13b5e81c3575">潜在的注入（custom）</h1>
<p>漏洞特征： CUSTOM_INJECTION<br/>
扫描工具所识别的函数存在注射问题。应验证输入并争取转义。</p>
<p>有漏洞的代码：</p>
<pre><code>SqlUtil.execQuery("select * from UserEntity t where id = " + parameterInput);</code></pre>
<p>wiki在线有很详细的教程关于<a href="https://github.com/find-sec-bugs/find-sec-bugs/wiki/Custom-signatures" target="_blank">如何配置custom</a></p>
<p>引用：<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet </a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a></p>
<h1 data-content="1" id="778ceb2a6a94b6e67a254cd605e3ef48">潜在的sql注入</h1>
<p>漏洞特征：SQL_INJECTION<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。或者，每一个参数应该被正确的转义。<br/>
有漏洞的代码：</p>
<pre><code>createQuery("select * from User where id = '"+inputId+"'");</code></pre>
<p>解决方案：</p>
<pre><code>import org.owasp.esapi.Encoder;

createQuery("select * from User where id = '"+Encoder.encodeForSQL(inputId)+"'");</code></pre>
<p>引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="a4a33b85b2a94436eab69fa93ee73842">在Turbine中潜在的sql注入</h1>
<p>漏洞特征：SQL_INJECTION_TURBINE<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。或者，每一个参数应该被正确的转义。<br/>
Turbine API 提供DSL在java代码中构建查询<br/>
有漏洞的代码：</p>
<pre><code>List&lt;Record&gt; BasePeer.executeQuery( "select * from Customer where id=" + inputId );</code></pre>
<p>解决方案（使用Criteria DSL）：</p>
<pre><code>Criteria c = new Criteria();
c.add( CustomerPeer.ID, inputId );

List&lt;Customer&gt; customers = CustomerPeer.doSelect( c );</code></pre>
<p>解决方案（使用特殊方法）：</p>
<pre><code>Customer customer = CustomerPeer.retrieveByPK( new NumberKey( inputId ) );</code></pre>
<p>解决方法（使用OWASP提供的编码方法）</p>
<pre><code>import org.owasp.esapi.Encoder;

BasePeer.executeQuery("select * from Customer where id = '"+Encoder.encodeForSQL(inputId)+"'");</code></pre>
<p>引用(Turbine)：<br/>
<a href="https://turbine.apache.org/turbine/turbine-2.1/howto/criteria-howto.html" target="_blank">Turbine Documentation: Criteria Howto</a><br/>
引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="affb1910bd1e4ddf8fadb718965d203b">潜在的SQL/HQL注入(Hibernate)</h1>
<p>漏洞特征：SQL_INJECTION_HIBERNATE<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。或者，可以使用Hibernate的Criteria。<br/>
有漏洞的代码：</p>
<pre><code>Session session = sessionFactory.openSession();
Query q = session.createQuery("select t from UserEntity t where id = " + input);
q.execute();</code></pre>
<p>解决方案：</p>
<pre><code>Session session = sessionFactory.openSession();
Query q = session.createQuery("select t from UserEntity t where id = :userId");
q.setString("userId",input);
q.execute();</code></pre>
<p>动态查询参数法解决方案（Hibernate Criteria）</p>
<pre><code>Session session = sessionFactory.openSession();
Query q = session.createCriteria(UserEntity.class)
    .add( Restrictions.like("id", input) )
    .list();
q.execute();</code></pre>
<p>引用(Hibernate)<br/>
<a href="https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/querycriteria.html" target="_blank">Hibernate Documentation: Query Criteria</a><br/>
<a href="https://docs.jboss.org/hibernate/orm/3.2/api/org/hibernate/Query.html" target="_blank">Hibernate Javadoc: Query Object</a><br/>
<a href="http://blog.h3xstream.com/2014/02/hql-for-pentesters.html" target="_blank">HQL for pentesters: Guideline to test if the suspected code is exploitable.</a><br/>
引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="dbbc08859e7b5cdbee1da9a72f1c3b30">潜在的sql/JDOQL注入(JDO)</h1>
<p>漏洞特征：SQL_INJECTION_JDO<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br/>
有漏洞的代码：</p>
<pre><code>PersistenceManager pm = getPM();

Query q = pm.newQuery("select * from Users where name = " + input);
q.execute();</code></pre>
<p>解决方案：</p>
<pre><code>PersistenceManager pm = getPM();

Query q = pm.newQuery("select * from Users where name = nameParam");
q.declareParameters("String nameParam");
q.execute(input);</code></pre>
<p>引用(JDO)：<br/>
<a href="https://db.apache.org/jdo/object_retrieval.html" target="_blank">JDO: Object Retrieval</a><br/>
引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="2112158a8550a01f5d81e2b643310908">潜在的sql/JPQL注入(JPA)</h1>
<p>漏洞特征： SQL_INJECTION_JPA<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br/>
有漏洞的代码：</p>
<pre><code>EntityManager pm = getEM();

TypedQuery&lt;UserEntity&gt; q = em.createQuery(
    String.format("select * from Users where name = %s", username),
    UserEntity.class);

UserEntity res = q.getSingleResult();</code></pre>
<p>解决方案：</p>
<pre><code>TypedQuery&lt;UserEntity&gt; q = em.createQuery(
    "select * from Users where name = usernameParam",UserEntity.class)
    .setParameter("usernameParam", username);

UserEntity res = q.getSingleResult();</code></pre>
<p>引用 (JPA)<br/>
<a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbrg.html" target="_blank">The Java EE 6 Tutorial: Creating Queries Using the Java Persistence Query Language</a><br/>
引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="ade796f9d01cd852af00753e785704cd">潜在的JDBC注入(Spring JDBC)</h1>
<p>漏洞特征：SQL_INJECTION_SPRING_JDBC<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。或者，每一个参数应该被正确的转义。<br/>
有漏洞的代码：</p>
<pre><code>JdbcTemplate jdbc = new JdbcTemplate();
int count = jdbc.queryForObject("select count(*) from Users where name = '"+paramName+"'", Integer.class);</code></pre>
<p>解决方案：</p>
<pre><code>JdbcTemplate jdbc = new JdbcTemplate();
int count = jdbc.queryForObject("select count(*) from Users where name = ?", Integer.class, paramName);</code></pre>
<p>引用 (Spring JDBC)<br/>
<a href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/jdbc.html" target="_blank">Spring Official Documentation: Data access with JDBC</a><br/>
引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="497209f9100b7aad364013c133101010">潜在的JDBC注入</h1>
<p>漏洞特征：SQL_INJECTION_JDBC<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br/>
有漏洞的代码：</p>
<pre><code>Connection conn = [...];
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("update COFFEES set SALES = "+nbSales+" where COF_NAME = '"+coffeeName+"'");</code></pre>
<p>解决方案：</p>
<pre><code>Connection conn = [...];
conn.prepareStatement("update COFFEES set SALES = ? where COF_NAME = ?");
updateSales.setInt(1, nbSales);
updateSales.setString(2, coffeeName);</code></pre>
<p>引用 (JDBC)<br/>
<a href="http://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html" target="_blank">Oracle Documentation: The Java Tutorials &gt; Prepared Statements</a><br/>
引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="4f78fe3f60458a95dcee38d7ab6e76c6">潜在的Scala Slick注入</h1>
<p>漏洞特征：SCALA_SQL_INJECTION_SLICK<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br/>
有漏洞的代码：</p>
<pre><code>db.run {
  sql"select * from people where name = '#$value'".as[Person]
}</code></pre>
<p>解决方案：</p>
<pre><code>db.run {
  sql"select * from people where name = $value".as[Person]
}</code></pre>
<p>引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="297468de7e410e67ddd6a05dae265d3e">潜在的Scala Anorm注入</h1>
<p>漏洞特征：SCALA_SQL_INJECTION_ANORM<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br/>
有漏洞的代码：</p>
<pre><code>val peopleParser = Macro.parser[Person]("id", "name", "age")

DB.withConnection { implicit c =&gt;
  val people: List[Person] = SQL("select * from people where name = '" + value + "'").as(peopleParser.*)
}</code></pre>
<p>解决方案：</p>
<pre><code>val peopleParser = Macro.parser[Person]("id", "name", "age")

DB.withConnection { implicit c =&gt;
  val people: List[Person] = SQL"select * from people where name = $value".as(peopleParser.*)
}</code></pre>
<p>引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="7ce65f4c7ef71172c96c0b164d681784">潜在的安卓sql注入</h1>
<p>漏洞特征：SQL_INJECTION_ANDROID<br/>
输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br/>
有漏洞的代码：</p>
<pre><code>String query = "SELECT * FROM  messages WHERE uid= '"+userInput+"'" ;
Cursor cursor = this.getReadableDatabase().rawQuery(query,null);</code></pre>
<p>解决方案：</p>
<pre><code>String query = "SELECT * FROM  messages WHERE uid= ?" ;
Cursor cursor = this.getReadableDatabase().rawQuery(query,new String[] {userInput});</code></pre>
<p>引用 (Android SQLite)<br/>
<a href="http://www.informit.com/articles/article.aspx?p=2268753&amp;seqNum=5" target="_blank">InformIT.com: Practical Advice for Building Secure Android Databases in SQLite </a><br/>
<a href="https://www.packtpub.com/books/content/knowing-sql-injection-attacks-and-securing-our-android-applications-them" target="_blank">Packtpub.com: Knowing the SQL-injection attacks and securing our Android applications from them</a></p>
<p><a href="https://books.google.ca/books?id=SXlMAQAAQBAJ&amp;lpg=PR1&amp;pg=PA64#v=onepage&amp;q&amp;f=false" target="_blank">Android Database Support (Enterprise Android: Programming Android Database Applications for the Enterprise)</a></p>
<p><a href="https://stackoverflow.com/a/29797229/89769" target="_blank">Safe example of Insert, Select, Update and Delete queryies provided by Suragch</a></p>
<p>引用（sql注入）<br/>
<a href="http://projects.webappsec.org/w/page/13246963/SQL%20Injection" target="_blank">WASC-19: SQL Injection</a><br/>
<a href="http://capec.mitre.org/data/definitions/66.html" target="_blank">CAPEC-66: SQL Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank">CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank">OWASP: SQL Injection Prevention Cheat Sheet</a><br/>
<a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank">OWASP: Query Parameterization Cheat Sheet</a></p>
<h1 data-content="1" id="f3c37d1b5963ce5882d8855e1852c25e">潜在的LDAP注入</h1>
<p>漏洞特征：LDAP_INJECTION<br/>
就像sql，所有进入到ldap查询的语句都必须要保证安全。不幸的是，ldap没有像sql那样的预编译接口。所以，现在的主要防御方式是，在参数进入ladp查询之前对其进行严格的检验。<br/>
有漏洞的代码：</p>
<pre><code>NamingEnumeration&lt;SearchResult&gt; answers = context.search("dc=People,dc=example,dc=com",
        "(uid=" + username + ")", ctrls);</code></pre>
<p>引用：<br/>
<a href="http://projects.webappsec.org/w/page/13246947/LDAP%20Injection" target="_blank">WASC-29: LDAP Injection</a><br/>
<a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank">OWASP: Top 10 2013-A1-Injection</a><br/>
<a href="http://cwe.mitre.org/data/definitions/90.html" target="_blank">CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection') </a><br/>
<a href="http://www.veracode.com/security/ldap-injection" target="_blank">LDAP Injection Guide: Learn How to Detect LDAP Injections and Improve LDAP Security</a></p>
</div>
</div>