<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h2 data-content="1" id="b9488fb233dc4d000823d1863b72821c">CVE-2024-21733 请求走私</h2>
<h3 data-content="1" id="a12630818d85cad351595e393334939c">前言</h3>
<p>最近看到这个漏洞，真的很有意思，因为之前一直没有接触过请求走私，在这里顺便学习了一下，然后看到网上几乎只是告诉你如何去打，几乎没有分析，在这里也来分析一下</p>
<h3 data-content="1" id="8fcd74dc61bc18d86d41d83ce915577b">走私漏洞原理</h3>
<h2 data-content="1" id="c87846264294fb5f0a84b8a1cdfe0478">漏洞原理</h2>
<p>Web应用程序经常在用户和最终应用程序逻辑之间使用HTTP服务器链，用户将请求发送到前端服务器(有时称为"负载均衡器"或"反向代理")，然后该服务器将请求转发到一台或多台后端服务器，这种类型的架构在现代基于云的应用程序中越来越常见并且在某些情况下是不可避免的，而当前端服务器将HTTP请求转发到后端服务器时，它通常会通过同一后端网络连接发送多个请求，因为这样的效率和性能要高得多，HTTP请求被一个接一个地发送，接收服务器必须确定一个请求在哪里结束以及下一个请求从哪里开始</p>
<p>在这种情况下前端和后端系统就请求之间的边界达成一致至关重要，否则攻击者可能能够发送不明确的请求，前端和后端系统会以不同的方式解释该请求，在下面的示例图中攻击者通过更改请求数据包导致其前端请求的一部分被后端服务器解释为下一个请求的开始，它有效地添加到下一个请求之前，因此可能会干扰应用程序处理该请求的方式，这便是请求走私攻击，可能会造成灾难性的后果</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240916115228-180914b8-73df-1.png"/></p>
<h3 data-content="1" id="e7fa2b7286d9dae29fcdff2927d0fca6">环境搭建</h3>
<p>这里使用spring搭建的，内置tomcat为</p>
<div class="highlight"><pre><span></span><span class="x">9.0.43</span>
</pre></div>
<p>然后随便写一个路由用于测试</p>
<div class="highlight"><pre><span></span><span class="x">public class tomcat {</span>

<span class="x">    @RequestMapping({"/cve"})</span>
<span class="x">    public String cve(HttpServletRequest request) {</span>
<span class="x">        String name = request.getParameter("name");</span>
<span class="x">        return "Your name is:" + name;</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
<h3 data-content="1" id="7532beed760f562fc6bd3dd0c6c9b72b">漏洞复现</h3>
<p>首先访问路由，随便输入一些东西</p>
<p>发送请求</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240916115249-246517fc-73df-1.png"/></p>
<p>然后再次发送一个请求</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240916115254-2708aa64-73df-1.png"/></p>
<p>可以发现我们上次的数据已经被爆出来了</p>
<p>需要content—length设置比原文大于1</p>
<h3 data-content="1" id="5a4bc5a5439416c320b26eb1ade42cec">漏洞分析</h3>
<h4 data-content="1" id="660f76b52460ca8ba1f32b7c094ac6d5">正常处理流程</h4>
<p>这里先简单分析一个正常的流程</p>
<p>我们关注到处理请求的地方</p>
<div class="highlight"><pre><span></span><span class="x">parseParameters:3216, Request (org.apache.catalina.connector)</span>
<span class="x">getParameter:1142, Request (org.apache.catalina.connector)</span>
<span class="x">getParameter:381, RequestFacade (org.apache.catalina.connector)</span>
<span class="x">cve:20, tomcat (com.example.headerstealer.controller)</span>
</pre></div>
<p>可以看到是访问我们路由后处理参数的时候</p>
<p>具体逻辑就在parseParameters方法</p>
<p>这里重点关注处理content-length的部分</p>
<div class="highlight"><pre><span></span><span class="x">int len = getContentLength();</span>
<span class="x">byte[] formData = null;</span>
<span class="x">                if (len &lt; CACHED_POST_LEN) {</span>
<span class="x">                    if (postData == null) {</span>
<span class="x">                        postData = new byte[CACHED_POST_LEN];</span>
<span class="x">                    }</span>
<span class="x">                    formData = postData;</span>
<span class="x">                } else {</span>
<span class="x">                    formData = new byte[len];</span>
<span class="x">                }</span>
<span class="x">                try {</span>
<span class="x">                    if (readPostBody(formData, len) != len) {</span>
<span class="x">                        parameters.setParseFailedReason(FailReason.REQUEST_BODY_INCOMPLETE);</span>
<span class="x">                        return;</span>
<span class="x">                    }</span>
<span class="x">                }</span>
</pre></div>
<p>先获取我们的长度，然后formData是来自</p>
<div class="highlight"><pre><span></span><span class="x">postData = new byte[CACHED_POST_LEN];</span>
</pre></div>
<p>CACHED_POST_LEN就是储存的意思，下面也会分析到，也就是上次请求的值</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240916115302-2c0204a2-73df-1.png"/></p>
<p>进入readPostBody方法</p>
<div class="highlight"><pre><span></span><span class="x">protected int readPostBody(byte[] body, int len)</span>
<span class="x">        throws IOException {</span>

<span class="x">    int offset = 0;</span>
<span class="x">    do {</span>
<span class="x">        int inputLen = getStream().read(body, offset, len - offset);</span>
<span class="x">        if (inputLen &lt;= 0) {</span>
<span class="x">            return offset;</span>
<span class="x">        }</span>
<span class="x">        offset += inputLen;</span>
<span class="x">    } while ((len - offset) &gt; 0);</span>
<span class="x">    return len;</span>

<span class="x">}</span>
</pre></div>
<p>首先读取输入数据的长度，然后和content的长度做比较，如果比实际长度长那么就继续循环</p>
<p>如果一样就返回</p>
<p>然后解析完后就回到</p>
<div class="highlight"><pre><span></span><span class="x">public String cve(HttpServletRequest request) {</span>
<span class="x">    String name = request.getParameter("name");</span>
<span class="x">    return "Your name is:" + name;</span>
<span class="x">}</span>
</pre></div>
<p>并返回</p>
<p>之后来到service方法</p>
<div class="highlight"><pre><span></span><span class="x">if (!isAsync() || getErrorState().isError()) {</span>
<span class="x">    request.updateCounters();</span>
<span class="x">    if (getErrorState().isIoAllowed()) {</span>
<span class="x">        inputBuffer.nextRequest();</span>
<span class="x">        outputBuffer.nextRequest();</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
<p>跟进nextRequest</p>
<div class="highlight"><pre><span></span><span class="x">void nextRequest() {</span>
<span class="x">    request.recycle();</span>

<span class="x">    if (byteBuffer.position() &gt; 0) {</span>
<span class="x">        if (byteBuffer.remaining() &gt; 0) {</span>
<span class="x">            // Copy leftover bytes to the beginning of the buffer</span>
<span class="x">            byteBuffer.compact();</span>
<span class="x">            byteBuffer.flip();</span>
<span class="x">        } else {</span>
<span class="x">            // Reset position and limit to 0</span>
<span class="x">            byteBuffer.position(0).limit(0);</span>
<span class="x">        }</span>
<span class="x">    }</span>

<span class="x">    // Recycle filters</span>
<span class="x">    for (int i = 0; i &lt;= lastActiveFilter; i++) {</span>
<span class="x">        activeFilters[i].recycle();</span>
<span class="x">    }</span>

<span class="x">    // Reset pointers</span>
<span class="x">    lastActiveFilter = -1;</span>
<span class="x">    parsingHeader = true;</span>
<span class="x">    swallowInput = true;</span>

<span class="x">    headerParsePos = HeaderParsePosition.HEADER_START;</span>
<span class="x">    parsingRequestLine = true;</span>
<span class="x">    parsingRequestLinePhase = 0;</span>
<span class="x">    parsingRequestLineEol = false;</span>
<span class="x">    parsingRequestLineStart = 0;</span>
<span class="x">    parsingRequestLineQPos = -1;</span>
<span class="x">    headerData.recycle();</span>
<span class="x">}</span>
</pre></div>
<p><code>nextRequest</code> 方法简单来说，确保在处理下一个请求之前，当前请求的所有资源都被正确回收和重置。它通过清理缓冲区、过滤器和解析状态，确保系统能够高效地处理多个请求。</p>
<p>之后来到parseRequestLine方法</p>
<p>逻辑有点复杂，分为不同的阶段</p>
<p>这里主要是二阶段</p>
<div class="highlight"><pre><span></span><span class="x">if (parsingRequestLinePhase == 2) {</span>
<span class="x">    //</span>
<span class="x">    // Reading the method name</span>
<span class="x">    // Method name is a token</span>
<span class="x">    //</span>
<span class="x">    boolean space = false;</span>
<span class="x">    while (!space) {</span>
<span class="x">        // Read new bytes if needed</span>
<span class="x">        if (byteBuffer.position() &gt;= byteBuffer.limit()) {</span>
<span class="x">            if (!fill(false)) // request line parsing</span>
<span class="x">                return false;</span>
<span class="x">        }</span>
<span class="x">        // Spec says method name is a token followed by a single SP but</span>
<span class="x">        // also be tolerant of multiple SP and/or HT.</span>
<span class="x">        int pos = byteBuffer.position();</span>
<span class="x">        chr = byteBuffer.get();</span>
<span class="x">        if (chr == Constants.SP || chr == Constants.HT) {</span>
<span class="x">            space = true;</span>
<span class="x">            request.method().setBytes(byteBuffer.array(), parsingRequestLineStart,</span>
<span class="x">                    pos - parsingRequestLineStart);</span>
<span class="x">        } else if (!HttpParser.isToken(chr)) {</span>
<span class="x">            // Avoid unknown protocol triggering an additional error</span>
<span class="x">            request.protocol().setString(Constants.HTTP_11);</span>
<span class="x">            String invalidMethodValue = parseInvalid(parsingRequestLineStart, byteBuffer);</span>
<span class="x">            throw new IllegalArgumentException(sm.getString("iib.invalidmethod", invalidMethodValue));</span>
<span class="x">        }</span>
<span class="x">    }</span>
<span class="x">    parsingRequestLinePhase = 3;</span>
<span class="x">}</span>
</pre></div>
<pre><code>**检查缓冲区**


   if (byteBuffer.position() &gt;= byteBuffer.limit()) {  
       if (!fill(false)) // request line parsing  
           return false;  
   }  


   - 如果当前缓冲区的位置已经到达限制，调用 `fill(false)` 方法填充更多数据。如果这次填充失败，则返回 `false`，表示解析尚未完成。

2. **读取字符和分析**


   int pos = byteBuffer.position();  
   chr = byteBuffer.get();  


   - 记录当前缓冲区的位置，然后读取下一个字符。

3. **判断字符类型**

   if (chr == Constants.SP || chr == Constants.HT) {  
       space = true;  
       request.method().setBytes(byteBuffer.array(), parsingRequestLineStart, pos - parsingRequestLineStart);  
   } else if (!HttpParser.isToken(chr)) {  
       request.protocol().setString(Constants.HTTP_11);  
       String invalidMethodValue = parseInvalid(parsingRequestLineStart, byteBuffer);  
       throw new IllegalArgumentException(sm.getString("iib.invalidmethod", invalidMethodValue));  
   }  


   - 第一部分：检查读取到的字符是否为空格（


     Constants.SP


     ）或水平制表符（


     Constants.HT


     ）。

     - 如果是，设置 `space` 为 `true`，并将解析的请求方法名的字节存储到 `request.method()` 中。方法名的字节内容来源于 `byteBuffer`，从 `parsingRequestLineStart` 开始，长度为当前位置和开始位置之间的差值。

   - 第二部分：如果读取的字符不是有效的标记（确认是否是支持的 HTTP 方法），则：

     - 默认将请求的协议设置为 `HTTP/1.1`。
     - 解析获取到的无效方法名，并抛出 `IllegalArgumentException`，附上无效方法的值。</code></pre>
<p>当然我这里其实主要分析的是漏洞部分相关的</p>
<h4 data-content="1" id="7f0e170ebdf481fd68c1f9f8e78367b2">回显之报错原因</h4>
<p>首先需要明白一个问题，为什么会报错</p>
<div class="highlight"><pre><span></span><span class="n">HTTP</span> <span class="n">method</span> <span class="n">names</span> <span class="n">must</span> <span class="n">be</span> <span class="n">tokens</span>
    <span class="n">at</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">coyote</span><span class="o">.</span><span class="na">http11</span><span class="o">.</span><span class="na">Http11InputBuffer</span><span class="o">.</span><span class="na">parseRequestLine</span><span class="o">(</span><span class="n">Http11InputBuffer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">417</span><span class="o">)</span> <span class="o">~[</span><span class="n">tomcat</span><span class="o">-</span><span class="n">embed</span><span class="o">-</span><span class="n">core</span><span class="o">-</span><span class="mf">9.0.43</span><span class="o">.</span><span class="na">jar</span><span class="o">:</span><span class="mf">9.0.43</span><span class="o">]</span>
</pre></div>
<p>也就是我们分析的parseRequestLine方法的第二阶段的时候，每个阶段都是解析不同的字符</p>
<div class="highlight"><pre><span></span><span class="x">if (!HttpParser.isToken(chr)) {</span>
<span class="x">    // Avoid unknown protocol triggering an additional error</span>
<span class="x">    request.protocol().setString(Constants.HTTP_11);</span>
<span class="x">    String invalidMethodValue = parseInvalid(parsingRequestLineStart, byteBuffer);</span>
<span class="x">    throw new IllegalArgumentException(sm.getString("iib.invalidmethod", invalidMethodValue));</span>
</pre></div>
<p>也就是当数据没有正常的token的时候会抛出异常，把不合法的invalidMethodValue抛了出来，而这个就是我们数据的value值</p>
<div class="highlight"><pre><span></span><span class="x">String invalidMethodValue = parseInvalid(parsingRequestLineStart, byteBuffer);</span>
</pre></div>
<p>value就是我们的请求数据</p>
<p>那为什么会不合法呢？合法的又是什么呢？首先第二阶段是解析请求头的阶段</p>
<p>判断依据主要是第一个字符的if</p>
<div class="highlight"><pre><span></span><span class="x">if (chr == Constants.SP || chr == Constants.HT)</span>
</pre></div>
<p>这个表示结束，因为我们的请求包一般都是POST空格啥的</p>
<div class="highlight"><pre><span></span><span class="x">public static final byte SP = (byte) ' ';</span>


<span class="x">/**</span>
<span class="x"> * HT.</span>
<span class="x"> */</span>
<span class="x">public static final byte HT = (byte) '\t';</span>
</pre></div>
<p>然后istoken就是限制请求头方法不能有的值，比如=，@等这些</p>
<p>而我们读取的数据是</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240916115514-7a8bbf14-73df-1.png"/></p>
<p>其中有=号，所以报错错误抛出异常</p>
<p>那我们的数据为什么是这样的呢？</p>
<h4 data-content="1" id="f85083a09bc327dc16dba725e6aae4b0">content-length对读取数据的影响</h4>
<p>按照上面分析的正常流程，我们会走到parseParameters方法</p>
<p>重点是</p>
<div class="highlight"><pre><span></span><span class="x">byte[] formData = null;</span>
<span class="x">if (len &lt; CACHED_POST_LEN) {</span>
<span class="x">    if (postData == null) {</span>
<span class="x">        postData = new byte[CACHED_POST_LEN];</span>
<span class="x">    }</span>
<span class="x">    formData = postData;</span>
<span class="x">} else {</span>
<span class="x">    formData = new byte[len];</span>
<span class="x">}</span>
<span class="x">try {</span>
<span class="x">    if (readPostBody(formData, len) != len) {</span>
<span class="x">        parameters.setParseFailedReason(FailReason.REQUEST_BODY_INCOMPLETE);</span>
<span class="x">        return;</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>
<p>其中的formData就是上次正常请求的数据</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240916115520-7e76d352-73df-1.png"/></p>
<p>进入readPostBody方法</p>
<div class="highlight"><pre><span></span><span class="kd">protected</span> <span class="kt">int</span> <span class="nf">readPostBody</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">body</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">inputLen</span> <span class="o">=</span> <span class="n">getStream</span><span class="o">().</span><span class="na">read</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">inputLen</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">offset</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">inputLen</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">len</span><span class="o">;</span>

<span class="o">}</span>
</pre></div>
<p>其中inputLen就是真实的长度，然后这里就会一直死循环，超出时长，造成异常，但是没有抛出</p>
<p>最后又会来到parseRequestLine处理部分</p>
<p>所以这里读取的数据我们重点观察</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240916115528-82e41cf6-73df-1.png"/></p>
<p>少了一个n，应该是name=...这里是ame=...是因为我们输入和content长度不符合，然后把缓冲区设置为了1，导致读取的时候少读了一位</p>
<p>师傅的示意图</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240916115533-85ce8226-73df-1.png"/></p>
<p>len(leakage) = len(previous body) + len(actually length) + 1 -len(Content-Length)</p>
<h3 data-content="1" id="1f259f596a4ba4ec4b061069b45c3d92">最后</h3>
<p>想问师傅们一个问题，为什么我找不到在最后来到parseRequestLine方法的时候，byteBuffer的值就变成了不合理的值，是在哪里完成赋值的呢？具体赋值又是如何根据content长度去计算的呢？</p>
</div>
</div>