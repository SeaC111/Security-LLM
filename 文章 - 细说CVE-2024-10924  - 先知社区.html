<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<p>截至发稿日期 github上的都是fake poc</p>
<p>btw cve看多了就发现了很多看起来评分高实际上用起来 like shit 的漏洞 这也是为什么很多洞没有10分</p>
<h1 data-content="1" id="d94fdb56aec44708e82eac6deca28cdc">环境</h1>
<p><a href="https://wordpress.org/plugins/really-simple-ssl/really-simple-ssl.9.0.0.zip" target="_blank">https://wordpress.org/plugins/really-simple-ssl/really-simple-ssl.9.0.0.zip</a></p>
<h1 data-content="1" id="6a16e10d28603cfc7ea2a2d2e099ef5f">成因分析</h1>
<p>问题点出在<code>security/wordpress/two-fa/class-rsssl-two-factor-on-board-api.php:164</code></p>
<p>根据<a href="https://plugins.trac.wordpress.org/changeset/3188431/really-simple-ssl" target="_blank">https://plugins.trac.wordpress.org/changeset/3188431/really-simple-ssl</a>我们也可以发现，主要更改的是email部分</p>
<div class="highlight"><pre><span></span><span class="x">public function validate_email_setup(WP_REST_Request $request ): WP_REST_Response {</span>
<span class="x">        $parameters = new Rsssl_Request_Parameters( $request );</span>
<span class="x">        $user = $this-&gt;check_login_and_get_user( $parameters-&gt;user_id, $parameters-&gt;login_nonce );</span>
<span class="x">        // Check if the provider.</span>
<span class="x">        if ( 'email' !== $parameters-&gt;provider ) {</span>
<span class="x">            return new WP_REST_Response( array( 'error' =&gt; 'Invalid provider' ), 401 );</span>
<span class="x">        }</span>
<span class="x">        if ( !Rsssl_Two_Factor_Email::get_instance()-&gt;validate_token( $parameters-&gt;user_id, self::sanitize_token($parameters-&gt;token) ) ) {</span>
<span class="x">            // we reset all the settings.</span>
<span class="x">            Rsssl_Two_Factor_Email::set_user_status( $parameters-&gt;user_id, 'open' );</span>
<span class="x">            Rsssl_Two_Factor_Totp::set_user_status( $parameters-&gt;user_id, 'open' );</span>

<span class="x">            // we logout the user</span>
<span class="x">            wp_logout();</span>

<span class="x">            return new WP_REST_Response( array( 'error' =&gt;  __('Code was was invalid, try "Resend Code"', 'really-simple.ssl-pro') ), 401 );</span>
<span class="x">        }</span>

<span class="x">        Rsssl_Two_Factor_Email::set_user_status( $parameters-&gt;user_id, 'active' );</span>
<span class="x">        // Mark all other statuses as inactive.</span>
<span class="x">        self::set_other_providers_inactive( $parameters-&gt;user_id, 'email' );</span>

<span class="x">        return $this-&gt;authenticate_and_redirect( $parameters-&gt;user_id, $parameters-&gt;redirect_to );</span>
<span class="x">    }</span>
</pre></div>
<p>如上所言 validate_email_setup会进行一次check_login_and_get_user，但是注意check_login_and_get_user方法如下</p>
<div class="highlight"><pre><span></span><span class="x">private function check_login_and_get_user( int $user_id, string $login_nonce ) {</span>
<span class="x">        if ( ! Rsssl_Two_Fa_Authentication::verify_login_nonce( $user_id, $login_nonce ) ) {</span>
<span class="x">            return new WP_REST_Response( array( 'error' =&gt; 'Invalid login nonce' ), 403 );</span>
<span class="x">        }</span>

<span class="x">        /**</span>
<span class="x">         * Get the user by the user ID.</span>
<span class="x">         *</span>
<span class="x">         * @var WP_User $user</span>
<span class="x">         */</span>
<span class="x">        $user = get_user_by( 'id', $user_id );</span>
<span class="x">        return $user;</span>
<span class="x">    }</span>
</pre></div>
<p>如我们所见 <code>check_login_and_get_user</code> 验证user_id和login_nonce的关联正确性 而且并不直接退出执行流程</p>
<p>而类似的 <code>verify_2fa_code_totp</code> <code>verify_2fa_code_totp</code> <code>skip_onboarding</code> <code>方法虽然同样给出了authenticate_and_redirect</code> 或者没有在用户验证失败后同样没有推出流程 但是由于其进行调用<code>check_login_and_get_user</code>后使用了<code>$user-&gt;id</code> 而由于实际上<code>login_nonce</code>和<code>user_id</code>不匹配 导致未获取到用户 这将导致<code>authenticate_and_redirect</code>第一个参数为 null 所以这也就是为什么只能使用<code>validate_email_setup</code>方法 更具体的原因不再赘述 有兴趣可以翻阅源码</p>
<p>回到<code>validate_email_setup</code> 这步使用<code>check_login_and_get_user</code>验证了之后 即使是错误的 也并没有退出流程 也没用使用到其方法返回的$user 这就导致验证失效</p>
<h1 data-content="1" id="c8bff68bb57f01fa41b6eec44f2fd2d5">利用分析</h1>
<p>看到</p>
<pre><code>if ( !Rsssl_Two_Factor_Email::get_instance()-&gt;validate_token( $parameters-&gt;user_id, self::sanitize_token($parameters-&gt;token) ) ) {</code></pre>
<p>我们需要提供token 而搜索<code>validate_token</code>所在的class 可以看到token的生成来自于<code>security/wordpress/two-fa/class-rsssl-two-factor-email.php:102</code></p>
<div class="highlight"><pre><span></span><span class="x">public function generate_token( int $user_id ): string {</span>
<span class="x">        $token = self::get_code();</span>

<span class="x">        update_user_meta( $user_id, self::RSSSL_TOKEN_META_KEY_TIMESTAMP, time() );</span>
<span class="x">        update_user_meta( $user_id, self::RSSSL_TOKEN_META_KEY, wp_hash( $token ) );</span>

<span class="x">        return $token;</span>
<span class="x">    }</span>
</pre></div>
<p>其中<code>get_code</code>为生成一个8位数的数字 不再赘述</p>
<p>跟踪<code>generate_token</code>调用即可看到<code>resend_email_code</code>和<code>start_email_validation</code>对其进行了调用</p>
<p>选择<code>start_email_validation</code>跟踪 可以看到<code>set_profile_email</code>和<code>set_as_email</code>方法</p>
<p>搜索可以看到其路由分别为<code>save_default_method_email</code>和<code>save_default_method_email_profile</code></p>
<p>由此我们掌握了创建token的方法</p>
<p>其次搜索validate_email_setup的路由为<code>validate_email_setup</code></p>
<p>由此可以确定漏洞利用方式</p>
<ol>
<li>通过save_default_method_email创建一个token</li>
<li>通过validate_email_setup进行8位数字的token验证</li>
</ol>
<p>by the way 在另一个方面 可以看到 其使用了 <code>wp_hash( $token )</code> 这个函数使用md5+salt， 其salt来自于多个地方的fallback 但是基本上可以认为来自于wp-config.php的定义 如 NONCE_SALT</p>
<p>而<code>set_as_email</code>方法实际上会将其hash后的token返回到页面 因此如果存在wp-config.php泄漏的话可以将返回的token放在本地跑hash</p>
<h1 data-content="1" id="bf50bef411c2fd0258c3bb1dfc29be10">关于利用限制</h1>
<p>除了上面所述 我们还可以跟踪到一个代码 具体调用过程不再赘述 总之其存在一个token有效期 为15分钟</p>
<div class="highlight"><pre><span></span><span class="x">public function user_token_ttl( int $user_id ): int {</span>
<span class="x">        $token_ttl = 15 * MINUTE_IN_SECONDS;</span>

<span class="x">        /**</span>
<span class="x">         * Number of seconds the token is considered valid</span>
<span class="x">         * after the generation.</span>
<span class="x">         *</span>
<span class="x">         * @param integer $token_ttl Token time-to-live in seconds.</span>
<span class="x">         * @param integer $user_id User ID.</span>
<span class="x">         */</span>
<span class="x">        return (int) apply_filters( 'rsssl_two_factor_token_ttl', $token_ttl, $user_id );</span>
<span class="x">    }</span>
</pre></div>
<p>因此我们可以得到如下结论</p>
<ol>
<li>需要开启email作为2fa的手段</li>
<li>token要跑几千万遍 或者wp-config泄露后在本地跑</li>
<li>token需要在15分钟内跑完 否则需要重新生成</li>
</ol>
<p>这大概就是其没有评分10分的原因</p>
<h1 data-content="1" id="9a4e6bad203a87687ec11e0293d79e49">展望未来</h1>
<p>官方已经发布了最新版 可以直接更新<br/>
但顺带一提的是 鉴权但没有实现流程中止的代码不在少数 网络安全 我辈仍需努力</p>
</div>
</div>