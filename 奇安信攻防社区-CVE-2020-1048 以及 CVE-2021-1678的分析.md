Active Directory协议
------------------

默认情况下是不适用TLS,而是依赖于Windows身份验证

NTLM
----

![image-20210808122512774](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-94c55510166dd94d545e878f2f2d8cfcb0f2ca14.png)

```php
1、当客户端服务器向服务器请求身份验证，客户端会发送NTLM协商请求 

2、服务器创建一个nonce，并在挑战请求中发送它

3、客户端机器使用用户的密码对nonce进行签名

4、服务器并不知道如何验证用户的密码，因此通过NETLOGON通道，发送NTLM身份验证消息

5、DC通过验证用户名和密码进行是批准还是拒绝用户的身份验证
```

Kerberos认证
----------

![1616509589474](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-8d37b1c6bf51631b9b8fe501592880efde6aeffc.png)

```php
1. AS-REQ: 首先Client用自己的哈希值NTLM-hash对时间戳进行加密， 发送给AS,向AS请求TGT票据

2. AS-REP: 当AS收到Client发来的信息后，AS会先向域控AD请求，询问是否有此Client用户，如果有的话，就会取出该Client的NTLM hash，AS使用Client hash进行解密，如果结果正确就返回用krbtgt用户的NTLM hash加密的TGT票据，发给客户端，TGT里面包含PAC,PAC包含Client的sid，Client所在的组

3. TGS-REQ: Client凭借TGT票据向KDC发起针对特定服务的TGS-REQ请求

4. TGS-REP: TGS收到请求后，使用krbtgt用户的NTLM hash进行解密，如果结果正确，就返回用krbtgt用户的NTLM hash加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据)

5. AP-REQ: Client拿着TGS票据去服务端请求服务

6. AP-REP: 服务端使用自己的NTLM hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限
```

Kerberos 和 NTLM
---------------

![image-20210808122536516](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-1f13ab2bbce723afef5ac2394b7cd4e81d2f0cf7.png)

Kerberos提供了比NTLM更高的安全性

NTLM最大的问题是，它**允许应用程序进行NTLM中继**

NTLM中继
------

![image-20210808122637225](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-fdf00a55793ec709ad66c3d0890bdbe8a18d6174.png)

```php
1、客户端请求连接到服务器

2、服务器上的攻击者，想要使用来自客户端的计算机凭据，来攻击另一个目标，因此，他将Negotiate消息中继到服务器和受害者机器

3、受害者机器用随机数发起Challenge

4、这个NTLM Challenge被中继回客户端机器

5、客户端机器使用 用户密码对nonce进行签名

6、服务器中继该NTLM身份验证消息

7、攻击目标将通过NETLOGON通道对其进行验证

8、DC进行批准操作，因为它是用户的正确密码，攻击成功
```

进一步分析
-----

NTLM中继仅在服务器未在目标上强制执行加密登录时才有效

其实可以用过某个PRC接口(即任务调动程序)进行身份验证，并且它不会强制签署流量

因此使用经典的NTLM中继技术，可以将身份验证中继到服务器，然后发送一个未签名的数据包，使其运行任意的任务

那么这将有效的导致远程代码执行漏洞

允许这种攻击的原因 是因为**RPC处理安全性的方式**

RPC处理安全性的方式
-----------

![image-20210808122330697](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-78ab5ad48c85f933cf7dc2a1687ac8b8b12afadf.png)

RPC会话中的安全级别，是由身份验证级别决定

某些RPC服务需要数据包隐私

这意味着它需要， 对会话进行加密，而其他只需要数据包完整性，即签名

认证要求是，在逐个接囗的基础上确定的。

而注册API，要求调用设置个特殊的函数，来检查任意身份验证级别的交全要求

它并不依赖于SMB签名设置或其他安全性。当一个接囗允许一个数据包用于连接的身份验证级别时，那么它是容易受到NTLM中继的攻击

问题是这个接口是否有浅在的安全风险

虽然微软在 Windows中实现的大多数接口都受到保护

但在某些情况下，开发人员可能会忽略这一点

CVE-2020-1048
-------------

再看打印机漏洞

### 漏洞原理

利用访问检查的缺失，来实现在系统中写入任意文件

### 漏洞影响范围

Windows的许多最新版本，包括Windows Server 2008、2012、2016和2019以及Windows 7、8.1和10

### 漏洞实现

需要指定哪台打印机，打印机驱动程序，以及它与打印机通信的端口

### 打印机驱动

在MSDN文档描述中，早期系统要求只有具备SeLoadDriverPrivilege权限的用户才能安装打印驱动，但为了便于标准用户安装驱动，从Windows Vista开始，只要打印机驱动是已经存在的可立即使用的驱动，就不需要任何特权即可安装

当前这个漏洞实现了任何用户安装打印机驱动程序，从而实现打印

所以最简单的驱动程序是一个通用/文本驱动程序，它只是将输入传输到端口

### 打印机端口

在添加一个打印机时，需要设置打印机的端口。Windows支持多种类型的打印机端口：LPT1端口、USB端口、网络端口和文件等。

如果设置端口为文件，则意味着打印机将数据打印到指定文件，然后与打印机的连接，它也可以是一个文件

### 漏洞成因

用户可以调用，这个简单的打印机来打印到它想要的文件夹

是访问检查是从某个执行路径完成的，但它是在客户端运行的

因此，这个漏洞所有的实现本地权限的提升，非特权用户可以在其中写入文件

CVE-2021-1678
-------------

### 漏洞危害

该漏洞允许攻击者将NTLM身份验证会话中继到受攻击的计算机

并使用打印机后台处理程序MSRPC接口在受攻击的计算机上远程执行代码

### 漏洞利用流程

![img](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-b0707fca4afe0d7c7b3e6313c521c6e583597974.png)

```php
1、与攻击者控制的中继机器建立 NTLM 会话。

2、攻击者绑定到所需目标上的 IRemoteWinspool 接口并选择 RPC_C_AUTHN_LEVEL_CONNECT 的身份验证级别。

3、NTLM 身份验证由攻击者通过已建立的 RPC 通道进行中继。 

4、执行一系列类似于 PrinterDemon 漏洞利用流程的 RPC 命令： 
RpcAsyncInstallPrinterDriverFromPackage (Opnum 62) — 安装“通用/文本”打印机驱动程序
RpcAsyncOpenPrinter (Opnum 0)
RpcAsyncXcvData (Opnum 33) — 添加端口
RpcAsyncAddPrinter (Opnum 1) — 添加具有上述驱动程序的打印机
RpcAsyncStartDocPrinter(Opnum 10) — 开始一个新文档
RpcAsyncWritePrinter (Opnum 12) — 写入新文档
```

组合拳
---

CVE-2020-1048，这个漏洞是只要有足够的权限，依然可以写入任意文件

那么结合CVE-2021-1678

两个漏洞进行结合 打一波组合拳

我们的本地特权-非特权用户，但没有正式设置联系某个服务器的远程特权用户

无论请求是什么，我们都将使用NTLM中继将这个请求中继到另一台服务器

![image-20210808124511685](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-ce16635a2548975cf5d64fd5c659668ea0ec18bf.png)

```php
1、首先，我们有一个客户端机器的身份验证请求，该请求被传递到一个流氓服务器

2、现在我们使用攻击者创建一个与目标服务器的通道，并绑定到Print Spooler接口

3、我们中继身份验证

4、拿到一个NTLM Challenge

5、将NTLM Challenge中继到客户端机器

6、然后客户端向我们发送对NTLM Challenge的响应

7、我们将它转发回DC
```

所以现在它被验证了，现在它有一个经过身份验证的有效的会话

然后我们可以向该会话发送不加密的命令安装打印机驱动程序

然后我们进行安装打印机驱动，添加打印机端口， 然后写入任意文件

参考：

[https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-rpce/425a7c53-c33a-4868-8e5b-2a850d40dc73](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/425a7c53-c33a-4868-8e5b-2a850d40dc73)

<https://rastamouse.me/ntlm-relaying-via-cobalt-strike/>

<https://www.crowdstrike.com/blog/cve-2021-1678-printer-spooler-relay-security-advisory/>