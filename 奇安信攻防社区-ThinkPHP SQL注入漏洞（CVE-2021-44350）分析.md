0x01漏洞描述
========

顶想信息科技 ThinkPHP是中国顶想信息科技公司的一套基于PHP的、开源的、轻量级Web应用程序开发框架。

ThinkPHP 5.0.x ＜=5.1.22 存在SQL注入漏洞，该漏洞源于通过Builder.php中的parseOrder函数。

0x02影响版本
========

ThinkPHP 5.0.x ＜=5.1.22

0x03环境搭建
========

Test on ThinkPHP-5.0.5，其完整版的源码：<http://www.thinkphp.cn/donate/download/id/870.html>

PHPstorm + Xdebug配置
-------------------

具体配置过程不做详细说明，最后效果大概如下：

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-4df1b4fbe607c7567cb1b6cdda6ae4108911c866.png)

phpinfo页面中

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-d0f0114d95da8b202024e62e1301276bb7fa6aad.png)

数据库配置
-----

在框架源码中的`database.php`数据库配置文件中添加相关的数据库信息，这里以连接mysql默认已有的数据库为例

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-da90e4cb3ca4079d1465db94877850ff40828c24.png)

tp5源码配置
-------

由于是tp5框架问题，所以可以在`Index.php`访问页面中修改成以下代码

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-114a92f1441403c60e82619465662a378b5fa38f.png)

0x04漏洞分析
========

在`Index.php`文件中断点逐步跟进即可~  
访问页面在url传入以下参数及值

```php
?test[user^updatexml(1,concat(0x7,user(),0x7e),1)%23]=1
```

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-39b54b0562e3c6ff5625c67d7233a3455f3841fb.png)

先看到`input()`中对接收http请求服务在`Request.php`进行了简单的判断和处理，并且从中可得到我们所构造的恶意键值对

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-9aea895965370904072d908e921e21ca044c632d.png)

接着返回到`Index.php`文件的第二个断点，`helper.php`中的`db()`函数对数据库进行connect连接操作，接着到`Query.php`文件的`where()`函数，这边也是没有任何的问题

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-662ae061f9b03b1c9a8c5fb6511907fbb5bdd7e7.png)

紧接着来到`order()`函数中，可以看到我们的`$field`数据内容是直接存储到了`$this->options['order']`当中

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-f8c26ae8bb723165e02ff4314aaa58f612c6db9b.png)

接着调用最后的`find()`函数以在数据库做sql语句的执行，先是利用`parseExpress()`函数提取sql语句中的关键字等操作

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-a8a1f06d97766b1f4702b2db715043a523de0411.png)

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-91eba05dee494b5847e71a64be3cd2ddec243c29.png)

接着`Query.php`中的`$sql = $this->builder->select($options);`会调用`Builder.php`中的`Select()`函数生成Sql语句，关键在于该方法中对`$options`中的`order`键值对做了`parseOrder()`函数的过滤

```php
public function select($options = [])
{
$sql = str_replace(
['%TABLE%', '%DISTINCT%', '%FIELD%', '%JOIN%', '%WHERE%', '%GROUP%', '%HAVING%', '%ORDER%', '%LIMIT%', '%UNION%', '%LOCK%', '%COMMENT%', '%FORCE%'],
[
$this->parseTable($options['table'], $options),
$this->parseDistinct($options['distinct']),
$this->parseField($options['field'], $options),
$this->parseJoin($options['join'], $options),
$this->parseWhere($options['where'], $options),
$this->parseGroup($options['group']),
$this->parseHaving($options['having']),
$this->parseOrder($options['order'], $options),
$this->parseLimit($options['limit']),
$this->parseUnion($options['union']),
$this->parseLock($options['lock']),
$this->parseComment($options['comment']),
$this->parseForce($options['force']),
], $this->selectSql);
return $sql;
}
```

在`parseOrder()`函数中，将`$key`和`$options`参数传入`parseKey()`函数过滤`$key`值

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-dbd671a05a54d4d2925ac8c809e3af5dc13bcce7.png)

在`parseKey()`函数中未对key中做任何消除敏感字符的过滤、检测，即照常返回原来的key值

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-fac9af17a85bab2106aedc6ded74236a7b50a5a9.png)

所以在`parseOrder()`函数中将直接返回以下内容

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-75f079acb65401b6ad9b2d9d7fef12cf7e22c8f2.png)

将得到最终所要执行的sql语句

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-5d2fa87e8bf1dff1a6e9ce08c232f50fc91e8faa.png)

在事件回调代码块中对以上得到的sql语句，来到`Connection.php`中的`query()`函数进行sql语句的查询

```php
$result = $this->query($sql, $bind, $options['master'], $options['fetch_pdo']);
```

最后在此处触发了错误的sql注入

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-a21a482171baf2db617e16a506689d4f384fc616.png)

在此处将返回我们成功注入sql的报错信息

![](https://shs3.b.qianxin.com/attack_forum/2022/02/attach-8725f5d2cd9e4646f8e2a3d1ceaca42895a3fcf8.png)

调用链如下：

```php
helper#db --> 连接数据库
Query#where --> 匹配where关键字
Query#order --> 匹配order关键字
Query#find,Builer#select --> 生成sql查询语句
Builer#parseOrder --> 过滤$options中的order键值对
Mysql#parseKey --> 过滤order中的key值
Query#query,Connection#Query --> 执行sql语句
PDOException#getLastsql --> 返回报错信息
```

0x05总结一下
========

（仅个人理解）就是在键值对中的构造恶意sql语句到key即键中，接着在生成sql查询语句过程中未对order（包括其他关键字）中的key做敏感字符串的过滤，导致将key值内容拼接进sql语句中，达到sql注入的目的