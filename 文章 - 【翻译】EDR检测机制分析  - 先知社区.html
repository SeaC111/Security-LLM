<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<p>翻译：<a href="https://redops.at/blog/edr-analysis-leveraging-fake-dlls-guard-pages-and-veh-for-enhanced-detection" target="_blank">https://redops.at/blog/edr-analysis-leveraging-fake-dlls-guard-pages-and-veh-for-enhanced-detection</a></p>
<p>在这篇博客文章中，我想记录并分享我在EDR（端点检测与响应）调试和逆向工程领域的最新发现和经验。最近，我接触到了一个端点检测与响应（EDR）系统，由于其检测行为引起了我的兴趣。这个系统超越了常见的检测机制，如内联API挂钩、Windows事件跟踪和内核回调。在这篇文章中，我想讨论一个与EDR相关的、相当非传统但非常有趣的检测机制。</p>
<h4 data-content="1" id="307c4599410c25e09a1b5dc1f50638ea">0X00 前言</h4>
<hr/>
<p>本文尝试通过调试和逆向工程分析一个特定EDR（端点检测与响应）的特定功能或检测机制。我的主要目标不是深入了解逆向工程的每一个细节，而是开发对EDR新实施的检测机制工作原理的深入理解，探索这一机制的功能，并质疑其可能实施的原因。<br/>
此外，我认为重要的是要理解，每个商业EDR最终都是一个黑盒子。人们可以尝试通过静态和动态分析等不同方法来了解EDR的工作方式，但特别是其内部工作方式和逻辑大部分仍然是一个黑盒子。可以提出关于EDR内部结构和逻辑结构的假设，然后分析这些假设以验证它们。然而，获取关于其工作方式的完整清晰度和明确声明往往是困难的。</p>
<h4 data-content="1" id="5501427dc1f4886f3808334d755de00d">0X01 检测机制</h4>
<hr/>
<p>EDR系统（端点检测与响应）根据阶段使用不同的机制来检测恶意软件。在静态阶段，通常使用扫描器来检查文件的已知哈希值、签名和特定字节序列。如果攻击者成功绕过这种静态检测，许多EDR会采用沙箱技术。这涉及到在虚拟化环境中执行潜在可疑文件以分析其行为。此外，EDR实施了如用户模式挂钩（例如内联API挂钩或IAT挂钩）、反恶意软件扫描接口（AMSI）、Windows事件跟踪以及威胁情报和内核回调等方法，用于基于行为的检测。<br/>
在我之前的一些文章中，我已经多次提到了一些EDR使用的内联API挂钩的概念，这些EDR通过这种方式主动干预Windows API的代码执行和参数。有关详细信息，请参阅我的最后一篇博客文章<a href="https://redops.at/blog/syscalls-via-vectored-exception-handling" target="_blank" title="《通过向量异常处理的系统调用》">《通过向量异常处理的系统调用》</a>。</p>
<h5 data-content="1" id="b578374ac381d7aacd76fabcb96585b3">非传统检测方法</h5>
<p>在这篇文章中，我想讨论一个与EDR相关的、相当非传统但非常有趣的检测机制，该机制基于对进程环境块（PEB）的修改、使用假DLL和保护页以及使用向量异常处理（VEH）的组合。</p>
<h5 data-content="1" id="00cfa6d639957d404cd3d96cede9c665">Fake DLL技术</h5>
<p>在Windows中初始化进程时，需要的DLL会被加载到虚拟内存中。这是按照进程的依赖和需求的特定顺序完成的。对于像<code>ntdll.dll</code>和<code>kernel32.dll</code>这样的系统级DLL，操作系统在进程的虚拟内存中放置引用（指针）。这些指针指向DLL在共享内存中的实际物理位置。<br/>
DLL加载的顺序由Process Environment Block（PEB）中的<code>PEB_LDR_DATA结构内的双向链表InLoadOrderModuleList</code>决定。其中，<code>ntdll.dll</code>和<code>kernel32.dll</code>作为每个Windows进程的关键组成部分，是必不可少的，总是会被加载。在检查装有待研究EDR的系统上的活动进程（例如cmd.exe）时，有一个特别的观察。我们使用Process Hacker工具来更详细地分析活动进程cmd.exe，特别是我们关注<code>模块标签页</code>，以检查在cmd.exe中加载的模块。初看之下，<code>kernel32.dll</code>和<code>ntdll.dll</code>似乎被加载了两次。但仔细观察发现，这些看似重复的DLL的拼写有所不同，因为其中一个版本是用Leetspeak写的。使用Process Hacker仔细检查这些模拟DLL版本时，发现模拟版本的文件大小与原始DLL完全相同。另一个显著的特点是，模拟版本缺少模块描述。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616104211-0870dd1c-2b8a-1.png"/><br/>
尝试使用Process Hacker更仔细地检查这些所谓的仿制品不会产生任何结果。它们无法被分析，且相应文件的镜像在硬盘上找不到（错误信息：无法加载PE文件：未找到对象名称）。显然，这些仿制品是相应DLL的一种假冒版本，因此我们将其称为"Fake DLL"。使用Process Hacker仔细查看<code>ntdll.dll</code>上下文中的Fake DLL时，发现它实际上是<code>ntdll.dll</code>的手动映射版本，但名称以<code>Leetspeak</code>形式更改。另一个有趣的特征在于仔细检查内存保护时显现：以RX（读-执行）分配的内存区域额外配备了一个保护页。我们记下这个细节，并稍后更详细地探讨它的含义。<br/>
但我们现在可以说的是，"Fake DLL"并不是一个可以在磁盘上找到的真正独立的DLL，而是<code>ntdll.dll</code>的手动映射版本，只是手动重命名为类似<code>ntdll.dll</code>的名称。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616104233-153a0e2e-2b8a-1.png"/></p>
<h4 data-content="1" id="d51f80cf89684252837fd5be27b29cc8">0X02 P3B蕴含的风险</h4>
<hr/>
<p>为了更好地理解假DLL在待分析EDR系统上下文中的角色，我们将注意力转向一个安装了EDR的系统上一个活动进程（例如cmd.exe）的进程环境块（PEB）。</p>
<blockquote>
<p>PEB是每个Windows进程中的一个关键存储结构，负责管理进程特定的数据，如程序基地址、堆、环境变量和命令行信息。它的结构包含许多字段和指针，特别值得注意的是Ldr结构，它负责管理加载的模块，特别是DLL。PEB对于每个进程都是唯一的，它在进程管理和DLL加载机制中扮演着关键角色。它为进程提供了必要的信息和资源，以便高效地执行和管理。</p>
</blockquote>
<p>然而，全面讨论PEB将超出本文的范围。对于希望深入了解的人，我建议深入研究Windows内部机制。但我们的主要目标是了解EDR如何使用假DLL。为了调查假DLL何时被映射到内存中，我们使用WinDbg。在我们附加到一个活动的cmd.exe进程后，我们尝试访问PEB中包含的<code>双向链表InLoadOrderModuleList</code>。这一步使我们能够分析模块在内存中的加载时间和顺序，包括识别Fake DLL。<br/>
第一步是使用WinDbg中的<code>!peb命令</code>访问cmd.exe的PEB。如下图所示，<code>InMemoryOrderModuleList</code>中的第二个位置是<code>ntdll.dll</code>的假版本，第三个位置是<code>kernel32.dll</code>的假版本。这证实了这些已经成功地被映射到进程的内存中。值得一提的是，<code>InMemoryOrderModuleList</code>与<code>InLoadOrderModuleList</code>之间的区别在于，<code>InMemoryOrderModuleList</code>按照模块在进程的虚拟内存中的位置列出模块。而<code>InLoadOrderModuleList</code>则指示DLL的加载顺序。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616104535-81ef6afa-2b8a-1.png"/><br/>
为了验证这一观察，我们想要访问Ldr结构中的<code>InLoadOrderModuleList</code>，并检查位于第二和第三位置的模块。首先，需要确定Ldr的地址（在这个例子中为<code>00007ffa61ebc4c0</code>）。然后，在WinDbg中使用命令<code>dt nt!_PEB_LDR_DATA 00007ffa61ebc4c0</code>来访问<code>PEB_LDR_DATA结构</code>。下图展示了对<code>PEB_LDR_DATA结构</code>的访问。从基地址开始，偏移量为<code>0x10</code>的位置是<code>InLoadOrderModuleList</code>条目，它清楚地告诉我们，在进程初始化期间，假的<code>ntdll.dll</code>是否真的被加载在第二位置，假的<code>kernel32.dll</code>被加载在第三位置。<br/>
通过这种方法，我们能够深入了解EDR如何操纵进程加载的DLLs，以及它如何通过这种方式增强其检测能力。这种对假DLL的使用，尤其是在它们被映射到进程的内存中时，显示了EDR系统采取的一种非常特殊和复杂的方法来监视和分析潜在的恶意行为。通过深入了解这些机制，安全研究人员可以更好地理解EDR系统的工作原理，并可能发现新的方法来提高系统的安全性或发现潜在的漏洞。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616104830-ea4761d4-2b8a-1.png"/><br/>
在下一步中，我们通过<code>InLoadOrderModuleList</code>（在本例中为）的起始地址访问<code>0x000001d5eb302650</code>此列表中的第一个模块。这是通过WinDbg中的命令完成的<code>dt nt!_LDR_DATA_TABLE_ENTRY 0x000001d5eb302650</code>。下图显示第一个模块cmd.exe是图像本身。此结果是预期的，因为执行进程的映像必须始终按模块顺序排在第一位。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616105519-de2ab86e-2b8b-1.png"/><br/>
要访问模块顺序中的第二个模块，我们再次在WinDbg中使用前面的命令，但将地址更新为的起始地址<code>InLoadOrderLinks</code>，在本例中<code>0x000001d5eb313d10</code>为运行此命令后的下图显示，模拟版本<code>ntdll.dll</code>实际上已作为订单中的第二个模块加载。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616105527-e2abbcda-2b8b-1.png"/><br/>
为了还检查模块加载顺序中的第三个模块，我们在WinDbg中重复上一步，但将地址相应地更新为<code>InLoadOrderLinks</code>第三个模块的起始地址（在本例中为<code>0x000001d5eb317c20</code>）。下图证实了我们之前的发现：假的<code>kernel32.dll</code>被加载为列表中的第三个模块。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616105825-4d05f910-2b8c-1.png"/><br/>
为了完成我们的分析，我们在WinDbg中重复该步骤两次，以确定其他模块在加载顺序中的位置。结果图显示，按模块加载顺序，真实的<code>ntdll.dll</code>为第四，真实的为第五。<code>kernel32.dll</code>这些信息对于以后来说非常重要。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616105902-6299eee4-2b8c-1.png"/><br/>
另外，需要注意的是，它还<code>InLoadOrderModuleList</code>用于确定EDR的<code>hooking DLL</code>被加载到哪里。在这种情况下，在<code>kernelbase.dll</code>加载第六个模块之后，在进程初始化期间将<code>Hooking DLL</code>作为第七个模块加载。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616105935-76b11e70-2b8c-1.png"/><br/>
如果使用WinDbg在未安装EDR系统的端点或具有替代EDR系统的端点上执行相同的分析，则在模块<code>InLoadOrderModuleList</code>加载顺序方面会出现明显不同的情况。分析结果表明，这些场景中不存在Fake DLL。还可以清楚地看到，<code>ntdll.dll</code>像往常一样，它们被加载<code>kernel32.dll</code>到模块列表中的第二和第三位。这种直接比较强调了最初检查的EDR系统的独特性，该系统通过使用Fake DLL和不同的模块加载顺序而与标准配置不同。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616110248-e9869416-2b8c-1.png"/><br/>
我们的分析结果以及与WinDbg的比较清楚地表明，进程环境块 (PEB)，或更具体地说，<code>InLoadOrderModuleList</code>进程（此处使用示例cmd.exe）在具有特定EDR系统的端点上进行了专门修改。</p>
<h4 data-content="1" id="e7a056465a4a0ddb2121b72a2a1a2509">0X03 保护页</h4>
<hr/>
<p>通过操纵PEB中的<code>InLoadOrderModuleList</code>，EDR确保在用户模式下初始化进程时，假的<code>ntdll.dll</code>和<code>kernel32.dll</code>版本被加载在第二和第三位置，然后真正的<code>ntdll.dll</code>和<code>kernel32.dll</code>跟随在第四和第五位置。但EDR进行这种操纵的目的是什么呢？<br/>
为了回答这个问题，让我们再次查看<code>ntdll.dll</code>和<code>kernel32.dll</code>的损坏版本。正如我们已经确定的，这些是原始DLL的版本，它们被手动映射到内存中，并在内存中由一个作为RX（读-执行）提交的保护页补充。根据微软文档，保护页可以触发一个<code>STATUS_GUARD_PAGE_VIOLATION</code>（<code>0x80000001</code>）异常。<br/>
这些观察表明，使用假DLL和保护页操纵进程环境块（PEB）很可能是用来激活EDR注册的向量异常处理程序（VEH）。对EDR的<code>x64 Hooking DLL</code>的仔细观察支持了这一理论：实现VEH所需的<code>Windows API AddVectoredExceptionHandler</code>和<code>RemoveVectoredExceptionHandler</code>是从<code>kernel32.dll</code>导入的。如果EDR确实注册了一个VEH，这意味着当通过保护页抛出异常时，EDR通过VEH而不是将异常传递给结构化异常处理程序（SEH）来控制程序流。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616110548-54d80cfe-2b8d-1.png"/><br/>
从另一个角度来看，在EDR的假DLL中保护页被触发后，异常<code>STATUS_GUARD_PAGE_VIOLATION</code>(<code>0x80000001</code>)必须由向量异常处理程序或结构化异常处理程序处理。考虑到EDR所需的努力，将其传递给SEH似乎不太可能，而将其传递给特别注册的VEH则显得更加合理和可行。这意味着EDR可以在异常被触发后积极介入程序的剩余流程，并在必要时阻止恶意软件。最终，这导致应用程序流程的重定向，可以被描述为挂钩。更具体地说，正如本文所描述的，是保护页挂钩或页面保护挂钩。<br/>
以下代码展示了如何结合向量异常处理在C语言中实现页面保护挂钩。重要的是要强调，这段代码只是一个示例和基本框架，并不包含EDR响应异常的具体逻辑。然而，可以想象，EDR在触发后可以恢复相应Fake DLL中的保护页，以便能够继续使用保护页进行监控。</p>
<div class="highlight"><pre><span></span><span class="err">#</span><span class="n">include</span> <span class="p">&lt;</span><span class="n">windows</span><span class="p">.</span><span class="n">h</span><span class="p">&gt;</span>
<span class="err">#</span><span class="n">include</span> <span class="p">&lt;</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="p">&gt;</span>

<span class="c1">// Vectored Exception Handler function</span>
<span class="c1">// This function is called when an exception occurs, such as a guard page violation</span>
<span class="n">LONG</span> <span class="n">CALLBACK</span> <span class="nf">GuardPageExceptionHandler</span><span class="p">(</span><span class="n">PEXCEPTION_POINTERS</span> <span class="n">pExceptionInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Check if the exception is a guard page violation</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pExceptionInfo</span><span class="p">-&gt;</span><span class="n">ExceptionRecord</span><span class="p">-&gt;</span><span class="n">ExceptionCode</span> <span class="p">==</span> <span class="n">STATUS_GUARD_PAGE_VIOLATION</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Guard Page Access Detected!\n"</span><span class="p">);</span>
        <span class="c1">// Here you can add logic to log the violation, analyze the access pattern,</span>
        <span class="c1">// or take any other appropriate action based on your EDR's requirements.</span>

        <span class="c1">// Optional: Restore the guard page here if you want continuous monitoring</span>

        <span class="c1">// Continue execution after handling the exception</span>
        <span class="k">return</span> <span class="n">EXCEPTION_CONTINUE_EXECUTION</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// If it's not a guard page violation, continue searching for other handlers</span>
    <span class="k">return</span> <span class="n">EXCEPTION_CONTINUE_SEARCH</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Set up a sensitive area of memory to monitor</span>
    <span class="c1">// This could represent a critical section of memory you want to protect</span>
    <span class="n">SYSTEM_INFO</span> <span class="n">si</span><span class="p">;</span>
    <span class="n">GetSystemInfo</span><span class="p">(&amp;</span><span class="n">si</span><span class="p">);</span> <span class="c1">// Get system information, including page size</span>
    <span class="n">LPVOID</span> <span class="n">pMemory</span> <span class="p">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">si</span><span class="p">.</span><span class="n">dwPageSize</span><span class="p">,</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pMemory</span> <span class="p">==</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Memory allocation failed\n"</span><span class="p">);</span>
        <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Protect the sensitive memory with a guard page</span>
    <span class="c1">// Any access to this page will trigger the guard page violation</span>
    <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">VirtualProtect</span><span class="p">(</span><span class="n">pMemory</span><span class="p">,</span> <span class="n">si</span><span class="p">.</span><span class="n">dwPageSize</span><span class="p">,</span> <span class="n">PAGE_GUARD</span> <span class="p">|</span> <span class="n">PAGE_READWRITE</span><span class="p">,</span> <span class="p">&amp;</span><span class="n">oldProtect</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to set guard page\n"</span><span class="p">);</span>
        <span class="n">VirtualFree</span><span class="p">(</span><span class="n">pMemory</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span> <span class="c1">// Clean up if setting the guard page fails</span>
        <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Register the Vectored Exception Handler</span>
    <span class="c1">// This handler will be invoked for exceptions, including guard page violations</span>
    <span class="n">PVOID</span> <span class="n">handler</span> <span class="p">=</span> <span class="n">AddVectoredExceptionHandler</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">GuardPageExceptionHandler</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="p">==</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to add Vectored Exception Handler\n"</span><span class="p">);</span>
        <span class="n">VirtualFree</span><span class="p">(</span><span class="n">pMemory</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span> <span class="c1">// Clean up if handler registration fails</span>
        <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Your application logic goes here</span>
    <span class="c1">// This is where you would implement the rest of your EDR's functionality</span>
    <span class="c1">// ...</span>

    <span class="c1">// Clean up before exiting the application</span>
    <span class="c1">// This includes unregistering the exception handler and freeing allocated memory</span>
    <span class="n">RemoveVectoredExceptionHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="n">VirtualFree</span><span class="p">(</span><span class="n">pMemory</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span>

    <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>同样有趣的是，<code>Windows API AddVectoredExceptionHandler</code>与<code>API LdrEnumerateLoadedModules</code>、<code>ntdll.dll</code>以及术语PEBTrap一起出现在挂钩DLL中。这可能表明了PEB的修改、Fake DLLs、保护页和向量异常处理程序之间的交互。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616111035-00008f84-2b8e-1.png"/><br/>
为了更好地理解EDR的向量异常处理程序（VEH）在<code>STATUS_GUARD_PAGE_VIOLATION</code>（<code>0x80000001</code>）下被激活的条件，仔细查看挂钩DLL提供了有趣的见解。看来，在这个DLL中有一个特殊的比较操作，用于检查在假<code>ntdll.dll</code>中触发保护页后调用原生API时是否发生了代码为<code>0x80000001</code>的相应异常。具体来说，如果抛出值为<code>0x80000001</code>的异常，EDR的向量异常处理程序将变为激活状态（并且如果必要的话可能终止进程）。然而，如果在调用相应的原生API，例如<code>NtProtectVirtualMemory</code>后，没有跟随值为<code>0x80000001</code>的异常，则允许继续执行原生API。然而，这目前是一个假设，并非一个确定的声明。但是，值得注意的是，这种比较在挂钩DLL中针对大约25个原生API进行，包括<code>NtAllocateVirtualMemory</code>、<code>NtWriteVirtualMemory</code>、<code>NtProtectVirtualMemory</code>等，这些API在恶意软件执行的上下文中经常使用。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616111238-49173f88-2b8e-1.png"/></p>
<h4 data-content="1" id="702f9d8939b8cf2f49a1a31a41c120ae">0X04 DLL Base vs. Original Base</h4>
<hr/>
<p>从恶意软件开发者的角度来看，主要问题在于恶意软件依赖于从PEB或者<code>ntdll.dll</code>或<code>kernel32.dll</code>动态检索信息。具体的一个例子是使用shellcode加载器或直接或间接使用系统调用的shellcode，例如，不在代码中锚定系统服务号（SSNs）。相反，它尝试在运行时通过结合PEB遍历和导出地址表（EAT）解析在<code>ntdll.dll</code>中动态获取这些SSN为了通过PEB遍历访问<code>ntdll.dll</code>的基地址，通常使用偏移量<code>0x30</code>的DLLBase。然而，在我们的EDR上下文中，这导致你最终进入了ntdll.dll的假版本的内存，从而通过页面保护挂钩触发EDR的向量异常处理程序。<br/>
为了验证这个声明的准确性，我们计划使用以下C代码进行一个实验。我们的目标是使用PEB遍历并通过偏移量<code>0x30</code>的DllBase访问<code>ntdll.dll</code>的基地址，以确定并输出其内存地址。然后我们想要将这个地址与cmd.exe内存中真实和假的<code>ntdll.dll</code>的内存地址进行比较。</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">UINT_PTR</span> <span class="nf">NtdllDllBase</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Read the PEB Offset from the GS Register</span>
    <span class="n">UINT_PTR</span> <span class="n">pebAddress</span> <span class="o">=</span> <span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="c1">// Access the PEB_LDR_DATA field within PEB</span>
    <span class="n">UINT_PTR</span> <span class="n">ldr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">pebAddress</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">);</span>
    <span class="c1">// Access the first entry in the InInitializationOrderModuleList</span>
    <span class="n">UINT_PTR</span> <span class="n">inInitOrderModuleList</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">ldr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="c1">// Traverse to the second module in the list (typically ntdll.dll)</span>
    <span class="n">UINT_PTR</span> <span class="n">secondModule</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">inInitOrderModuleList</span><span class="p">);</span>
    <span class="c1">// Uncomment the following line to advance to the third module</span>
    <span class="c1">// secondModule = *(UINT_PTR*)(secondModule);</span>

    <span class="c1">// Access the base address of the module by using DLL Base</span>
    <span class="n">UINT_PTR</span> <span class="n">baseAddress</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">secondModule</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">baseAddress</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">UINT_PTR</span> <span class="n">ntdllBase</span> <span class="o">=</span> <span class="n">NtdllDllBase</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Base address (offset 0x30) of the loaded ntdll.dll: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ntdllBase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Press any key to exit..."</span><span class="p">);</span>

    <span class="n">getchar</span><span class="p">();</span> <span class="c1">// wait for keypress</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>下图显示，使用<code>0x30 DllBase偏移量</code>找到的基地址与内存中的真实<code>ntdll.dll</code>不匹配。然而，如果你检查EDR系统实现的假<code>ntdll.dll</code>，你会看到内存地址是匹配的。这意味着，在进行PEB遍历时，使用<code>0x30 DllBase偏移量</code>访问的内存区域不是真实的<code>ntdll.dll</code>，而是EDR系统用于页面保护挂钩的假<code>ntdll.dll</code>。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616112105-7749ae62-2b8f-1.png"/><br/>
在我们实验的下一步中，我们想要调整我们的C代码，不仅通过<code>偏移量0x30</code>（<code>DllBase</code>）访问并输出<code>ntdll.dll</code>的基地址，还要通过<code>偏移量0xF8</code>（<code>OriginalBase</code>）确定并输出同一个DLL的基地址。<code>OriginalBase</code>提供了一种访问<code>InLoadOrderModuleList</code>中模块基地址的替代方法。通过这样扩展我们的代码，我们可以将找到的两个地址与内存中真实和假<code>ntdll.dll</code>的地址进行比较。</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">UINT_PTR</span> <span class="nf">NtdllDllBase</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Read the PEB Offset from the GS Register</span>
    <span class="n">UINT_PTR</span> <span class="n">pebAddress</span> <span class="o">=</span> <span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="c1">// Access the PEB_LDR_DATA field within PEB</span>
    <span class="n">UINT_PTR</span> <span class="n">ldr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">pebAddress</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">);</span>
    <span class="c1">// Access the first entry in the InInitializationOrderModuleList</span>
    <span class="n">UINT_PTR</span> <span class="n">inInitOrderModuleList</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">ldr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="c1">// Traverse to the second module in the list (typically ntdll.dll)</span>
    <span class="n">UINT_PTR</span> <span class="n">secondModule</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">inInitOrderModuleList</span><span class="p">);</span>
    <span class="c1">// Uncomment the following line to advance to the third module</span>
    <span class="c1">// secondModule = *(UINT_PTR*)(secondModule);</span>

    <span class="c1">// Access the base address of the module</span>
    <span class="n">UINT_PTR</span> <span class="n">baseAddress</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">secondModule</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">baseAddress</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">UINT_PTR</span> <span class="nf">NtdllOriginalDLLBase</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Read the PEB Offset from the GS Register</span>
    <span class="n">UINT_PTR</span> <span class="n">pebAddress</span> <span class="o">=</span> <span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="c1">// Access the PEB_LDR_DATA field within PEB</span>
    <span class="n">UINT_PTR</span> <span class="n">ldr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">pebAddress</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">);</span>
    <span class="c1">// Access the first entry in the InInitializationOrderModuleList</span>
    <span class="n">UINT_PTR</span> <span class="n">inInitOrderModuleList</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">ldr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="c1">// Traverse to the second module in the list (typically ntdll.dll)</span>
    <span class="n">UINT_PTR</span> <span class="n">secondModule</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">inInitOrderModuleList</span><span class="p">);</span>
    <span class="c1">// Uncomment the following line to advance to the third module</span>
    <span class="c1">// secondModule = *(UINT_PTR*)(secondModule);</span>

    <span class="c1">// Access the base address of the module by using Original Base</span>
    <span class="n">UINT_PTR</span> <span class="n">baseAddress</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">secondModule</span> <span class="o">+</span> <span class="mh">0xF8</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">baseAddress</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">UINT_PTR</span> <span class="n">ntdllBase</span> <span class="o">=</span> <span class="n">NtdllDllBase</span><span class="p">();</span>
    <span class="n">UINT_PTR</span> <span class="n">ntdllOriginalBase</span> <span class="o">=</span> <span class="n">NtdllOriginalDLLBase</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Base address (offset 0x30) of the loaded ntdll.dll: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ntdllBase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Original base address (offset 0xF8) of the loaded ntdll.dll: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">NtdllOriginalDLLBase</span><span class="p">());</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Press any key to exit..."</span><span class="p">);</span>

    <span class="n">getchar</span><span class="p">();</span> <span class="c1">// wait for keypress</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>在安装了EDR的终端上运行我们扩展的代码后，下图显示了一个揭示性的结果：使用<code>偏移量0xF8</code>的<code>OriginalBase</code>找到的内存地址对应于真实的<code>ntdll.dll</code>的地址。这证实了使用<code>偏移量0x30</code>（<code>DllBase</code>）进行PEB遍历将会带我们进入EDR插入的假<code>ntdll.dll</code>的内存区域。然而，如果我们选<code>择偏移量0xF8</code>的<code>OriginalBase</code>，我们将会进入真实的<code>ntdll.dll</code>的内存区域。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616112426-ef257d6c-2b8f-1.png"/></p>
<h4 data-content="1" id="15beee31ab29c5bd9a7ec969af7b8dcc">0X05 向量异常处理</h4>
<hr/>
<p>在我们更仔细地查看下一节中要分析的检测链的内部逻辑之前，我想更详细地探讨我们将要分析的EDR在特定进程上下文中使用向量异常处理的理论是如何得到支持的。我们已经看到，EDR从<code>kernel32.dll</code>导入了<code>AddVectoredExceptionHandler</code>和<code>RemoveVectoredExceptionHandler</code>函数。然而，为了证明一个进程正在使用向量异常处理程序或被一个注册的向量异常处理程序监控，让我们更仔细地查看进程环境块（PEB）。使用Windbg进行调试，我们想在PEB中查看CrossProcessFlags（对于64位，偏移量为0x50）的值。根据Olllie Whitehouse的文章和Geoff Chapell的文档，CrossProcessFlags条目可以告诉我们一个进程是否正在使用VEH。换句话说，如果CrossProcessFlags条目的十进制值为4，则该进程正在使用VEH。另一方面，如果CrossProcessFlags条目的十进制值为0，则该进程没有使用VEH。<br/>
这可以在下图中清楚地看到：在安装了要分析的EDR的虚拟机上启动了<code>notepad.exe</code>，并在PEB中使用Windbg检查了CrossProcessFlags条目的值。可以清楚地看到，<code>CrossProcessFlags</code>的十进制值为4（十六进制为<code>0x00000004</code>），因此正在使用VEH，或者假定是EDR的VEH（但这将在稍后更详细地检查）。然而，在图的右侧比较中，我们看到同一个进程在没有安装EDR的虚拟机上。如预期，这里的<code>CrossProcessFlags</code>条目为0，即notepad.exe进程没有使用VEH。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616112628-37f4cea8-2b90-1.png"/><br/>
因此，检查PEB中的<code>CrossProcessFlags</code>条目可以告诉我们一个进程是否正在使用向量异常处理，但同时了解哪个模块负责注册VEH也是很有趣的。换句话说，我们想要证明VEH是由EDR注册的。为了提供这个证据，我们可以使用x64dbg这样的调试器加载图像<code>notepad.exe</code>，并在原生<code>API RtlAddVectoredExceptionHandler</code>上设置一个断点。当断点触发时，我们查看调用堆栈并检查<code>RtlAddVectoredExceptionHandler</code>函数是从哪个地址或模块调用的。换句话说，如果VEH的注册是由EDR完成的，那么在调用<code>RtlAddVectoredExceptionHandler</code>之前的调用堆栈上的地址预期将是与EDR关联的地址。<br/>
下图强调了这一期望；可以看到，在<code>RtlAddVectoredExceptionHandler</code>的上下文中断点被触发后，堆栈帧之前是在EDR的用户模式挂钩DLL的上下文中调用的。这表明<code>RtlAddVectoredExceptionHandler</code>的函数调用是由EDR用户模式挂钩DLL发起的。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616112711-51af4b98-2b90-1.png"/><br/>
这些调查使我们能够使用PEB中的CrossProcessFlags条目检查一个进程是否正在使用VEH，并且还能证明调用原生函数<code>RtlAddVectoredExceptionHandler</code>（注册VEH所需）是由EDR用户模式挂钩DLL发起的。</p>
<h4 data-content="1" id="e695a6d884baed6d3988a983a38f4a06">0X06</h4>
<hr/>
<p>在我们总结和探讨可能的解决方法之前，让我们尝试更好地理解EDR如何检查在假DLL的上下文中是否触发了GUARD_PAGE标志。正如我们已经知道的，假DLL并不是真正的DLL，它们只是手动映射的版本，例如在ntdll.dll的上下文中。然而，EDR仍然需要一个内存中的部分来处理逻辑或检查在假DLL的上下文中何时触发了GUARD_PAGE。通过查看内存中的EDR模块，我们可以识别EDR用于内联挂钩部分的DLL或模块。在这个EDR的上下文中，这是EDR在用户模式下的进程内存中使用的唯一真正的DLL，除了假DLL，所以我们想更仔细地查看EDR的挂钩DLL，看看我们是否可以在我们对假DLL等的研究中找到一些重要的联系。<br/>
我想找出EDR内部的逻辑部分在哪里，以检查异常是否与<code>STATUS_GUARD_PAGE_VIOLATION</code>或更具体地与相关异常代码<code>0x80000001</code>有关。所以我有了一个简单的想法，使用x64dbg。我们打开任何应用程序，如notepad.exe或cmd.exe，用x64dbg附加到它，并在第一步中搜索挂钩DLL的基地址的内存映射。第二步，我们创建一个搜索模式，可以用来尝试识别针对值<code>0x80000001</code>的比较操作。换句话说，我们在挂钩DLL内部寻找针对<code>STATUS_GUARD_PAGE_VIOLATION</code>上下文中的异常代码的比较操作。所以我们想搜索模式<code>cmp eax, 80000001h</code>，基于小端我们需要将我们的模式转换为<code>3D 01 00 00 80</code>。这是我们的搜索模式，使用x64dbg模式搜索后，我们能够在挂钩DLL的内存中观察到针对<code>80000001h</code>的多个比较操作。我认为下图是一个合理的指标，表明EDR检查是否在假DLL的上下文中触发了<code>STATUS_GUARD_PAGE_VIOLATION 0x80000001</code>的逻辑放置在EDR的挂钩DLL内部，然后根据情况在挂钩DLL内部采取进一步的步骤。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616112732-5df9d2e2-2b90-1.png"/><br/>
上图显示，基于比较操作<code>cmp eax, 80000001h</code>，如果寄存器eax的值不等于<code>80000001h</code>，则调用函数<code>7FFE77F5AE51</code>。否则，如果eax的值为<code>80000001h</code>，则调用函数<code>7FFE77F56230</code>。换句话说，如果假DLL之一的内存中的<code>GUARD_PAGE标志</code>被触发，将会调用函数<code>7FFE77F56230</code>。</p>
<h4 data-content="1" id="da3a8b57a8c7b05076638fa8132bf0a3">0X07 总结</h4>
<hr/>
<p>在我们探讨潜在的规避技术之前，让我们简要总结一下对EDR系统的分析。我们的调查发现，EDR通过部署假DLL，有针对性地修改了进程环境块（PEB）内的<code>InLoadOrderModuleList</code>。值得注意的是，这些假DLL并不是独立的实体，而是原始DLL（如<code>ntdll.dll</code>）的手动映射版本。这些假DLL的一个关键特点是它们的RX（读-执行）提交内存区域配备了保护页。当访问这个内存区域（读取或执行）时，保护页会抛出<code>STATUS_GUARD_PAGE_VIOLATION</code>（<code>0x80000001</code>）异常，这也被称为页面保护挂钩。这个异常随后激活了EDR的向量异常处理程序（VEH），允许EDR积极影响应用程序的执行流程。我们还能够识别EDR的挂钩DLL中用于检查是否抛出<code>STATUS_GUARD_PAGE_VIOLATION</code>（<code>0x80000001</code>）异常的比较操作。然而，EDR的VEH被激活后采取的确切行动在这一阶段仍不清楚，需要进一步检查EDR系统。<br/>
总之，这种技术为EDR提供了监控和潜在地缓解恶意活动的能力，通过控制（潜在恶意的）应用程序的执行流程。</p>
<h5 data-content="1" id="6842bcd25e3f9182d201b2943bc81069">可能的规避策略</h5>
<p>最后，我们考虑一些可能的规避策略（在这个上下文中，规避被定义为未被阻止和检测到的活动），在PEB遍历的上下文中，例如，为了动态查询系统服务号（SSNs）以执行直接或间接的系统调用。</p>
<h5 data-content="1" id="21d7845e9b81f01fddc6f03538dfd320">偏移OriginalBase</h5>
<p>正如我们在分析中发现的，当在PEB遍历期间使用<code>偏移量0x30</code>（<code>DllBase</code>），触发保护页，最终触发EDR的VEH时，EDR的检测机制被激活。一个可能的解决策略是使用偏移量0xF8的OriginalBase来确定真实DLL（如<code>ntdll.dll</code>）的基地址，而不是访问假DLL。然而，这可能会根据Windows的版本造成问题，因为OriginalBase的偏移量可能会有所不同。关于这一点的更详细研究尚未进行。</p>
<div class="highlight"><pre><span></span><span class="n">UINT_PTR</span> <span class="nf">NtdllOriginalDLLBase</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Read the PEB Offset from the GS Register</span>
    <span class="n">UINT_PTR</span> <span class="n">pebAddress</span> <span class="o">=</span> <span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="c1">// Access the PEB_LDR_DATA field within PEB</span>
    <span class="n">UINT_PTR</span> <span class="n">ldr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">pebAddress</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">);</span>
    <span class="c1">// Access the first entry in the InInitializationOrderModuleList</span>
    <span class="n">UINT_PTR</span> <span class="n">inInitOrderModuleList</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">ldr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="c1">// Traverse to the second module in the list (typically ntdll.dll)</span>
    <span class="n">UINT_PTR</span> <span class="n">secondModule</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">inInitOrderModuleList</span><span class="p">);</span>
    <span class="c1">// Uncomment the following line to advance to the third module</span>
    <span class="c1">// secondModule = *(UINT_PTR*)(secondModule);</span>

    <span class="c1">// Access the base address of the module by using Original Base</span>
    <span class="n">UINT_PTR</span> <span class="n">baseAddress</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT_PTR</span><span class="o">*</span><span class="p">)(</span><span class="n">secondModule</span> <span class="o">+</span> <span class="mh">0xF8</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">baseAddress</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h5 data-content="1" id="0062fe9c90d401dabfc2d51cf652556a">通过Flink访问正确的模块</h5>
<p>另一种策略可能是使用PEB遍历，特别是访问<code>双向链表InLoadOrderModuleList</code>中的第四个模块，这在本例中对应于正确的<code>ntdll.dll</code>，因此可以绕过EDR的假dll。然而，为了在实践中可靠地操作（例如，在红队准备期间你不知道目标环境中正在运行哪个EDR），可能需要实施额外的检查，例如，一个比较DLL名称的循环。这可以防止除非PEB被EDR修改，否则不访问<code>InLoadOrderModuleList</code>中的第四个模块。</p>
<div class="highlight"><pre><span></span><span class="c1">// Get base address from ntdll.dll on machine with default InLoadOrderModuleList in PEB </span>
    <span class="n">PLDR_DATA_TABLE_ENTRY</span> <span class="n">pLdrDataEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PLDR_DATA_TABLE_ENTRY</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pCurrentPeb</span><span class="o">-&gt;</span><span class="n">LoaderData</span><span class="o">-&gt;</span><span class="n">InMemoryOrderModuleList</span><span class="p">.</span><span class="n">Flink</span><span class="o">-&gt;</span><span class="n">Flink</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">);</span>

<span class="c1">// Get base address from ntdll.dll on machine with modified InLoadOrderModuleList in PEB in context of the analysed EDR</span>
    <span class="n">PLDR_DATA_TABLE_ENTRY</span> <span class="n">pLdrDataEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PLDR_DATA_TABLE_ENTRY</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pCurrentPeb</span><span class="o">-&gt;</span><span class="n">LoaderData</span><span class="o">-&gt;</span><span class="n">InMemoryOrderModuleList</span><span class="p">.</span><span class="n">Flink</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="o">-&gt;</span><span class="n">Flink</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">);</span>
</pre></div>
<h5 data-content="1" id="90c79806c00a833dbbfe7e63afc5a3f5">Windows API函数</h5>
<p>另一个可能的解决方法是使用Windows API函数<code>GetModuleHandleA</code>来确定<code>ntdll.dll</code>的基地址。以下代码展示了如何使用<code>GetModuleHandleA</code>来确定这个基地址。在安装了待分析EDR的系统上运行代码后，可以检查是正在访问真实<code>ntdll.dll</code>的内存区域还是假<code>ntdll.dll</code>的内存区域。通过这种方式，可以分析EDR对PEB的特定修改在多大程度上也影响了<code>GetModuleHandleA</code>的使用。</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">UINT_PTR</span> <span class="nf">NtdllGetModul</span><span class="p">(){</span>
    <span class="n">UINT_PTR</span> <span class="n">baseAddress</span> <span class="o">=</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">baseAddress</span><span class="p">;</span>
    <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">UINT_PTR</span> <span class="n">ntdllGetModul</span> <span class="o">=</span> <span class="n">NtdllGetModul</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Base address from ntdll via GetModuleHandleA: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">NtdllGetModul</span><span class="p">());</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Press any key to exit..."</span><span class="p">);</span>

    <span class="n">getchar</span><span class="p">();</span> <span class="c1">// wait for keypress</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>我们实验的结果，如下图所示，是在安装了正在调查的EDR的终端上使用<code>Windows API GetModuleHandleA</code>时，我们实际上进入了真实<code>ntdll.dll</code>的内存区域，而不是假<code>ntdll.dll</code>的内存区域。这表明，使用<code>GetModuleHandleA</code>访问模块或DLL的基地址提供了一种绕过EDR实现的假DLL以及页面保护挂钩的方法。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616113403-471fe092-2b91-1.png"/><br/>
然而，这个策略并不真正推荐，因为Windows API函数<code>GetModuleHandleA</code>、<code>GetProcAddress</code>、<code>LoadLibrary</code>等经常被EDR通过内联API挂钩监控。因此，这些API应该始终被避免，例如，在shellcode加载器或shellcode本身中。</p>
<h5 data-content="1" id="4fb3e011b276dffc4692e66901cbaed6">PEB遍历和字符串比较</h5>
<p>我想指出最后一个规避可能性。为了优化确定正确<code>ntdll.dll</code>的基地址，并确保你不会意外地获得假<code>ntdll.dll</code>的基地址，可以使用以下C代码。这种方法使用了PEB中<code>InLoadOrderModuleList</code>的遍历和字符串比较的组合来识别正确的<code>ntdll.dll</code>。具体来说，代码遍历加载的模块列表，将模块名称与<code>ntdll.dll</code>精确比较，并在有精确匹配时提取正确模块的基地址。这种方法是一种精确且相当可靠的解决方案，用于区分真实的<code>ntdll.dll</code>和潜在的假版本，并正确确定其基地址。</p>
<div class="highlight"><pre><span></span><span class="c1">// Resources: </span>
<span class="c1">// Hiding in Plain Sight: Unlinking Malicious DLLs from the PEB </span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;psapi.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_UNICODE_STRING</span> <span class="p">{</span>
    <span class="n">USHORT</span> <span class="n">Length</span><span class="p">;</span>
    <span class="n">USHORT</span> <span class="n">MaximumLength</span><span class="p">;</span>
    <span class="n">PWSTR</span>  <span class="n">Buffer</span><span class="p">;</span>
<span class="p">}</span> <span class="n">UNICODE_STRING</span><span class="p">,</span> <span class="o">*</span> <span class="n">PUNICODE_STRING</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PEB_LDR_DATA</span> <span class="p">{</span>
    <span class="n">BYTE</span>       <span class="n">Reserved1</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">PVOID</span>      <span class="n">Reserved2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">LIST_ENTRY</span> <span class="n">InMemoryOrderModuleList</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PEB_LDR_DATA</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPEB_LDR_DATA</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_LDR_DATA_TABLE_ENTRY</span> <span class="p">{</span>
    <span class="n">LIST_ENTRY</span> <span class="n">InLoadOrderLinks</span><span class="p">;</span>
    <span class="n">LIST_ENTRY</span> <span class="n">InMemoryOrderLinks</span><span class="p">;</span>
    <span class="n">LIST_ENTRY</span> <span class="n">InInitializationOrderLinks</span><span class="p">;</span>
    <span class="n">PVOID</span>      <span class="n">DllBase</span><span class="p">;</span>
    <span class="n">PVOID</span>      <span class="n">EntryPoint</span><span class="p">;</span>
    <span class="n">ULONG</span>      <span class="n">SizeOfImage</span><span class="p">;</span>
    <span class="n">UNICODE_STRING</span> <span class="n">FullDllName</span><span class="p">;</span>
    <span class="n">UNICODE_STRING</span> <span class="n">BaseDllName</span><span class="p">;</span>
<span class="p">}</span> <span class="n">LDR_DATA_TABLE_ENTRY</span><span class="p">,</span> <span class="o">*</span> <span class="n">PLDR_DATA_TABLE_ENTRY</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PEB</span> <span class="p">{</span>
    <span class="n">BYTE</span>                          <span class="n">Reserved1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">BYTE</span>                          <span class="n">BeingDebugged</span><span class="p">;</span>
    <span class="n">BYTE</span>                          <span class="n">Reserved2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">PVOID</span>                         <span class="n">Reserved3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">PPEB_LDR_DATA</span>                 <span class="n">Ldr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PEB</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPEB</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_MY_LDR_DATA_TABLE_ENTRY</span>
<span class="p">{</span>
    <span class="n">LIST_ENTRY</span>      <span class="n">InLoadOrderLinks</span><span class="p">;</span>
    <span class="n">LIST_ENTRY</span>      <span class="n">InMemoryOrderLinks</span><span class="p">;</span>
    <span class="n">LIST_ENTRY</span>      <span class="n">InInitializationOrderLinks</span><span class="p">;</span>
    <span class="n">PVOID</span>           <span class="n">DllBase</span><span class="p">;</span>
    <span class="n">PVOID</span>           <span class="n">EntryPoint</span><span class="p">;</span>
    <span class="n">ULONG</span>           <span class="n">SizeOfImage</span><span class="p">;</span>
    <span class="n">UNICODE_STRING</span>  <span class="n">FullDllName</span><span class="p">;</span>
    <span class="n">UNICODE_STRING</span>  <span class="n">ignored</span><span class="p">;</span>
    <span class="n">ULONG</span>           <span class="n">Flags</span><span class="p">;</span>
    <span class="n">SHORT</span>           <span class="n">LoadCount</span><span class="p">;</span>
    <span class="n">SHORT</span>           <span class="n">TlsIndex</span><span class="p">;</span>
    <span class="n">LIST_ENTRY</span>      <span class="n">HashTableEntry</span><span class="p">;</span>
    <span class="n">ULONG</span>           <span class="n">TimeDateStamp</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MY_LDR_DATA_TABLE_ENTRY</span><span class="p">;</span>


<span class="c1">// Returns a pointer to the PEB by reading the FS or GS registry</span>
<span class="n">PEB</span><span class="o">*</span> <span class="nf">get_peb</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#ifdef _WIN64</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PEB</span><span class="o">*</span><span class="p">)</span><span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="k">return</span>  <span class="p">(</span><span class="n">PEB</span><span class="o">*</span><span class="p">)</span><span class="n">__readfsdword</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="c1">// Get the base address of reall ntdll.dll by comparing the name of the DLL with "ntdll.dll" string and returning the base address of the DLL if the name contains "ntdll.dll"  </span>
<span class="n">PVOID</span> <span class="nf">get_ntdll_base_via_name_comparison</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PEB</span><span class="o">*</span> <span class="n">peb</span> <span class="o">=</span> <span class="n">get_peb</span><span class="p">();</span> <span class="c1">// Get a pointer to the PEB</span>
    <span class="n">LIST_ENTRY</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">peb</span><span class="o">-&gt;</span><span class="n">Ldr</span><span class="o">-&gt;</span><span class="n">InMemoryOrderModuleList</span><span class="p">;</span> <span class="c1">// Get the first entry in the list of loaded modules</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span> <span class="c1">// Move to the next entry</span>
        <span class="n">MY_LDR_DATA_TABLE_ENTRY</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">MY_LDR_DATA_TABLE_ENTRY</span><span class="p">,</span> <span class="n">InMemoryOrderLinks</span><span class="p">);</span>
        <span class="kt">char</span> <span class="n">dllName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span> <span class="c1">// Buffer to store the name of the DLL</span>
        <span class="c1">// Assuming FullDllName is a UNICODE_STRING, conversion to char* may require more than snprintf, consider proper conversion</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="n">dllName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dllName</span><span class="p">),</span> <span class="s">"%wZ"</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">FullDllName</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">dllName</span><span class="p">,</span> <span class="s">"ntdll.dll"</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Check if dllName contains "ntdll.dll"</span>
            <span class="k">return</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span><span class="p">;</span> <span class="c1">// Return the base address of ntdll.dll</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">peb</span><span class="o">-&gt;</span><span class="n">Ldr</span><span class="o">-&gt;</span><span class="n">InMemoryOrderModuleList</span><span class="p">);</span> <span class="c1">// Loop until we reach the first entry again</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Get the base address of ntdll.dll by comparing the name of the DLL with "ntdll.dll" string</span>
    <span class="n">PVOID</span> <span class="n">ntdll_base</span> <span class="o">=</span> <span class="n">get_ntdll_base_via_name_comparison</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ntdll_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"ntdll.dll not found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Base address from real ntdll.dll based on string or dll name comparison: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntdll_base</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Press any key to continue</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">getchar</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>下图展示了我们如何使用C代码避开EDR的假ntdll.dll，并成功确定真实ntdll.dll的基地址。<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20240616113747-cc61f6b4-2b91-1.png"/></p>
<h4 data-content="1" id="89b7a9575bfe737688f23229fcfabd7d">0X08 解读</h4>
<hr/>
<p>我想以对EDR系统的简短解读来结束我的分析。与其他EDR解决方案直接比较，基于假DLL、保护页和向量异常处理的描述检测机制被视为一种相当非传统的方法，更可能在游戏黑客领域中找到。然而，它在实践中被证明是非常有效的。根据我自己的经验，我可以说，成功绕过的时间和精力——定义为恶意软件既未被阻止也未被检测到的情况——与其他EDR系统相比显著更高。这种方法的复杂性和连贯结构使其看起来像一个“陷阱”。据我目前的理解，如果在进程初始化期间通过PEB遍历使用DLLBase偏移量0x30尝试访问ntdll.dll，但实际上最终进入了假ntdll.dll的内存，假ntdll.dll中的保护页才会被触发。然而，如果应用程序或恶意软件使用诸如GetModuleHandleA或LoadLibrary这样的API来获取ntdll.dll的句柄，假ntdll.dll、保护页和VEH机制将不起作用。然而，从恶意软件的角度来看，这种情况下EDR通过内联API挂钩的概率相对较高，因为GetModuleHandleA和LoadLibrary经常被内联挂钩。<br/>
虽然修改进程环境块（PEB）、结合页面保护挂钩和向量异常处理使用假DLL的过程相对容易理解，但在交给EDR的VEH之后究竟发生了什么仍然是一个未解之谜。一个可能但未经证实的假设是，受影响的线程或进程要么被直接杀死，要么交给EDR的挂钩DLL，由其决定是否杀死进程。然而，重要的是要强调，这些目前只是推测，不能被视为确凿的事实。<br/>
调查所描述的EDR机制对系统性能的影响也将是有益的，特别是与不遵循这种特定方法的其他EDR系统相比。鉴于页面保护挂钩和向量异常处理的过程，可能会预期这种方法会更加耗费系统资源。类似于内联API挂钩，EDR可以被限制到特定的API以最小化系统负载。这个假设得到了IDA中已识别的大约25个原生API的比较操作的支持，这可能表明EDR专注于选定的、关键的API以优化效率，而不会过度影响系统性能。</p>
</div>
</div>