CVE-2021-43527 Mozilla加密库NSS存在一个简单却很严重的缓存溢出漏洞
---------------------------------------------

NSS是一个类似OpenSSL的密码学库，由Mozilla公司开发维护，广泛应用于Firefox 、Thunderbird、LibreOffice等一些常用的软件当中。

近日，谷歌P0实验室安全研究员Tavis Ormandy披露了一个NSS缓存溢出漏洞。该漏洞形成原因非常简单，仅仅是因为没有对证书长度做限制，就导致了随后的内存复制操作触发了缓存溢出漏洞。

### 复现漏洞

CVE-2021-43527 的复现步骤也很简单。

1、利用openssl生成满足一定长度要求的证书，

`openssl genpkey -algorithm rsa-pss -pkeyopt rsa_keygen_bits:$((16384 + 64*5)) -pkeyopt rsa_keygen_primes:5 -out bigsig.key`

2、对证书自签名，

`openssl req -x509 -new -key bigsig.key -subj "/CN=BigSig" -sha256 -out bigsig.cer`

3、利用工具vfychain校验证书，即可触发漏洞。

`vfychain -a bigsig.cer`

复现漏洞的流程如下图所示。

[![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9f23d38ea5d8e7e77c1cc0f1acf819d37001922f.jpg)](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9f23d38ea5d8e7e77c1cc0f1acf819d37001922f.jpg)

### 分析漏洞

存在漏洞的函数vfy\_CreateContext，位于文件/nss/lib/cryptohi/secvfy.c，查看477行至490行。代码文件参考文章结尾附带链接。

[![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-fb5ca68bf9157274ec6d3c9c80115973ac81e80d.jpg)](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-fb5ca68bf9157274ec6d3c9c80115973ac81e80d.jpg)

489行存在内存copy操作，第一个参数cx-&gt;u.buffer，cx由456行复制而来，是一个结构体指针。

[![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-6326e2a91e7ffdf399146db806a05f0e65c64d79.jpg)](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-6326e2a91e7ffdf399146db806a05f0e65c64d79.jpg)

查看结构体VFYContext的定义，得知cx-&gt;u.buffer是固定长度的buffer。

[![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9631cf1d97846da5fe4b09bfd38742b6dd9e0370.jpg)](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9631cf1d97846da5fe4b09bfd38742b6dd9e0370.jpg)

第二个参数sig-&gt;data，由下图所示的函数定义可知，sig是需要校验的签名数据，其内容可以被攻击者完全控制。

[![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-0c295bc6693d3ab3bb5f2bd5e86a30880574a5a4.jpg)](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-0c295bc6693d3ab3bb5f2bd5e86a30880574a5a4.jpg)

第三个参数sigLen由漏洞代码块的478行赋值而来，再查看函数定义，确定sigLen是校验签名的公钥key的长度，该值同样可以被攻击者控制。

这样，只要绕过484行的对比检查，就可以触发漏洞。484行是判断公钥key的长度siglen与签名数据sig-&gt;len的长度是否相等，因为是自签名，所以两者相等是显而易见的。

至此，由上面的内存copy的三个参数分析可知，该漏洞是典型的缓存溢出漏洞。

下面来动态调试该漏洞，

1、启动调试，

`gdb vfychain`

2、打断点478行SECKEY\_SignatureLen函数，

`b SECKEY_SignatureLen`

3、单步执行，查看484行对比逻辑中sigLen与sig-&gt;len的值，两者都是2088。该值由生成密钥时(16384 + 64\*5)/8而来。继续执行，在调用memcpy之前，查看内存copy长度值sigLen的同样也是2088.

[![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-938c13f5a7d2e28a57d57119857f4df183895f4b.jpg)](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-938c13f5a7d2e28a57d57119857f4df183895f4b.jpg)

为什么是2088个字节，即(16384 + 64\*5)=16704位，查看结构体VFYContext的定义，这个长度正好可以覆盖指针变量hashobj，该指针后面会被调用。16384 是NSS定义的RSA签名算法最大模指位数，即RSA\_MAX\_MODULUS\_BITS，5个64分别是pkcs1RSADigestInfoLen、pkcs1RSADigestInfo、wincx、hashcx、hashobj的占位长度，正好可以覆盖hashobj。

继续执行，触发崩溃，查看调用栈，发现crash在VFY\_Begin函数，查看当前指令是call指令，查看寄存器rax的值

[![](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-f1d2b5cc8a2377175f1fc30e6e39dcf36a319cd3.jpg)](https://shs3.b.qianxin.com/attack_forum/2021/12/attach-f1d2b5cc8a2377175f1fc30e6e39dcf36a319cd3.jpg)

至此，可以看到call指令的地址可以被完全控制。

注意，直接校验bigsig.cer证书，rax的值是随机值，通过人为修改bigsig.cer结尾处的数据，可以控制寄存器rax的值。

### 总结

该漏洞原理非常简单，却存在了很多年。Mozilla 也有强大的安全团队和fuzz工具，也没能提早发现这个漏洞，说明现有的fuzz工具还是存在一定的缺陷。

如何挖掘类似于CVE-2021-43527的漏洞，是一件值得研究的事情。

### 参考资料

<https://cloud.tencent.com/developer/news/238252>

<https://searchfox.org/mozilla-central/rev/f8576fec48d866c5f988baaf1fa8d2f8cce2a82f/security/nss/lib/cryptohi/secvfy.c>

<https://searchfox.org/mozilla-central/rev/f8576fec48d866c5f988baaf1fa8d2f8cce2a82f/security/nss/lib/freebl/blapit.h#139>

<https://googleprojectzero.blogspot.com/2021/12/this-shouldnt-have-happened.html>

<https://bugs.chromium.org/p/project-zero/issues/detail?id=2237>