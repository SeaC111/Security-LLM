<div class="detail_content markdown-body editormd-preview-container" id="markdown-body">
<div id="app">
<p>目前。网上关于CVE-2015-4852漏洞的资料很多，但是针对CVE-2015-4852漏洞如何修复，修复补丁又是如何生效的却少之又少；而CVE-2016-0638、CVE-2016-3510这两个漏洞又是如何绕过CVE-2015-4852补丁的，则只是在介绍Weblogic系列漏洞时被一句话带过。</p>
<p>CVE-2015-4852、CVE-2016-0638以及CVE-2016-3510，这三个漏洞有着极其相似的地方，其本质就是利用了Weblogic反序列化机制，而官方在修复CVE-2015-4852时，也并未对这个机制进行调整，而仅仅是在此基础上增加了一个关卡：黑名单。</p>
<p>因此，在彻底搞清楚Weblogic反序列化漏洞的原理以及如何修复这个问题之前，很有必要弄清楚Weblogic处理流量中的java反序列化数据的流程。只有清楚了这一点，才能很好的理解如下几个问题：</p>
<ol>
<li>
<p>CVE-2015-4852是如何产生的以及后续是如何修复的？</p>
</li>
<li>
<p>修复CVE-2015-4852，为何要在resolveClass:108,InboundMsgAbbrev\$ServerChannelInputStream (weblogic.rjvm)处添加黑名单？</p>
</li>
<li>
<p>CVE-2016-0638、CVE-2016-3510是如何绕过修复？二者的绕过方式有何相同与不同？</p>
</li>
</ol>
<h2 data-content="1" id="6ea2d94751b23a614ef0d21a0f7f3428">Weblogic 反序列化攻击时序</h2>
<p>为了搞清楚CVE-2015-4852、CVE-2016-0638、CVE-2016-3510中的种种疑团，我们需要首先来弄明白一些原理性的东西，我们先从Weblogic<br/>
反序列化攻击时序入手，看看Weblogic是如何从流量中将序列化字节码进行反序列化。</p>
<p>首先贴出一张Weblogic 反序列化攻击时序图</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155439-aa3a40c0-1829-1.png"/></p>
<p>这张图是从我的好朋友廖新喜大佬博客扒下来的，也欢迎大家去读一读他的关于java漏洞的分析文章：</p>
<p><a href="http://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/" target="_blank">http://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/</a></p>
<p>上图为一张完整的Weblogic反序列化攻击时序图，庞大而且繁杂，不如我们将其拆分开，首先说说Weblogic如何从流量数据取出序列化数据并获取其类对象的过程。</p>
<h2 data-content="1" id="58e602470f119d7d8acf6baa80ddc558">从流量数据到Class对象</h2>
<p>首先我们来看一张图：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155452-b1e5a580-1829-1.png"/></p>
<p>Weblogic通过7001端口，获取到流量中T3协议的java反序列化数据。从上图中readObject开始，经过流程中的一步步的加工，并最终于上图流程终点处的resolveProxyClass或resolveClass处将流量中的代理类/类类型的字节流转变为了对应的Class对象。</p>
<p>首先我们可以发现：在ObjectInputStream (java.io)中的readClassDesc方法处，存在着分叉点，导致了序列化流量流向了两个不同的分支：其中一些流量流向了readProxyDesc并最终采用resolveProxyClass获取类对象，而另一些则流向了readNonProxyDesc并最终使用resolveClass获取类对象。</p>
<h3 data-content="1" id="d635d9235d550105c01c4aef940e0e0a">readClassDesc是什么？</h3>
<p>从上文来看，流量数据经过readClassDesc并驶入了不同的处理分支。</p>
<p>首先来看一下readClassDesc方法的官方注释：“readClassDesc方法读入并返回（可能为null）类描述符。将passHandle设置为类描述符的已分配句柄。”</p>
<p>如果想理解官方注释的含义，需要扩充一些java序列化的知识：</p>
<p>java序列化数据在流量传输，并不是随随便便杂乱无章的，序列化数据的格式是要遵循序列化流协议。</p>
<p>序列化流协议定义了字节流中传输的对象的基本结构。该协议定义了对象的每个属性：其类，其字段以及写入的数据，以及以后由类特定的方法读取的数据。</p>
<p>字节流中对象的表示可以用一定的语法格式来描述。对于空对象，新对象，类，数组，字符串和对流中已有对象的反向引用，都有特殊的表示形式。比如说在字节流中传递的序列化数据中，字符串有字符串类型的特定格式、对象有对象类型的特定格式、类结构有着类结构。而TC_STRING、TC_OBJECT、TC_CLASSDESC则是他们的描述符，他们标识了接下来这段字节流中的数据是什么类型格式的</p>
<p>以TC_CLASSDESC为例，TC_CLASSDESC在流量中的值是(byte)0x72，在序列化流协议中，当这个值出现后，代表接下来的数据将开始一段Class的描述(DESC=description)，即TC_CLASSDESC描述符(byte)0x72后面的字节流数据为Class类型。通过这些描述符，程序可以正确的解析流量中的序列化数据。</p>
<p>如果对这部分感兴趣，可以参照oracle文档：</p>
<p><a href="https://www.oracle.com/security-alerts/cpuoct2020traditional.html" target="_blank">https://www.oracle.com/security-alerts/cpuoct2020traditional.html</a></p>
<p>readClassDesc的功能很简单：读入字节流，通过读取字节流中的描述符来确定字节流中传递数据的类型，并交给对应的方法进行处理。</p>
<p>接下来我们看看readClassDesc的实现</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="n">ObjectStreamClass</span> <span class="nf">readClassDesc</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">unshared</span><span class="o">)</span> 
    <span class="kd">throws</span> <span class="n">IOException</span> 
    <span class="o">{</span>
    <span class="kt">byte</span> <span class="n">tc</span> <span class="o">=</span> <span class="n">bin</span><span class="o">.</span><span class="na">peekByte</span><span class="o">();</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">tc</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">TC_NULL</span><span class="o">:</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">ObjectStreamClass</span><span class="o">)</span> <span class="n">readNull</span><span class="o">();</span>

        <span class="k">case</span> <span class="n">TC_REFERENCE</span><span class="o">:</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">ObjectStreamClass</span><span class="o">)</span> <span class="n">readHandle</span><span class="o">(</span><span class="n">unshared</span><span class="o">);</span>

        <span class="k">case</span> <span class="n">TC_PROXYCLASSDESC</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">readProxyDesc</span><span class="o">(</span><span class="n">unshared</span><span class="o">);</span>

        <span class="k">case</span> <span class="n">TC_CLASSDESC</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">readNonProxyDesc</span><span class="o">(</span><span class="n">unshared</span><span class="o">);</span>

<span class="nl">        default:</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">StreamCorruptedException</span><span class="o">(</span>
            <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"invalid type code: %02X"</span><span class="o">,</span> <span class="n">tc</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="o">}</span>
</pre></div>
<p>从readClassDesc方法的实现可见，readClassDesc中switch语句有5个分支（TC_NULL、TC_REFERENCE、TC_PROXYCLASSDESC、TC_CLASSDESC、default）。</p>
<pre><code>TC_NULL描述符表示空对象引用

TC_REFERENCE描述符表示引用已写入流的对象

TC_PROXYCLASSDESC是新的代理类描述符

TC_CLASSDESC是新的类描述符</code></pre>
<p>那么我们为什么在上文流程图里只画出了其中两处分支（TC_PROXYCLASSDESC、TC_CLASSDESC）呢？</p>
<p>我们先来看看Weblogic反序列化漏洞成的原理：Weblogic反序列化漏洞是由于通过流量中传入的恶意类而未得到合理的过滤，最终被反序列化而形成。</p>
<p>从原理上来看，是weblogic对流量中序列化后的类对象处理时出现的问题。</p>
<p>基于这一点，我们应重点关注程序是如何从流量中获取并处理类类型数据的流程。</p>
<p>TC_PROXYCLASSDESC与TC_CLASSDESC描述符标识了流量中代理类与类这两种类型的数据，因此我们重点关注TC_PROXYCLASSDESC与TC_CLASSDESC这两处分支，这也是上文流程图里只有这两处分支的原因。</p>
<p>当readClassDesc从字节流中读取到TC_CLASSDESC描述符，说明此处程序此时要处理的字节流为普通类，程序接下来会调用readNonProxyDesc方法对这段字节流进行解析。</p>
<p>在readNonProxyDesc方法中，程序会从该段序列化流中获取类的序列化描述符ObjectStreamClass（类序列化描述符ObjectStreamClass，其本质是对Class类的包装，可以想象成一个字典，里面记录了类序列化时的一些信息，包括字段的描述信息和serialVersionUID 和需要序列化的字段fields，以便在反序列化时拿出来使用）。随后该类的序列化描述符被传递给resolveClass方法，resolveClass方法从该类的序列化描述符中获取对应的Class对象。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155508-bbe2ab14-1829-1.png"/></p>
<p>当readClassDesc从字节流中读取到TC_PROXYCLASSDESC描述符时，说明此处程序此时要处理的字节流为动态代理类，程序接下来会调用readProxyDesc方法进行处理，过程与上文一致，不再复述。</p>
<p>我们以此处传入的字节流为普通类为例，接下来看看resolveClass是如何将类的序列化描述符加工成该类的Class对象</p>
<p>位于weblogic/rjvm/InboundMsgAbbrev.class中的resolveClass方法</p>
<div class="highlight"><pre><span></span><span class="kd">protected</span> <span class="n">Class</span> <span class="nf">resolveClass</span><span class="o">(</span><span class="n">ObjectStreamClass</span> <span class="n">var1</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
            <span class="n">Class</span> <span class="n">var2</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">resolveClass</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">var2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">ClassNotFoundException</span><span class="o">(</span><span class="s">"super.resolveClass returns null."</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">ObjectStreamClass</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">ObjectStreamClass</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="n">var2</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">var3</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">var3</span><span class="o">.</span><span class="na">getSerialVersionUID</span><span class="o">()</span> <span class="o">!=</span> <span class="n">var1</span><span class="o">.</span><span class="na">getSerialVersionUID</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="n">ClassNotFoundException</span><span class="o">(</span><span class="s">"different serialVersionUID. local: "</span> <span class="o">+</span> <span class="n">var3</span><span class="o">.</span><span class="na">getSerialVersionUID</span><span class="o">()</span> <span class="o">+</span> <span class="s">" remote: "</span> <span class="o">+</span> <span class="n">var1</span><span class="o">.</span><span class="na">getSerialVersionUID</span><span class="o">());</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">var2</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
</pre></div>
<p>程序通过Class var2 = super.resolveClass(var1); 从ObjectStreamClass var1中获取到对应的类对象，并赋值给var2，最终通过执行return var2，将var1序列化描述符所对应的Class对象返回</p>
<p>我们以熟悉的CVE-2015-4852利用链为例，动态调试一下resolveClass方法</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155521-c3a488ae-1829-1.png"/></p>
<p>可见resolveClass方法成功从序列化描述符中获取到”sun.reflect.annotation.AnnotationInvocationHandler”类对象，并将其返回</p>
<p>到目前为止，我们已经搞明白了weblogic如何将流量中的类字节流转变为对应的Class对象。以上这部分知识，有助于我们理解Weblogic官方的修复方案。而接下来我们要谈论的是在Weblogic获得到Class对象后要做的事情，通过对这部分流程的理解，将会帮助你很轻松的理解为什么CVE-2015-4852、CVE-2016-0638、CVE-2016-3510的poc是如何奏效的。</p>
<h2 data-content="1" id="08b530d8e553c54872e991c1f9431b68">从Class对象到代码执行</h2>
<p>通过上文的介绍可知，程序通过resolveClass获取Class对象，在resolveClass方法将获取到的Class对象返回后，上一级的readNonProxyDesc在接收到resolveClass方法返回值后，连同之前从流量中获取类的序列化描述符ObjectStreamClass一并，初始化并构建一个新的ObjectStreamClass，这个流程如下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201102141936-616bba0a-1cd3-1.png"/></p>
<p>关键部分代码如下</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="n">ObjectStreamClass</span> <span class="nf">readNonProxyDesc</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">unshared</span><span class="o">)</span> 
<span class="kd">throws</span> <span class="n">IOException</span> 
   <span class="o">{</span>
<span class="o">...</span>

<span class="n">ObjectStreamClass</span> <span class="n">desc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectStreamClass</span><span class="o">();</span>
<span class="o">...</span>

<span class="n">ObjectStreamClass</span> <span class="n">readDesc</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">...</span>
    <span class="n">readDesc</span> <span class="o">=</span> <span class="n">readClassDescriptor</span><span class="o">();</span>
<span class="o">...</span>

<span class="n">Class</span> <span class="n">cl</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">...</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">cl</span> <span class="o">=</span> <span class="n">resolveClass</span><span class="o">(</span><span class="n">readDesc</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">resolveEx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassNotFoundException</span><span class="o">(</span><span class="s">"null class"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span>
<span class="n">desc</span><span class="o">.</span><span class="na">initNonProxy</span><span class="o">(</span><span class="n">readDesc</span><span class="o">,</span> <span class="n">cl</span><span class="o">,</span> <span class="n">resolveEx</span><span class="o">,</span> <span class="n">readClassDesc</span><span class="o">(</span><span class="kc">false</span><span class="o">));</span>

<span class="o">...</span>
<span class="k">return</span> <span class="n">desc</span><span class="o">;</span>
   <span class="o">}</span>
</pre></div>
<p>结合流程图与代码来看，readNonProxyDesc方法中主要做了如下这些事情</p>
<p>1、通过readClassDescriptor()方法从流量中获取序列化类的ObjectStreamClass并赋值给readDesc变量</p>
<p>2、将readDesc传入resolveClass，获取该类的Class对象并赋值给cl变量</p>
<p>3、将该类的ObjectStreamClass与Class对象传入initNonProxy方法，初始化一个ObjectStreamClass并赋值给desc变量</p>
<p>4、将desc变量返回</p>
<p>readNonProxyDesc方法中返回的ObjectStreamClass类型的desc变量，将会传递给readClassDesc，进而被readClassDesc传递给readOrdinaryObject</p>
<p>readOrdinaryObject、readClassDesc与readNonProxyDesc的调用关系如下：</p>
<p>readOrdinaryObject中调用readClassDesc:</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="n">Object</span> <span class="nf">readOrdinaryObject</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">unshared</span><span class="o">)</span> 
<span class="kd">throws</span> <span class="n">IOException</span> 
   <span class="o">{</span>
<span class="o">...</span>

<span class="n">ObjectStreamClass</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">readClassDesc</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">...</span>
</pre></div>
<p>readClassDesc中调用readNonProxyDesc:</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="n">ObjectStreamClass</span> <span class="nf">readClassDesc</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">unshared</span><span class="o">)</span> 
<span class="kd">throws</span> <span class="n">IOException</span> 
   <span class="o">{</span>
<span class="kt">byte</span> <span class="n">tc</span> <span class="o">=</span> <span class="n">bin</span><span class="o">.</span><span class="na">peekByte</span><span class="o">();</span>
<span class="k">switch</span> <span class="o">(</span><span class="n">tc</span><span class="o">)</span> <span class="o">{</span>
<span class="o">...</span>
    <span class="k">case</span> <span class="n">TC_CLASSDESC</span><span class="o">:</span>
   <span class="k">return</span> <span class="n">readNonProxyDesc</span><span class="o">(</span><span class="n">unshared</span><span class="o">);</span>
</pre></div>
<p>因此，当readNonProxyDesc中ObjectStreamClass类型的desc变量返回后，途径readClassDesc方法的最终传递给readOrdinaryObject中的desc变量</p>
<p>接下来看看readOrdinaryObject方法中部分片段</p>
<div class="highlight"><pre><span></span><span class="n">ObjectStreamClass</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">readClassDesc</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">...</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">desc</span><span class="o">.</span><span class="na">isInstantiable</span><span class="o">()</span> <span class="o">?</span> <span class="n">desc</span><span class="o">.</span><span class="na">newInstance</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">...</span>
<span class="k">if</span> <span class="o">(</span><span class="n">desc</span><span class="o">.</span><span class="na">isExternalizable</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">readExternalData</span><span class="o">((</span><span class="n">Externalizable</span><span class="o">)</span> <span class="n">obj</span><span class="o">,</span> <span class="n">desc</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">readSerialData</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">desc</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">handles</span><span class="o">.</span><span class="na">finish</span><span class="o">(</span><span class="n">passHandle</span><span class="o">);</span>

<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> 
    <span class="n">handles</span><span class="o">.</span><span class="na">lookupException</span><span class="o">(</span><span class="n">passHandle</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
    <span class="n">desc</span><span class="o">.</span><span class="na">hasReadResolveMethod</span><span class="o">())</span>
<span class="o">{</span>
    <span class="n">Object</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">desc</span><span class="o">.</span><span class="na">invokeReadResolve</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</pre></div>
<p>上述代码中的第一行：</p>
<div class="highlight"><pre><span></span><span class="n">ObjectStreamClass</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">readClassDesc</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</pre></div>
<p>代码中由readClassDesc(false)执行得到的desc，即是readNonProxyDesc中获取并返回的ObjectStreamClass类型的desc</p>
<div class="highlight"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">desc</span><span class="o">.</span><span class="na">isInstantiable</span><span class="o">()</span> <span class="o">?</span> <span class="n">desc</span><span class="o">.</span><span class="na">newInstance</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
</pre></div>
<p>代码中接下来的条件分支，即是在获取了ObjectStreamClass类型的desc后，readOrdinaryObject接着尝试调用类对象中的readObject、readResolve、readExternal等方法。</p>
<p>关于readObject、readResolve、readExternal等方法的调用，将其整理成流程图，有助于对其更好的理解，流程图如下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155537-cca7961c-1829-1.png"/></p>
<p>在Weblogic从流量中的序列化类字节段通过readClassDesc-readNonProxyDesc-resolveClass获取到普通类序列化数据的类对象后，程序依次尝试调用类对象中的readObject、readResolve、readExternal等方法。</p>
<p>在这里提前透露下，CVE-2015-4852、CVE-2016-0638、CVE-2016-3510这三个漏洞，所利用的恰好依次是恶意类”sun.reflect.annotation.AnnotationInvocationHandler”中的readObject、”weblogic.jms.common.StreamMessageImpl”中的readExternal、以及”weblogic.corba.utils.MarshalledObject”中的readResolve方法</p>
<p>试想一下这个场景：在没有任何防护或防护不当的时候，攻击者通过流量中传入恶意类的序列化数据，weblogic将流量中的序列化数据还原为其对应的Class对象，并尝试执行恶意类中的readObject、readResolve、readExternal等方法。这就是CVE-2015-4852、CVE-2016-0638、CVE-2016-3510漏洞的核心。</p>
<h2 data-content="1" id="5d6b96f60f33282a3d976c6a1bd988d9">CVE-2015-4852</h2>
<p>在分析过流程之后，这个漏洞呼之欲出。简单来说，在CVE-2015-4852漏洞爆发之前，weblogic对流量中的序列化数据没有任何的校验，长驱直入的恶意数据最终被还原出其Class对象，并被Weblogic调用了其Class对象中的readObject方法，结合CVE-2015-4852细节来说就是：</p>
<ol>
<li>
<p>精心构造的ChainedTransformer恶意链（以下简称恶意数据）</p>
</li>
<li>
<p>将构造好的恶意数据包裹在AnnotationInvocationHandler类的memberValues变量中</p>
</li>
<li>
<p>在流量中构造并传入上述制作好的AnnotationInvocationHandler类的序列化数据</p>
</li>
<li>
<p>Weblogic获取AnnotationInvocationHandler类的Class对象</p>
</li>
<li>
<p>Weblogic尝试调用AnnotationInvocationHandler类的readObject方法</p>
</li>
<li>
<p>AnnotationInvocationHandler类中readObject中存在一些有助于漏洞利用的操作（AnnotationInvocationHandler的readObject方法中对其memberValues的每一项调用了setValue方法进而调用了checkSetValue）</p>
</li>
<li>
<p>恶意数据存放在memberValues中伺机而动。恶意数据的原理我们就不细说了，简单来说就是，当恶意数据的checkSetValue被触发，就能造成命令执行</p>
</li>
<li>
<p>等到readObject方法对memberValues的每一项调用setValue方法执行时，setValue方法会进而调用并触发恶意数据的checkSetValue，造成命令执行</p>
</li>
</ol>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155550-d4cf730a-1829-1.png"/></p>
<h2 data-content="1" id="dbd648de94f3c49d5d3a796bdf99f440">Weblogic的防护机制</h2>
<p>CVE-2015-4852这个漏洞利用出现之后，官方对Weblogic进行了一些改造，增加了一些安全防护。至于怎么防护，说起来很简单，以普通类为例，见下图：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155559-da0eb3b2-1829-1.png"/></p>
<p>resolveClass方法的作用是从类序列化描述符获取类的Class对象，在resolveClass中增加一个检查，检查一下该类的序列化描述符中记录的类名是否在黑名单上，如果在黑名单上，直接抛出错误，不允许获取恶意的类的Class对象。这样以来，恶意类连生成Class对象的机会都没有，更何况要执行恶意类中的<br/>
readObject、readResolve、readExternal呢。</p>
<p>我们看一下具体是怎么实现的，见下图：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155626-e9e7005a-1829-1.png"/></p>
<p>可见更新之后多出了一个if条件分支，通过isBlackListed校验传入的类名用来处理代理类的resolveProxyClass也是一样的方式，不再复述。</p>
<p>从整体上来看，检查模块主要在下图红框里</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155635-ef801b3c-1829-1.png"/></p>
<p>在修复过后，CVE-2015-4852已经不能成功利用了：CVE-2015-4852所使用到的AnnotationInvocationHandler在黑名单中，会直接报错而不能获取其Class对象，更不能执行其中的readObject。</p>
<h2 data-content="1" id="c15768efa6230239f8fca0b217252c6c">CVE-2016-0638</h2>
<p>这个漏洞主要是找到了个黑名单之外的类"weblogic.jms.common.StreamMessageImpl"</p>
<p>简单来说，由于黑名单的限制，CVE-2015-4852利用链没法直接使用，这个漏洞像是整了个套娃，给CVE-2015-4852装进去了。</p>
<p>为什么使用StreamMessageImpl这个类呢？其实原理也很简单。StreamMessageImpl类中的readExternal方法可以接收序列化数据作为参数，而当StreamMessageImpl类的readExternal执行时，会反序列化传入的参数并执行该参数反序列化后对应类的readObject方法。我们动态调试一下，见下图</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155645-f52e107a-1829-1.png"/></p>
<p>如果我们把序列化后的CVE-2015-4852利用链序列化之后丢进readExternal呢？</p>
<p>当我们给上图StreamMessageImpl类的readExternal中传入序列化后的CVE-2015-4852利用链，在readExternal被执行时，会将CVE-2015-4852利用链数据反序列化，并在上图864行处调用其readObject方法，也就是AnnotationInvocationHandler的readObject方法</p>
<p>好了，AnnotationInvocationHandler的readObject方法被调用了，CVE-2015-4852复活了。</p>
<p>但是StreamMessageImpl类的readExternal要怎么被执行呢?别忘了上文分析的Weblogic反序列化流程，在获取到StreamMessageImpl类的Class对象后，程序可不止调用其readObject方法，还会尝试调用readExternal的。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155655-fb5f308c-1829-1.png"/></p>
<h2 data-content="1" id="9797cf0f9ac04d3312be5eae8aaf282f">CVE-2016-3510</h2>
<p>这个漏洞与上一个几乎一致，也是做了个套娃给CVE-2015-4852利用链装进去了，从而绕过了黑名单限制。</p>
<p>这次找到的是weblogic.corba.utils.MarshalledObject</p>
<p>首先看一下这个类的构造方法</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="nf">MarshalledObject</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">var1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="mi">13</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">ByteArrayOutputStream</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
        <span class="n">MarshalledObject</span><span class="o">.</span><span class="na">MarshalledObjectOutputStream</span> <span class="n">var3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MarshalledObject</span><span class="o">.</span><span class="na">MarshalledObjectOutputStream</span><span class="o">(</span><span class="n">var2</span><span class="o">);</span>
        <span class="n">var3</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
        <span class="n">var3</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">objBytes</span> <span class="o">=</span> <span class="n">var2</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">var4</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">var5</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">var5</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">objBytes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">var5</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">var4</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">var4</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">objBytes</span><span class="o">[</span><span class="n">var5</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">var4</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>可以发现，这个类的构造方法接收一个Object类型的参数var1，然后将传入的Object参数序列化后转换为byte数组的形式赋值给this.objBytes</p>
<p>我们接下来看看MarshalledObject的readResolve方法</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">Object</span> <span class="nf">readResolve</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">ObjectStreamException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">objBytes</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">ByteArrayInputStream</span> <span class="n">var1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">objBytes</span><span class="o">);</span>
        <span class="n">ObjectInputStream</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
        <span class="n">Object</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">var2</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
        <span class="n">var2</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">var3</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>可见，MarshalledObject的readResolve方法将this.objBytes反序列化，并执行其readObject。this.objBytes可以由MarshalledObject构造方法中传入的var参数控制</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201027155707-028637ca-182a-1.png"/></p>
<p>这样以来，将CVE-2015-4852利用链传入MarshalledObject构造方法中，将MarshalledObject序列化后，则可以将CVE-2015-4852利用链保存在其this.objBytes变量中。当weblogic将构造好的MarshalledObject反序列化时，weblogic将尝试调用MarshalledObject的readResolve方法时，CVE-2015-4852利用链被执行</p>
<p>如果对如何构造的poc细节不是很清楚，可以参照这个链接</p>
<p><a href="https://github.com/zhzhdoai/Weblogic_Vuln/blob/master/Weblogic_Vuln/src/main/java/com/weblogcVul/CVE_2016_3510.java" target="_blank">https://github.com/zhzhdoai/Weblogic_Vuln/blob/master/Weblogic_Vuln/src/main/java/com/weblogcVul/CVE_2016_3510.java</a></p>
<h2 data-content="1" id="6d8d78d7f933a0d2ea7c460ae81118c6">总结</h2>
<p>Weblogic的前三个反序列化漏洞并不复杂，但是对其的研究和分析是有一定的方式的，仅仅从单一的漏洞分析入手，很容易看不懂，反而把漏洞弄得复杂化。在了解了漏洞流程之后，再回头来看，这几个漏洞的原理便呼之欲出。</p>
</div>
</div>